{"version":3,"sources":["../../src/utils/objects.ts"],"sourcesContent":["import fp from \"lodash/fp\";\nimport type { Get, IsEqual, EmptyObject } from \"type-fest\";\nimport { Expand } from \"./types\";\n\ntype UpdaterFn<T extends object, P extends string, V extends Get<T, P>> = (\n\tval: IsEqual<Get<T, P>, unknown> extends true ? never : V,\n) => IsEqual<Get<T, P>, unknown> extends true ? never : V;\n\nfunction update<T extends object, P extends string, V extends Get<T, P>>(\n\tpath: P,\n\tupdater: UpdaterFn<T, P, V>,\n): (obj: T) => IsEqual<Get<T, P>, unknown> extends true ? unknown : T;\n\nfunction update<T extends object, P extends string, V extends Get<T, P>>(\n\tobj: T,\n\tpath: P,\n\tupdater: UpdaterFn<T, P, V>,\n): IsEqual<Get<T, P>, unknown> extends true ? unknown : T;\n\nfunction update<T extends object, P extends string, V extends Get<T, P>>(...args: [P, UpdaterFn<T, P, V>] | [T, P, UpdaterFn<T, P, V>]) {\n\tif (args.length === 3) {\n\t\tconst [obj, path, updater] = args;\n\t\treturn fp.update(path)(updater)(obj);\n\t}\n\tconst [path, updater] = args;\n\treturn fp.update(path)(updater);\n}\n\nconst entries = <T extends object>(obj: T) => Object.entries(obj) as [keyof T, T[keyof T]][];\n\ntype Path = string | readonly string[];\n\n/** Proxy for lodash fp `set` with better type inference. Overloaded to support both imperative and point free style.\n *\n * If an invalid path is passed, the type of the `value` parameter is `never` which should cause a type error.\n * Do **not** do an `as never` assertion to get around this, but instead make sure that the path is correct.\n *\n * Dynamic paths is supported if an array is passed as `path`.\n * If an array is passed as `path`, it needs to be `const`: `[\"foo\", \"bar\"] as const`\n */\nfunction set<T extends object, P extends Path, V extends Get<T, P>>(\n\tpath: P,\n\tvalue: IsEqual<Get<T, P>, unknown> extends true ? never : V,\n): (obj: T) => IsEqual<Get<T, P>, unknown> extends true ? unknown : T;\n\nfunction set<T extends object, P extends Path, V extends Get<T, P>>(\n\tobj: T,\n\tpath: P,\n\tvalue: IsEqual<Get<T, P>, unknown> extends true ? never : V,\n): IsEqual<Get<T, P>, unknown> extends true ? unknown : T;\n\nfunction set<T extends object, P extends Path, V extends Get<T, P>>(...args: [P, V] | [T, P, V]) {\n\tif (args.length === 3) {\n\t\tconst [obj, path, value] = args;\n\t\treturn fp.set(path)(value)(obj);\n\t}\n\tconst [path, value] = args;\n\treturn fp.set(path)(value);\n}\n\nexport type SetProp<P extends string, V, T extends object> = Expand<\n\tP extends `${infer K}.${infer Tail}`\n\t\t? K extends keyof T\n\t\t\t? { [k in keyof T]: k extends K ? SetProp<Tail, V, EmptyObject> : T[k] }\n\t\t\t: { [k in K]: SetProp<Tail, V, EmptyObject> } & (T extends EmptyObject ? {} : T)\n\t\t: P extends keyof T\n\t\t\t? { [k in keyof T]: k extends P ? V : T[k] }\n\t\t\t: { [k in P]: V } & (T extends EmptyObject ? {} : T)\n>;\n\nfunction setProp<T extends object, P extends string, V>(obj: T, path: P, value: V): SetProp<P, V, T>;\nfunction setProp<T extends object, P extends string, V>(path: P, value: V): (obj: T) => SetProp<P, V, T>;\nfunction setProp<T extends object, P extends string, V>(...args: [T, P, V] | [P, V]) {\n\tif (args.length === 3) {\n\t\tconst [obj, path, value] = args;\n\t\treturn fp.set(path, value)(obj);\n\t}\n\tconst [path, value] = args;\n\treturn (obj: T) => fp.set(path, value)(obj);\n}\n\nexport { update, entries, set, setProp };\n"],"mappings":";AAAA,OAAO,QAAQ;AAmBf,SAAS,UAAmE,MAA4D;AACvI,MAAI,KAAK,WAAW,GAAG;AACtB,UAAM,CAAC,KAAKA,OAAMC,QAAO,IAAI;AAC7B,WAAO,GAAG,OAAOD,KAAI,EAAEC,QAAO,EAAE,GAAG;AAAA,EACpC;AACA,QAAM,CAAC,MAAM,OAAO,IAAI;AACxB,SAAO,GAAG,OAAO,IAAI,EAAE,OAAO;AAC/B;AAEA,MAAM,UAAU,CAAmB,QAAW,OAAO,QAAQ,GAAG;AAuBhE,SAAS,OAA8D,MAA0B;AAChG,MAAI,KAAK,WAAW,GAAG;AACtB,UAAM,CAAC,KAAKD,OAAME,MAAK,IAAI;AAC3B,WAAO,GAAG,IAAIF,KAAI,EAAEE,MAAK,EAAE,GAAG;AAAA,EAC/B;AACA,QAAM,CAAC,MAAM,KAAK,IAAI;AACtB,SAAO,GAAG,IAAI,IAAI,EAAE,KAAK;AAC1B;AAcA,SAAS,WAAkD,MAA0B;AACpF,MAAI,KAAK,WAAW,GAAG;AACtB,UAAM,CAAC,KAAKF,OAAME,MAAK,IAAI;AAC3B,WAAO,GAAG,IAAIF,OAAME,MAAK,EAAE,GAAG;AAAA,EAC/B;AACA,QAAM,CAAC,MAAM,KAAK,IAAI;AACtB,SAAO,CAAC,QAAW,GAAG,IAAI,MAAM,KAAK,EAAE,GAAG;AAC3C;","names":["path","updater","value"]}