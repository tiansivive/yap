{"version":3,"sources":["../../src/utils/types.ts"],"sourcesContent":["export type Extend<T, Brand extends symbol, Metadata> = [RecursiveExtend<T, Brand, Metadata>, Metadata];\n\ntype RecursiveExtend<T, Brand extends symbol, Metadata> = T extends object\n\t? {\n\t\t\t[K in keyof T]: T[K] extends { [S in Brand]: void } ? [RecursiveExtend<T[K], Brand, Metadata>, Metadata] : RecursiveExtend<T[K], Brand, Metadata>;\n\t\t}\n\t: T;\n\nexport type Prettify<T> = {\n\t[K in keyof T]: T[K];\n} & {};\n\nexport type Tag<Str extends string, T> = T & { __tag: Str };\n\nexport type SetProp<P extends string, V, T extends object> = (P extends `${infer K}.${infer Tail}`\n\t? K extends `${infer KK}[${infer I extends number}]`\n\t\t? { [key in KK]: { [key in I]: SetProp<Tail, V, {}> } }\n\t\t: { [key in K]: SetProp<Tail, V, {}> }\n\t: P extends string\n\t\t? { [key in P]: V }\n\t\t: never) &\n\tT;\n\n/**\n * Type utility to force typescript to early evaluate the type.\n * This is useful for clarifying type computations\n */\nexport type Expand<T> = T extends unknown ? { [K in keyof T]: T[K] } : never;\n\nexport type Tags<T, K> = K extends string ? (T extends { [k in K]: infer U } ? U : never) : never;\n\nexport type Brand<S extends symbol, T> = T & { [K in S]: void };\nexport const make = <T, S extends symbol>(s: S, a: T): Brand<S, T> => {\n\treturn Object.defineProperty(a, s, { value: void 0 }) as Brand<S, T>;\n};\n"],"mappings":";AAgCO,MAAM,OAAO,CAAsB,GAAM,MAAsB;AACrE,SAAO,OAAO,eAAe,GAAG,GAAG,EAAE,OAAO,OAAO,CAAC;AACrD;","names":[]}