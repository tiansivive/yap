{"version":3,"sources":["../../src/elaboration/module.ts"],"sourcesContent":["import * as EB from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as M from \"@yap/elaboration/shared/monad\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport { Either } from \"fp-ts/lib/Either\";\n\nimport * as E from \"fp-ts/lib/Either\";\nimport * as F from \"fp-ts/lib/function\";\n\nimport { set, update } from \"@yap/utils\";\n\nimport { Interface } from \"../modules/loading\";\nimport { solve } from \"./solver\";\nimport * as A from \"fp-ts/lib/Array\";\n\nimport * as Sub from \"@yap/elaboration/unification/substitution\";\nimport { VerificationService } from \"@yap/verification/service\";\nimport { match } from \"ts-pattern\";\nimport { Bool, init } from \"z3-solver\";\n\nexport const elaborate = (mod: Src.Module, ctx: EB.Context) => {\n\tconst maybeExport = (name: string) => (result: Omit<Interface, \"imports\">) => {\n\t\tif (\n\t\t\tmod.exports.type === \"*\" ||\n\t\t\t(mod.exports.type === \"explicit\" && mod.exports.names.includes(name)) ||\n\t\t\t(mod.exports.type === \"partial\" && !mod.exports.hiding.includes(name))\n\t\t) {\n\t\t\treturn update(result, \"exports\", A.append(name));\n\t\t}\n\t\treturn result;\n\t};\n\n\ttype Pair = [string, Either<EB.V2.Err, EB.AST>];\n\tconst next = (stmts: Src.Statement[], ctx: EB.Context): Omit<Interface, \"imports\"> => {\n\t\tif (stmts.length === 0) {\n\t\t\treturn { foreign: [], exports: [], letdecs: [], errors: [] };\n\t\t}\n\n\t\tconst [head, ...tail] = stmts;\n\n\t\tif (head.type === \"using\") {\n\t\t\treturn F.pipe(\n\t\t\t\tusing(head, ctx),\n\t\t\t\tE.match(\n\t\t\t\t\te => update(next(tail, ctx), \"errors\", A.prepend(e)),\n\t\t\t\t\tctx => next(tail, ctx),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (head.type === \"foreign\") {\n\t\t\tconst [name, result] = foreign(head, ctx);\n\t\t\treturn F.pipe(\n\t\t\t\tresult,\n\t\t\t\tE.match(\n\t\t\t\t\te => update(next(tail, ctx), \"foreign\", A.prepend<Pair>([name, E.left(e)])),\n\t\t\t\t\t([ast, ctx]) => F.pipe(next(tail, ctx), update(\"foreign\", A.prepend<Pair>([name, E.right(ast)])), maybeExport(name)),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (head.type === \"let\") {\n\t\t\tconst foo = letdec(head, ctx);\n\t\t\tconst [name, result] = foo;\n\t\t\treturn F.pipe(\n\t\t\t\tresult,\n\t\t\t\tE.match(\n\t\t\t\t\te => update(next(tail, ctx), \"letdecs\", A.prepend<Pair>([name, E.left(e)])),\n\t\t\t\t\t([ast, ctx]) => F.pipe(next(tail, ctx), update(\"letdecs\", A.prepend<Pair>([name, E.right(ast)])), maybeExport(name)),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tconsole.warn(\"Unrecognized statement\", head);\n\t\treturn next(tail, ctx);\n\t};\n\n\tconst result = next(mod.content.script, ctx);\n\tconsole.log(\"\\n================ Module Elaboration ================\\n\");\n\tconsole.log(\"Exports:\");\n\tconsole.log(result.exports);\n\tconsole.log(\"Foreigns:\");\n\tconsole.log(result.foreign);\n\tconsole.log(\"Let Declarations:\");\n\tconsole.log(result.letdecs);\n\tconsole.log(\"Errors:\");\n\tconsole.log(result.errors);\n\tconsole.log(\"\\n===================================================\\n\");\n\treturn result;\n};\n\nexport const foreign = (stmt: Extract<Src.Statement, { type: \"foreign\" }>, ctx: EB.Context): [string, Either<V2.Err, [EB.AST, EB.Context]>] => {\n\tconst check = EB.check(stmt.annotation, NF.Type);\n\tconst { result } = check(ctx);\n\tconst e = E.Functor.map(result, ([tm, us]): [EB.AST, EB.Context] => {\n\t\tconst nf = NF.evaluate(ctx, tm);\n\t\tconst v = EB.Constructors.Var({ type: \"Foreign\", name: stmt.variable });\n\t\treturn [[v, nf, us], set(ctx, [\"imports\", stmt.variable] as const, [v, nf, us])];\n\t});\n\n\treturn [stmt.variable, e];\n};\n\nexport const using = (stmt: Extract<Src.Statement, { type: \"using\" }>, ctx: EB.Context): Either<V2.Err, EB.Context> => {\n\tconst infer = EB.Stmt.infer(stmt);\n\tconst { result } = infer(ctx);\n\ttype Implicit = EB.Context[\"implicits\"][0];\n\treturn E.Functor.map(result, ([t, ty]) => update(ctx, \"implicits\", A.append<Implicit>([t.value, ty])));\n};\n\nexport const letdec = (stmt: Extract<Src.Statement, { type: \"let\" }>, ctx: EB.Context): [string, Either<V2.Err, [EB.AST, EB.Context]>] => {\n\tconst inference = V2.Do(function* () {\n\t\tconst [elaborated, ty, us] = yield* EB.Stmt.infer.gen(stmt);\n\t\tconst { constraints, metas } = yield* V2.listen();\n\t\tconst subst = yield* V2.local(\n\t\t\tupdate(\"metas\", ms => ({ ...ms, ...metas })),\n\t\t\tsolve(constraints),\n\t\t);\n\t\t//const tyZonked = yield* EB.zonk.gen(\"nf\", ty, subst);\n\t\tconst zonked = F.pipe(\n\t\t\tctx,\n\t\t\tupdate(\"metas\", prev => ({ ...prev, ...metas })),\n\t\t\tset(\"zonker\", Sub.compose(subst, ctx.zonker)),\n\t\t);\n\t\tconst [generalized, next] = NF.generalize(ty, zonked);\n\t\tconst instantiated = NF.instantiate(generalized, next);\n\n\t\tconst xtended = EB.bind(next, { type: \"Let\", variable: stmt.variable }, instantiated);\n\t\tconst wrapped = F.pipe(\n\t\t\tEB.Icit.instantiate(elaborated.value, xtended),\n\t\t\tinst => EB.Icit.generalize(inst, xtended),\n\t\t\ttm => EB.Icit.wrapLambda(tm, ty, xtended),\n\t\t);\n\n\t\tconsole.log(\"\\n------------------ LETDEC --------------------------------\");\n\t\tconsole.log(\"Elaborated:\\n\", EB.Display.Statement(elaborated, xtended));\n\t\tconsole.log(\"Wrapped:\\n\", EB.Display.Term(wrapped, xtended));\n\t\tconsole.log(\"Instantiated:\\n\", NF.display(instantiated, xtended));\n\n\t\t// init().then(z3 => {\n\t\t// \tconst zCtx = z3.Context(\"main\");\n\t\t// \tz3.enableTrace(\"main\");\n\n\t\t// \tconst Verification = VerificationService(zCtx);\n\n\t\t// \tconst { result: res } = V2.Do(() => V2.local(_ => next, Verification.check(wrapped, instantiated)))(next);\n\t\t// \tif (res._tag === \"Left\") {\n\t\t// \t\tconsole.log(\"Verification failure\");\n\t\t// \t\tconsole.log(res.left);\n\t\t// \t\treturn;\n\t\t// \t}\n\t\t// \tconst result = res.right;\n\t\t// \tconst artefacts = result;\n\n\t\t// \tconst solver = new zCtx.Solver();\n\n\t\t// \tsolver.add(artefacts.vc.eq(true));\n\t\t// \tsolver.check().then(res => {\n\t\t// \t\tconsole.log(\"\\n------------------ LETDEC --------------------------------\");\n\t\t// \t\tconsole.log(\"Elaborated:\\n\", EB.Display.Statement(elaborated, xtended));\n\t\t// \t\tconsole.log(\"Wrapped:\\n\", EB.Display.Term(wrapped, xtended));\n\t\t// \t\tconsole.log(\"Instantiated:\\n\", NF.display(instantiated, xtended));\n\n\t\t// \t\tconsole.log(\"\\n\\n--------------------DEBUG VERIFICATION--------------------\");\n\t\t// \t\t// console.log(\"RESULT:\");\n\t\t// \t\t// console.log(result);\n\n\t\t// \t\t//console.log(\"\\nSynthed:\\n\", NF.display(synthed, next));\n\t\t// \t\tconsole.log(\"\\nArtefacts:\");\n\t\t// \t\tconsole.log(\"Usages:\\n\", artefacts.usages);\n\n\t\t// \t\tconsole.log(\"\\n--------------------FORMULA----------------------\");\n\t\t// \t\tconsole.log(\"Z3 Sat:\", res);\n\t\t// \t\tconsole.log(\"VC (Z3):\\n\", artefacts.vc.sexpr());\n\n\t\t// \t\tconsole.log(\"------------------- END LETDEC --------------------------------\\n\");\n\t\t// \t});\n\t\t// });\n\t\tconst ast: EB.AST = [wrapped, instantiated, us];\n\t\treturn [ast, set(next, [\"imports\", stmt.variable] as const, ast)] satisfies [EB.AST, EB.Context];\n\t});\n\n\tconst { result } = inference(ctx);\n\treturn [stmt.variable, result];\n};\n\nexport const expression = (stmt: Extract<Src.Statement, { type: \"expression\" }>, ctx: EB.Context) => {\n\tconst inference = V2.Do(function* () {\n\t\tconst [elaborated, ty, us] = yield* EB.infer.gen(stmt.value);\n\t\tconst { constraints, metas } = yield* V2.listen();\n\t\tconst subst = yield* V2.local(\n\t\t\tupdate(\"metas\", ms => ({ ...ms, ...metas })),\n\t\t\tsolve(constraints),\n\t\t);\n\n\t\tconsole.log(\"Substitution:\\n\", Sub.display(subst, metas));\n\t\tconst zonked = F.pipe(\n\t\t\tctx,\n\t\t\tupdate(\"metas\", prev => ({ ...prev, ...metas })),\n\t\t\tset(\"zonker\", Sub.compose(subst, ctx.zonker)),\n\t\t);\n\t\tconst [generalized, next] = NF.generalize(ty, zonked);\n\t\tconst instantiated = NF.instantiate(generalized, next);\n\n\t\tconst wrapped = F.pipe(\n\t\t\tEB.Icit.instantiate(elaborated, next),\n\t\t\tinst => EB.Icit.generalize(inst, next),\n\t\t\ttm => EB.Icit.wrapLambda(tm, ty, next),\n\t\t);\n\n\t\t// init().then(z3 => {\n\t\t// \tconst zCtx = z3.Context(\"main\");\n\t\t// \tz3.enableTrace(\"main\");\n\n\t\t// \tconst Verification = VerificationService(zCtx);\n\t\t// \tconst { result: res } = V2.Do(() => V2.local(_ => next, Verification.synth(wrapped)))(next);\n\t\t// \tif (res._tag === \"Left\") {\n\t\t// \t\tconsole.log(\"Verification failure\");\n\t\t// \t\tconsole.log(res.left);\n\t\t// \t\treturn;\n\t\t// \t}\n\t\t// \tconst result = res.right;\n\t\t// \tconsole.log(\"\\n\\n--------------------------DEBUG---------------------------------\");\n\t\t// \tconsole.log(\"RESULT:\");\n\t\t// \tconsole.log(result);\n\t\t// \tconst [synthed, artefacts] = result;\n\t\t// \tconsole.log(\"\\nSynthed:\\n\", NF.display(synthed, next));\n\t\t// \tconsole.log(\"\\nArtefacts:\");\n\t\t// \tconsole.log(\"Usages:\\n\", artefacts.usages);\n\n\t\t// \t// console.log(\"VC:\\n\", NF.display(artefacts.vc., next));\n\t\t// \t//console.log(\"Simplified:\\n\", NF.display(tmp_simplify(artefacts.vc), next));\n\t\t// \tconsole.log(\"VC (Z3):\\n\", artefacts.vc);\n\t\t// \tconst solver = new zCtx.Solver();\n\t\t// \tsolver.add(artefacts.vc as Bool);\n\t\t// \tconst check = solver.check();\n\t\t// \tconsole.log(\"Z3 Sat:\", check);\n\n\t\t// \tconsole.log(\"\\n-----------------------END DEBUG------------------------------------\\n\");\n\t\t// });\n\t\treturn [wrapped, instantiated, us, subst] as const;\n\t});\n\n\tconst { result } = inference(ctx);\n\treturn result;\n};\n\n// const tmp_simplify = (vc: NF.Value): NF.Value =>\n// \tmatch(vc)\n// \t\t.with({ type: \"App\" }, ({ func, arg }) => {\n// \t\t\treturn NF.reduce(func, arg, \"Explicit\");\n// \t\t})\n// \t\t.with({ type: \"External\" }, ({ args, arity, compute }) => (args.length === arity && compute !== undefined ? compute(...args) : vc))\n// \t\t.otherwise(() => vc);\n"],"mappings":"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","names":["result","ctx"]}