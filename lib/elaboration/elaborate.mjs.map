{"version":3,"sources":["../../src/elaboration/elaborate.ts"],"sourcesContent":["import { match } from \"ts-pattern\";\n\nimport * as EB from \".\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as V2 from \"./shared/monad.v2\";\n\nimport * as NF from \"./normalization\";\nimport * as Modal from \"@yap/verification/modalities/shared\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nexport type AST = [EB.Term, NF.Value, Q.Usages];\nexport const infer = V2.regen((ast: Src.Term): V2.Elaboration<AST> => {\n\tconst result = V2.track<AST>(\n\t\t{ tag: \"src\", type: \"term\", term: ast, metadata: { action: \"infer\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst elaboration = match(ast)\n\t\t\t\t.with({ type: \"var\" }, ({ variable }) => EB.lookup(variable, ctx))\n\n\t\t\t\t.with({ type: \"lit\" }, EB.Lit.infer)\n\t\t\t\t.with({ type: \"hole\" }, EB.Hole.infer)\n\n\t\t\t\t.with({ type: \"row\" }, EB.Rows.infer)\n\t\t\t\t.with({ type: \"projection\" }, EB.Proj.infer)\n\t\t\t\t.with({ type: \"injection\" }, EB.Inj.infer)\n\n\t\t\t\t.with({ type: \"struct\" }, EB.Struct.infer)\n\t\t\t\t.with({ type: \"tuple\" }, EB.Tuples.infer)\n\t\t\t\t.with({ type: \"list\" }, EB.List.infer)\n\t\t\t\t.with({ type: \"dict\" }, EB.Dict.infer)\n\t\t\t\t.with({ type: \"variant\" }, EB.Variant.infer)\n\t\t\t\t.with({ type: \"tagged\" }, EB.Tagged.infer)\n\n\t\t\t\t.with({ type: \"pi\" }, { type: \"arrow\" }, EB.Pi.infer)\n\t\t\t\t.with({ type: \"lambda\" }, EB.Lambda.infer)\n\t\t\t\t.with({ type: \"application\" }, EB.Application.infer)\n\n\t\t\t\t.with({ type: \"match\" }, EB.Match.infer)\n\n\t\t\t\t.with({ type: \"block\" }, EB.Block.infer)\n\t\t\t\t.with({ type: \"modal\" }, EB.Modal.infer)\n\t\t\t\t.with({ type: \"annotation\" }, EB.Annotation.infer)\n\t\t\t\t.otherwise(v => {\n\t\t\t\t\tthrow new Error(\"Not implemented yet: \" + JSON.stringify(v));\n\t\t\t\t});\n\n\t\t\tconst [tm, ty, us] = yield* V2.pure(elaboration);\n\t\t\tyield* V2.tell(\"type\", { term: tm, nf: ty, modalities: {} as any });\n\n\t\t\treturn [tm, ty, us] as AST;\n\t\t}),\n\t);\n\treturn result;\n});\n// infer.gen = F.flow(infer, V2.pure)\n"],"mappings":";AAAA,SAAS,aAAa;AAEtB,YAAY,QAAQ;AAGpB,YAAY,QAAQ;AAOb,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAuC;AACrE,QAAM,SAAS,GAAG;AAAA,IACjB,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,KAAK,UAAU,EAAE,QAAQ,QAAQ,EAAE;AAAA,IACrE,GAAG,GAAG,aAAa;AAClB,YAAM,MAAM,OAAO,GAAG,IAAI;AAC1B,YAAM,cAAc,MAAM,GAAG,EAC3B,KAAK,EAAE,MAAM,MAAM,GAAG,CAAC,EAAE,SAAS,MAAM,GAAG,OAAO,UAAU,GAAG,CAAC,EAEhE,KAAK,EAAE,MAAM,MAAM,GAAG,GAAG,IAAI,KAAK,EAClC,KAAK,EAAE,MAAM,OAAO,GAAG,GAAG,KAAK,KAAK,EAEpC,KAAK,EAAE,MAAM,MAAM,GAAG,GAAG,KAAK,KAAK,EACnC,KAAK,EAAE,MAAM,aAAa,GAAG,GAAG,KAAK,KAAK,EAC1C,KAAK,EAAE,MAAM,YAAY,GAAG,GAAG,IAAI,KAAK,EAExC,KAAK,EAAE,MAAM,SAAS,GAAG,GAAG,OAAO,KAAK,EACxC,KAAK,EAAE,MAAM,QAAQ,GAAG,GAAG,OAAO,KAAK,EACvC,KAAK,EAAE,MAAM,OAAO,GAAG,GAAG,KAAK,KAAK,EACpC,KAAK,EAAE,MAAM,OAAO,GAAG,GAAG,KAAK,KAAK,EACpC,KAAK,EAAE,MAAM,UAAU,GAAG,GAAG,QAAQ,KAAK,EAC1C,KAAK,EAAE,MAAM,SAAS,GAAG,GAAG,OAAO,KAAK,EAExC,KAAK,EAAE,MAAM,KAAK,GAAG,EAAE,MAAM,QAAQ,GAAG,GAAG,GAAG,KAAK,EACnD,KAAK,EAAE,MAAM,SAAS,GAAG,GAAG,OAAO,KAAK,EACxC,KAAK,EAAE,MAAM,cAAc,GAAG,GAAG,YAAY,KAAK,EAElD,KAAK,EAAE,MAAM,QAAQ,GAAG,GAAG,MAAM,KAAK,EAEtC,KAAK,EAAE,MAAM,QAAQ,GAAG,GAAG,MAAM,KAAK,EACtC,KAAK,EAAE,MAAM,QAAQ,GAAG,GAAG,MAAM,KAAK,EACtC,KAAK,EAAE,MAAM,aAAa,GAAG,GAAG,WAAW,KAAK,EAChD,UAAU,OAAK;AACf,cAAM,IAAI,MAAM,0BAA0B,KAAK,UAAU,CAAC,CAAC;AAAA,MAC5D,CAAC;AAEF,YAAM,CAAC,IAAI,IAAI,EAAE,IAAI,OAAO,GAAG,KAAK,WAAW;AAC/C,aAAO,GAAG,KAAK,QAAQ,EAAE,MAAM,IAAI,IAAI,IAAI,YAAY,CAAC,EAAS,CAAC;AAElE,aAAO,CAAC,IAAI,IAAI,EAAE;AAAA,IACnB,CAAC;AAAA,EACF;AACA,SAAO;AACR,CAAC;","names":[]}