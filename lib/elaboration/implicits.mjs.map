{"version":3,"sources":["../../src/elaboration/implicits.ts"],"sourcesContent":["import * as F from \"fp-ts/lib/function\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as NF from \"@yap/elaboration/normalization\";\n\nimport { match, P } from \"ts-pattern\";\n\nimport _ from \"lodash\";\nimport { Subst } from \"./unification/substitution\";\n\nimport * as Metas from \"@yap/elaboration/shared/metas\";\nimport * as R from \"@yap/shared/rows\";\n\nexport function insert(node: EB.AST): V2.Elaboration<EB.AST> {\n\tconst [term, ty, us] = node;\n\treturn V2.Do(function* () {\n\t\tconst ctx = yield* V2.ask();\n\t\tconst r = match(node)\n\t\t\t.with([{ type: \"Abs\", binding: { type: \"Lambda\", icit: \"Implicit\" } }, P._, P._], () => V2.of<EB.AST>(node))\n\t\t\t.with([P._, { type: \"Abs\", binder: { type: \"Pi\", icit: \"Implicit\" } }, P._], ([, pi]) =>\n\t\t\t\tV2.Do(function* () {\n\t\t\t\t\tconst found = yield* V2.pure(EB.resolveImplicit(pi.binder.annotation));\n\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tif (!_.isEmpty(found[1])) {\n\t\t\t\t\t\t\tthrow new Error(\"insert: Found implicit with constraints; What to do here?\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst bodyNF = NF.apply(pi.binder, pi.closure, pi.binder.annotation);\n\t\t\t\t\t\tconst tm = EB.Constructors.App(\"Implicit\", term, found[0]);\n\t\t\t\t\t\treturn [tm, bodyNF, us] satisfies EB.AST;\n\t\t\t\t\t}\n\t\t\t\t\tconst meta = yield* EB.freshMeta(ctx.env.length, pi.binder.annotation);\n\t\t\t\t\tconst mvar = EB.Constructors.Var(meta);\n\t\t\t\t\tconst vNF = NF.evaluate(ctx, mvar);\n\n\t\t\t\t\tconst tm = EB.Constructors.App(\"Implicit\", term, mvar);\n\t\t\t\t\tconst bodyNF = NF.apply(pi.binder, pi.closure, vNF);\n\t\t\t\t\tconst r = yield* insert.gen([tm, bodyNF, us]);\n\t\t\t\t\treturn r;\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.otherwise(() => V2.of<EB.AST>(node));\n\t\treturn yield* V2.pure(r);\n\t});\n}\n\ninsert.gen = F.flow(insert, V2.pure);\n\nexport const wrapLambda = (term: EB.Term, ty: NF.Value, ctx: EB.Context): EB.Term => {\n\treturn match(ty)\n\t\t.with(\n\t\t\t{ type: \"Abs\", binder: { type: \"Pi\", icit: \"Implicit\" } },\n\t\t\t_ => term.type === \"Abs\" && (term.binding.type === \"Lambda\" || term.binding.type === \"Pi\") && term.binding.icit === \"Implicit\",\n\t\t\t_ => term,\n\t\t)\n\t\t.with({ type: \"Abs\", binder: { type: \"Pi\", icit: \"Implicit\" } }, pi => {\n\t\t\tconst ann = NF.quote(ctx, ctx.env.length, pi.binder.annotation);\n\t\t\tconst binding: EB.Binding = { type: \"Lambda\", variable: pi.binder.variable, icit: pi.binder.icit, annotation: ann };\n\t\t\treturn EB.Constructors.Abs(binding, wrapLambda(term, NF.apply(pi.binder, pi.closure, NF.Constructors.Rigid(0)), ctx));\n\t\t})\n\t\t.otherwise(() => term);\n};\n\nexport const generalize = (tm: EB.Term, ctx: EB.Context): EB.Term => {\n\tconst ms = Metas.collect.eb(tm, ctx.zonker);\n\tconst charCode = 97; // 'a'\n\treturn ms.reduce(\n\t\t(tm, m, i) => {\n\t\t\treturn EB.Constructors.Abs(\n\t\t\t\t{\n\t\t\t\t\ttype: \"Lambda\",\n\t\t\t\t\ticit: \"Implicit\",\n\t\t\t\t\tvariable: `${String.fromCharCode(charCode + i)}`,\n\t\t\t\t\tannotation: NF.quote(ctx, ctx.env.length, ctx.metas[m.val].ann),\n\t\t\t\t},\n\t\t\t\ttm,\n\t\t\t);\n\t\t},\n\t\ttm, //replaceMeta(tm, ms, 0, ctx),\n\t);\n};\n\n// type Meta = Extract<EB.Variable, { type: \"Meta\" }>;\n// export const replaceMeta = (tm: EB.Term, ms: Meta[], lvl: number, ctx: EB.Context): EB.Term => {\n// \tconst sub = (tm: EB.Term, lvl: number): EB.Term => {\n// \t\tconst t = match(tm)\n// \t\t\t.with({ type: \"Var\", variable: { type: \"Meta\" } }, ({ variable }) => {\n// \t\t\t\tif (!ctx.zonker[variable.val]) {\n// \t\t\t\t\treturn EB.Constructors.Var(bindMeta(variable, ms, lvl));\n// \t\t\t\t}\n\n// \t\t\t\treturn NF.quote(ctx, lvl, ctx.zonker[variable.val]);\n// \t\t\t\t// console.warn(\"Generalize: Found meta variable\", { variable });\n// \t\t\t\t// console.warn(\"Term generalization yet to be fully implemented\");\n// \t\t\t\t// return EB.Constructors.Var(bindMeta(variable, ms, lvl));\n// \t\t\t})\n\n// \t\t\t.with({ type: \"Var\" }, () => tm)\n// \t\t\t.with({ type: \"Lit\" }, () => tm)\n// \t\t\t.with({ type: \"Abs\", binding: { type: \"Lambda\" } }, ({ binding, body }) => EB.Constructors.Abs(binding, sub(body, lvl + 1)))\n// \t\t\t.with({ type: \"Abs\", binding: { type: \"Pi\" } }, ({ binding, body }) =>\n// \t\t\t\tEB.Constructors.Abs({ ...binding, annotation: sub(binding.annotation, lvl) }, sub(body, lvl + 1)),\n// \t\t\t)\n// \t\t\t.with({ type: \"Abs\", binding: { type: \"Mu\" } }, ({ binding, body }) =>\n// \t\t\t\tEB.Constructors.Abs({ ...binding, annotation: sub(binding.annotation, lvl) }, sub(body, lvl + 1)),\n// \t\t\t)\n// \t\t\t// .with({ type: \"App\", icit: \"Implicit\", arg: { type: \"Var\", variable: { type: \"Meta\" } } }, ({ icit, func, arg }) => {\n// \t\t\t// \treturn EB.Constructors.App(icit, sub(func, lvl), sub(arg, lvl));\n// \t\t\t// })\n// \t\t\t.with({ type: \"App\" }, ({ icit, func, arg }) => EB.Constructors.App(icit, sub(func, lvl), sub(arg, lvl)))\n// \t\t\t.with({ type: \"Row\" }, ({ row }) => {\n// \t\t\t\tconst r = R.traverse(\n// \t\t\t\t\trow,\n// \t\t\t\t\tval => sub(val, lvl),\n// \t\t\t\t\tv => ({ type: \"variable\", variable: bindMeta(v, ms, lvl) }),\n// \t\t\t\t);\n// \t\t\t\treturn EB.Constructors.Row(r);\n// \t\t\t})\n// \t\t\t.with({ type: \"Proj\" }, ({ label, term }) => EB.Constructors.Proj(label, sub(term, lvl)))\n// \t\t\t.with({ type: \"Inj\" }, ({ label, value, term }) => EB.Constructors.Inj(label, sub(value, lvl), sub(term, lvl)))\n// \t\t\t//.with({ type: \"Annotation\" }, ({ term, ann }) => EB.Constructors.Annotation(sub(term, lvl), sub(ann, lvl)))\n// \t\t\t.with({ type: \"Match\" }, ({ scrutinee, alternatives }) =>\n// \t\t\t\tEB.Constructors.Match(\n// \t\t\t\t\tsub(scrutinee, lvl),\n// \t\t\t\t\talternatives.map(alt => ({ pattern: alt.pattern, term: sub(alt.term, lvl) })),\n// \t\t\t\t),\n// \t\t\t)\n// \t\t\t.with({ type: \"Block\" }, ({ return: ret, statements }) => {\n// \t\t\t\tconst stmts = statements.map(s => {\n// \t\t\t\t\tif (s.type === \"Let\") {\n// \t\t\t\t\t\treturn { ...s, value: sub(s.value, lvl), annotation: sub(s.annotation, lvl) };\n// \t\t\t\t\t}\n// \t\t\t\t\treturn { ...s, value: sub(s.value, lvl) };\n// \t\t\t\t});\n// \t\t\t\treturn EB.Constructors.Block(stmts, sub(ret, lvl));\n// \t\t\t})\n\n// \t\t\t.otherwise(() => {\n// \t\t\t\tthrow new Error(\"Generalize: Not implemented yet\");\n// \t\t\t});\n\n// \t\treturn t;\n// \t};\n\n// \treturn sub(tm, lvl);\n// };\n\n// const bindMeta = (v: EB.Variable, ms: Meta[], lvl: number): EB.Variable => {\n// \tif (v.type !== \"Meta\") {\n// \t\treturn v;\n// \t}\n\n// \tconst i = ms.findIndex(m => m.val === v.val);\n// \tif (i === -1) {\n// \t\t// Not a meta that we are generalizing. If it doesn't show up in the meta list, then it must be in the zonker (solved)\n// \t\treturn v;\n// \t}\n\n// \treturn EB.Bound(lvl - i - 1);\n// };\n\n// TODO: We might want to remove this pass altogether in the future. Perhaps merge it with a lowering pass.\n/**\n * Instantiates unconstrained meta variables in a Term to default values based on their annotations.\n * Constrained metas (those that have been unified to some value) are quoted from the zonker.\n * NOTE: this is more zonking than instantiation, but the name is kept for legacy reasons.\n */\nexport const instantiate = (term: EB.Term, ctx: EB.Context): EB.Term => {\n\treturn (\n\t\tmatch(term)\n\t\t\t.with({ type: \"Var\", variable: { type: \"Meta\" } }, v => {\n\t\t\t\tif (!!ctx.zonker[v.variable.val]) {\n\t\t\t\t\t// Solved meta means it's in the zonker = not unconstrained, so no need to instantiate it\n\t\t\t\t\treturn NF.quote(ctx, ctx.env.length, ctx.zonker[v.variable.val]);\n\t\t\t\t}\n\n\t\t\t\tconst { ann } = ctx.metas[v.variable.val];\n\n\t\t\t\treturn match(ann)\n\t\t\t\t\t.with({ type: \"Lit\", value: { type: \"Atom\", value: \"Row\" } }, () => EB.Constructors.Row({ type: \"empty\" }))\n\t\t\t\t\t.with({ type: \"Lit\", value: { type: \"Atom\", value: \"Type\" } }, () => EB.Constructors.Lit({ type: \"Atom\", value: \"Any\" }))\n\t\t\t\t\t.with({ type: \"Lit\", value: { type: \"Atom\", value: \"Any\" } }, () => EB.Constructors.Lit({ type: \"Atom\", value: \"Void\" }))\n\t\t\t\t\t.otherwise(() => EB.Constructors.Var(v.variable));\n\t\t\t})\n\t\t\t.with({ type: \"Abs\" }, abs => {\n\t\t\t\tconst annotation = instantiate(abs.binding.annotation, ctx);\n\t\t\t\tconst extended = EB.bind(ctx, abs.binding, NF.evaluate(ctx, annotation));\n\t\t\t\treturn EB.Constructors.Abs({ ...abs.binding, annotation }, instantiate(abs.body, extended));\n\t\t\t})\n\t\t\t.with({ type: \"App\" }, app => EB.Constructors.App(app.icit, instantiate(app.func, ctx), instantiate(app.arg, ctx)))\n\t\t\t.with({ type: \"Row\" }, ({ row }) => {\n\t\t\t\tconst r = R.traverse(\n\t\t\t\t\trow,\n\t\t\t\t\tval => instantiate(val, ctx),\n\t\t\t\t\tv => R.Constructors.Variable(v),\n\t\t\t\t);\n\t\t\t\treturn EB.Constructors.Row(r);\n\t\t\t})\n\t\t\t.with({ type: \"Proj\" }, ({ label, term }) => EB.Constructors.Proj(label, instantiate(term, ctx)))\n\t\t\t.with({ type: \"Inj\" }, ({ label, value, term }) => EB.Constructors.Inj(label, instantiate(value, ctx), instantiate(term, ctx)))\n\t\t\t//.with({ type: \"Annotation\" }, ({ term, ann }) => EB.Constructors.Annotation(instantiate(term, ctx), instantiate(ann, ctx)))\n\t\t\t.with({ type: \"Match\" }, ({ scrutinee, alternatives }) =>\n\t\t\t\tEB.Constructors.Match(\n\t\t\t\t\tinstantiate(scrutinee, ctx),\n\t\t\t\t\talternatives.map(alt => {\n\t\t\t\t\t\tconst xtended = alt.binders.reduce((acc, [bv, bty]) => EB.bind(acc, { type: \"Let\", variable: bv }, bty), ctx);\n\t\t\t\t\t\treturn { pattern: alt.pattern, term: instantiate(alt.term, xtended), binders: alt.binders };\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.with({ type: \"Block\" }, ({ return: ret, statements }) => {\n\t\t\t\tconst { stmts, ctx: xtended } = statements.reduce(\n\t\t\t\t\t(acc, s) => {\n\t\t\t\t\t\tconst { stmts, ctx } = acc;\n\t\t\t\t\t\tconst instantiated = { ...s, value: instantiate(s.value, ctx) };\n\t\t\t\t\t\tif (s.type === \"Let\") {\n\t\t\t\t\t\t\tconst extended = EB.bind(ctx, { type: \"Let\", variable: s.variable }, s.annotation);\n\t\t\t\t\t\t\treturn { stmts: [...stmts, instantiated], ctx: extended };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { stmts: [...stmts, instantiated], ctx };\n\t\t\t\t\t},\n\t\t\t\t\t{ stmts: [] as EB.Statement[], ctx },\n\t\t\t\t);\n\n\t\t\t\treturn EB.Constructors.Block(stmts, instantiate(ret, xtended));\n\t\t\t})\n\t\t\t.with({ type: \"Modal\" }, ({ term, modalities }) => EB.Constructors.Modal(instantiate(term, ctx), modalities))\n\t\t\t.otherwise(t => t)\n\t);\n\n\t// return EB.traverse(term, v => {\n\t// \tif (v.variable.type !== \"Meta\") {\n\t// \t\treturn v;\n\t// \t}\n\n\t// \tif (!!ctx.zonker[v.variable.val]) {\n\t// \t\t// Solved meta means it's in the zonker = not unconstrained, so no need to instantiate it\n\t// \t\treturn NF.quote(ctx, ctx.env.length, ctx.zonker[v.variable.val]);\n\t// \t}\n\n\t// \tconst { ann } = ctx.metas[v.variable.val];\n\n\t// \treturn match(ann)\n\t// \t\t.with({ type: \"Lit\", value: { type: \"Atom\", value: \"Row\" } }, () => EB.Constructors.Row({ type: \"empty\" }))\n\t// \t\t.with({ type: \"Lit\", value: { type: \"Atom\", value: \"Type\" } }, () => EB.Constructors.Lit({ type: \"Atom\", value: \"Any\" }))\n\t// \t\t.with({ type: \"Lit\", value: { type: \"Atom\", value: \"Any\" } }, () => EB.Constructors.Lit({ type: \"Atom\", value: \"Void\" }))\n\t// \t\t.otherwise(() => EB.Constructors.Var(v.variable));\n\t// });\n};\n"],"mappings":"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","names":["bodyNF","tm","r","_","term","stmts","ctx"]}