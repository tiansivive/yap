{"version":3,"sources":["../../../src/elaboration/inference/applications.ts"],"sourcesContent":["import * as F from \"fp-ts/lib/function\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\nimport { match } from \"ts-pattern\";\nimport { Implicitness } from \"@yap/shared/implicitness\";\nimport * as Modal from \"@yap/verification/modalities\";\nimport { Liquid } from \"@yap/verification/modalities\";\n\ntype Application = Extract<Src.Term, { type: \"application\" }>;\n\nexport const infer = (node: Application) =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: node, metadata: { action: \"infer\", description: \"Application node\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\tconst [ft, fty, fus] = yield* V2.pure(inferFn(node));\n\t\t\tconst pi = yield* mkPi(NF.force(ctx, fty), node.icit);\n\t\t\tconst [at, aus] = yield* V2.pure(checkArg(node, pi[0]));\n\n\t\t\tconst [nf, cls, x] = pi;\n\n\t\t\t// TODO: Move this to the verification step\n\t\t\t//const rus = Q.add(fus, Q.multiply(quantity, aus));\n\n\t\t\tconst val = NF.apply({ type: \"Pi\", variable: x }, cls, NF.evaluate(ctx, at));\n\t\t\treturn [EB.Constructors.App(node.icit, ft, at), val, fus] satisfies EB.AST;\n\t\t}),\n\t);\ninfer.gen = F.flow(infer, V2.pure);\n\nconst inferFn = (node: Application) =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: node.fn, metadata: { action: \"infer\", description: \"inferring function type\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst inferred = yield* EB.infer.gen(node.fn);\n\n\t\t\tif (node.icit !== \"Explicit\") {\n\t\t\t\treturn inferred;\n\t\t\t}\n\n\t\t\tconst ast = yield* EB.Icit.insert.gen(inferred);\n\t\t\treturn ast;\n\t\t}),\n\t);\n\nconst checkArg = ({ arg }: Application, ann: NF.Value) =>\n\tV2.track({ tag: \"src\", type: \"term\", term: arg, metadata: { action: \"checking\", against: ann, description: \"checking argument type\" } }, EB.check(arg, ann));\n\ntype Pi = [NF.Value, NF.Closure, string];\nconst mkPi = (fnType: NF.Value, icit: Implicitness): Generator<V2.Elaboration<any>, Pi, any> =>\n\tmatch(fnType)\n\t\t.with({ type: \"Modal\" }, ({ value }) => {\n\t\t\tconsole.warn(\"Inferred fn as a modal type. Still unsure what to do here. Simply unwrapping the modality for now\");\n\t\t\treturn mkPi(value, icit);\n\t\t})\n\t\t.with({ type: \"Abs\", binder: { type: \"Pi\" } }, pi => {\n\t\t\tif (pi.binder.icit !== icit) {\n\t\t\t\tthrow new Error(\"Implicitness mismatch\");\n\t\t\t}\n\n\t\t\treturn V2.lift<Pi>([pi.binder.annotation, pi.closure, pi.binder.variable]);\n\t\t})\n\t\t.otherwise(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\tconst meta = EB.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\tconst nf = NF.evaluate(ctx, meta);\n\n\t\t\tconst kind = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\tconst closure = NF.Constructors.Closure(ctx, EB.Constructors.Var(yield* EB.freshMeta(ctx.env.length + 1, kind)));\n\n\t\t\tconst pi = NF.Constructors.Pi(\"x\", icit, nf, closure);\n\n\t\t\tyield* V2.tell(\"constraint\", { type: \"assign\", left: fnType, right: pi, lvl: ctx.env.length });\n\t\t\treturn [nf, closure, pi.binder.variable] satisfies Pi;\n\t\t});\n"],"mappings":"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","names":[]}