{"version":3,"sources":["../../../src/elaboration/inference/lists.ts"],"sourcesContent":["import * as F from \"fp-ts/lib/function\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\nimport * as Lit from \"@yap/shared/literals\";\n\ntype List = Extract<Src.Term, { type: \"list\" }>;\n\nexport const infer = (list: List): V2.Elaboration<EB.AST> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: list, metadata: { action: \"infer\", description: \"List\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst kind = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\tconst mvar = EB.Constructors.Var(yield* EB.freshMeta(ctx.env.length, kind));\n\t\t\tconst v = NF.evaluate(ctx, mvar);\n\n\t\t\tconst validate = (tm: Src.Term) =>\n\t\t\t\tV2.Do(function* () {\n\t\t\t\t\tconst inferred = yield* EB.infer.gen(tm);\n\t\t\t\t\tyield* V2.tell(\"constraint\", { type: \"assign\", left: inferred[1], right: v, lvl: ctx.env.length });\n\t\t\t\t\treturn inferred;\n\t\t\t\t});\n\n\t\t\tconst es = yield* V2.pure(V2.traverse(list.elements, validate));\n\t\t\tconst usages = es.reduce((acc, [, , us]) => Q.add(acc, us), Q.noUsage(ctx.env.length));\n\n\t\t\tconst indexing = NF.Constructors.App(NF.Indexed, NF.Constructors.Lit(Lit.Atom(\"Num\")), \"Explicit\");\n\t\t\tconst values = NF.Constructors.App(indexing, v, \"Explicit\");\n\n\t\t\tconst ty = NF.Constructors.App(values, NF.Constructors.Var({ type: \"Foreign\", name: \"defaultArray\" }), \"Implicit\");\n\n\t\t\tconst row = es.reduceRight(\n\t\t\t\t(r: EB.Row, [tm], i) => {\n\t\t\t\t\tconst label = i.toString();\n\t\t\t\t\treturn { type: \"extension\", label, value: tm, row: r } satisfies EB.Row;\n\t\t\t\t},\n\t\t\t\t{ type: \"empty\" },\n\t\t\t);\n\t\t\treturn [EB.Constructors.Row(row), NF.Constructors.Neutral(ty), usages] satisfies EB.AST;\n\t\t}),\n\t);\ninfer.gen = F.flow(infer, V2.pure);\n"],"mappings":";AAAA,YAAY,OAAO;AAEnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AAEpB,YAAY,QAAQ;AAGpB,YAAY,OAAO;AACnB,YAAY,SAAS;AAId,MAAM,QAAQ,CAAC,SACrB,GAAG;AAAA,EACF,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,MAAM,UAAU,EAAE,QAAQ,SAAS,aAAa,OAAO,EAAE;AAAA,EAC3F,GAAG,GAAG,aAAa;AAClB,UAAM,MAAM,OAAO,GAAG,IAAI;AAC1B,UAAM,OAAO,GAAG,aAAa,IAAI,OAAO,GAAG,UAAU,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC;AAC7E,UAAM,OAAO,GAAG,aAAa,IAAI,OAAO,GAAG,UAAU,IAAI,IAAI,QAAQ,IAAI,CAAC;AAC1E,UAAM,IAAI,GAAG,SAAS,KAAK,IAAI;AAE/B,UAAM,WAAW,CAAC,OACjB,GAAG,GAAG,aAAa;AAClB,YAAM,WAAW,OAAO,GAAG,MAAM,IAAI,EAAE;AACvC,aAAO,GAAG,KAAK,cAAc,EAAE,MAAM,UAAU,MAAM,SAAS,CAAC,GAAG,OAAO,GAAG,KAAK,IAAI,IAAI,OAAO,CAAC;AACjG,aAAO;AAAA,IACR,CAAC;AAEF,UAAM,KAAK,OAAO,GAAG,KAAK,GAAG,SAAS,KAAK,UAAU,QAAQ,CAAC;AAC9D,UAAM,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,KAAK,EAAE,GAAG,EAAE,QAAQ,IAAI,IAAI,MAAM,CAAC;AAErF,UAAM,WAAW,GAAG,aAAa,IAAI,GAAG,SAAS,GAAG,aAAa,IAAI,IAAI,KAAK,KAAK,CAAC,GAAG,UAAU;AACjG,UAAM,SAAS,GAAG,aAAa,IAAI,UAAU,GAAG,UAAU;AAE1D,UAAM,KAAK,GAAG,aAAa,IAAI,QAAQ,GAAG,aAAa,IAAI,EAAE,MAAM,WAAW,MAAM,eAAe,CAAC,GAAG,UAAU;AAEjH,UAAM,MAAM,GAAG;AAAA,MACd,CAAC,GAAW,CAAC,EAAE,GAAG,MAAM;AACvB,cAAM,QAAQ,EAAE,SAAS;AACzB,eAAO,EAAE,MAAM,aAAa,OAAO,OAAO,IAAI,KAAK,EAAE;AAAA,MACtD;AAAA,MACA,EAAE,MAAM,QAAQ;AAAA,IACjB;AACA,WAAO,CAAC,GAAG,aAAa,IAAI,GAAG,GAAG,GAAG,aAAa,QAAQ,EAAE,GAAG,MAAM;AAAA,EACtE,CAAC;AACF;AACD,MAAM,MAAM,EAAE,KAAK,OAAO,GAAG,IAAI;","names":[]}