{"version":3,"sources":["../../../src/elaboration/inference/annotations.ts"],"sourcesContent":["import * as F from \"fp-ts/lib/function\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\nimport { Usages } from \"@yap/shared/modalities/multiplicity\";\nimport { Unwrap } from \"../shared/monad.v2\";\nimport { isEqual } from \"lodash\";\n\ntype Annotation = Extract<Src.Term, { type: \"annotation\" }>;\n\ntype Checked = Unwrap<ReturnType<typeof EB.check>>;\n\nexport const infer = (node: Annotation): V2.Elaboration<EB.AST> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: node, metadata: { action: \"infer\", description: \"Annotation node\" } },\n\t\tV2.Do<EB.AST, Checked>(function* () {\n\t\t\tconst { term, ann } = node;\n\n\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\t// FIXME:TODO: This was a fix for allowing singleton numbers as annotations. The correct was is to pattern match on check(Lit.Num, Type), and allow that check to succeed\n\t\t\tconst ast = yield* EB.check.gen(ann, NF.Type);\n\t\t\t//const [_ann, kind]: EB.AST = yield* EB.Icit.insert.gen(ast[0]);\n\t\t\tconst nf = NF.evaluate(ctx, ast[0]);\n\n\t\t\t//const [_ann, us] = yield* EB.check.gen(ann, nf);\n\t\t\t//const _ty = NF.evaluate(ctx, _ann);\n\t\t\tconst [_term, us] = yield* EB.check.gen(term, nf);\n\n\t\t\treturn [_term, nf, us] satisfies EB.AST;\n\t\t}),\n\t);\n"],"mappings":";AAEA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AAEpB,YAAY,QAAQ;AAUb,MAAM,QAAQ,CAAC,SACrB,GAAG;AAAA,EACF,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,MAAM,UAAU,EAAE,QAAQ,SAAS,aAAa,kBAAkB,EAAE;AAAA,EACtG,GAAG,GAAoB,aAAa;AACnC,UAAM,EAAE,MAAM,IAAI,IAAI;AAEtB,UAAM,MAAM,OAAO,GAAG,IAAI;AAG1B,UAAM,MAAM,OAAO,GAAG,MAAM,IAAI,KAAK,GAAG,IAAI;AAE5C,UAAM,KAAK,GAAG,SAAS,KAAK,IAAI,CAAC,CAAC;AAIlC,UAAM,CAAC,OAAO,EAAE,IAAI,OAAO,GAAG,MAAM,IAAI,MAAM,EAAE;AAEhD,WAAO,CAAC,OAAO,IAAI,EAAE;AAAA,EACtB,CAAC;AACF;","names":[]}