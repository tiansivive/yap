{"version":3,"sources":["../../../src/elaboration/inference/patterns.ts"],"sourcesContent":["import { match } from \"ts-pattern\";\n\nimport * as F from \"fp-ts/lib/function\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as Log from \"@yap/shared/logging\";\n\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as Src from \"@yap/src/index\";\nimport * as Lit from \"@yap/shared/literals\";\n\nimport * as Modal from \"@yap/verification/modalities/shared\";\n\nimport * as R from \"@yap/shared/rows\";\nimport { capitalize } from \"lodash\";\n\ntype Tags<T, K> = K extends string ? (T extends { [k in K]: infer U } ? U : never) : never;\nexport type Inference<T, Key> = Key extends string\n\t? Tags<T, Key> extends string\n\t\t? {\n\t\t\t\t[k in Tags<T, Key> as Capitalize<k>]: {\n\t\t\t\t\t(pattern: Extract<Src.Pattern, { [t in Key]: k }>): V2.Elaboration<Result>;\n\t\t\t\t\tgen: (pattern: Extract<Src.Pattern, { [t in Key]: k }>) => ReturnType<typeof V2.pure<Result>>;\n\t\t\t\t};\n\t\t\t}\n\t\t: never\n\t: never;\n\nexport type Result = [EB.Pattern, NF.Value, Q.Usages, Binder[]];\nexport type Binder = [string, NF.Value];\n\nexport const infer: Inference<Src.Pattern, \"type\"> = {\n\tLit: V2.regen(pat => {\n\t\tconst atom: Lit.Literal = match(pat.value)\n\t\t\t.with({ type: \"String\" }, _ => Lit.Atom(\"String\"))\n\t\t\t.with({ type: \"Num\" }, _ => Lit.Atom(\"Num\"))\n\t\t\t.with({ type: \"Bool\" }, _ => Lit.Atom(\"Bool\"))\n\t\t\t.with({ type: \"Atom\" }, _ => Lit.Atom(\"Type\"))\n\t\t\t.with({ type: \"unit\" }, _ => Lit.Atom(\"Unit\"))\n\n\t\t\t.exhaustive();\n\n\t\treturn V2.Do<Result, EB.Context>(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\treturn [EB.Constructors.Patterns.Lit(pat.value), NF.Constructors.Lit(atom), Q.noUsage(ctx.env.length), []] satisfies Result;\n\t\t});\n\t}),\n\n\tVar: V2.regen(pat =>\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\tconst free = ctx.imports[pat.value.value];\n\t\t\t// TODO:FIXME: Remove this check for now. Let's ignore matching on defined variables for now, until we answer how to match on lambdas and others\n\t\t\tif (free) {\n\t\t\t\tconst [tm, ty, us] = free;\n\t\t\t\treturn [EB.Constructors.Patterns.Var(pat.value.value, tm), ty, us, []];\n\t\t\t}\n\t\t\tconst kind = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\tconst meta = EB.Constructors.Var(yield* EB.freshMeta(ctx.env.length, kind));\n\t\t\tconst va = NF.evaluate(ctx, meta);\n\t\t\tconst zero = Q.noUsage(ctx.env.length);\n\t\t\tconst binder: Binder = [pat.value.value, va];\n\t\t\treturn [{ type: \"Binder\", value: pat.value.value }, va, zero, [binder]];\n\t\t}),\n\t),\n\tRow: V2.regen(pat =>\n\t\tV2.Do(function* () {\n\t\t\tconst [r, rowty, rus, binders] = yield* elaborate.gen(pat.row);\n\t\t\treturn [EB.Constructors.Patterns.Row(r), NF.Constructors.Row(rowty), rus, binders] satisfies Result;\n\t\t}),\n\t),\n\tStruct: V2.regen(pat =>\n\t\tV2.Do(function* () {\n\t\t\tconst [tm, ty, qs, binders] = yield* elaborate.gen(pat.row);\n\t\t\treturn [EB.Constructors.Patterns.Struct(tm), NF.Constructors.Schema(ty), qs, binders] satisfies Result;\n\t\t}),\n\t),\n\n\tVariant: V2.regen(pat =>\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst [r, rowty, rus, binders] = yield* elaborate.gen(pat.row);\n\t\t\tconst addVar = function* (nfr: NF.Row): Generator<V2.Elaboration<any>, NF.Row, any> {\n\t\t\t\tif (nfr.type === \"empty\") {\n\t\t\t\t\treturn R.Constructors.Variable(yield* EB.freshMeta(ctx.env.length, NF.Row));\n\t\t\t\t}\n\n\t\t\t\tif (nfr.type === \"variable\") {\n\t\t\t\t\treturn nfr;\n\t\t\t\t}\n\t\t\t\tconst tail = yield* addVar(nfr.row);\n\t\t\t\treturn R.Constructors.Extension(nfr.label, nfr.value, tail);\n\t\t\t};\n\n\t\t\tconst tail = yield* addVar(rowty);\n\t\t\treturn [EB.Constructors.Patterns.Variant(r), NF.Constructors.Variant(tail), rus, binders] satisfies Result;\n\t\t}),\n\t),\n\n\tWildcard: V2.regen(_ =>\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst kind = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\tconst meta = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, kind));\n\t\t\treturn [EB.Constructors.Patterns.Wildcard(), meta, Q.noUsage(ctx.env.length), []];\n\t\t}),\n\t),\n\n\tTuple: V2.regen(pat =>\n\t\tV2.Do(function* () {\n\t\t\tconst [r, rowty, qs, binders] = yield* elaborate.gen(pat.row);\n\t\t\treturn [EB.Constructors.Patterns.Struct(r), NF.Constructors.Schema(rowty), qs, binders] satisfies Result;\n\t\t}),\n\t),\n\tList: V2.regen(pat =>\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst kind = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\tconst mvar = EB.Constructors.Var(yield* EB.freshMeta(ctx.env.length, kind));\n\n\t\t\tconst v = NF.evaluate(ctx, mvar);\n\n\t\t\tconst validate = (val: Src.Pattern) =>\n\t\t\t\tV2.Do(function* () {\n\t\t\t\t\tconst key = capitalize(val.type) as keyof typeof infer;\n\n\t\t\t\t\tconst result = yield* infer[key].gen(val as Extract<Src.Pattern, { type: typeof key }>);\n\t\t\t\t\tyield* V2.tell(\"constraint\", { type: \"assign\", left: result[1], right: v });\n\t\t\t\t\treturn result;\n\t\t\t\t});\n\n\t\t\tconst es = yield* V2.pure(V2.traverse(pat.elements, validate));\n\n\t\t\tconst [pats, binders] = es.reduce(([pats, binders], [pat, , , b]) => [pats.concat(pat), binders.concat(b)], [[], []] as [EB.Pattern[], Binder[]]);\n\n\t\t\tconst indexing = NF.Constructors.App(NF.Indexed, NF.Constructors.Lit(Lit.Atom(\"Num\")), \"Explicit\");\n\t\t\tconst values = NF.Constructors.App(indexing, v, \"Explicit\");\n\n\t\t\tconst ty = NF.Constructors.App(values, NF.Constructors.Var({ type: \"Foreign\", name: \"defaultArray\" }), \"Implicit\");\n\n\t\t\treturn [\n\t\t\t\tEB.Constructors.Patterns.List(pats, pat.rest?.value),\n\t\t\t\tNF.Constructors.Neutral(ty),\n\t\t\t\tQ.noUsage(ctx.env.length),\n\t\t\t\tpat.rest ? binders.concat([[pat.rest.value, ty /*, Q.noUsage(ctx.env.length)*/]]) : binders,\n\t\t\t];\n\t\t}),\n\t),\n};\n\ntype Row = R.Row<EB.Pattern, string>;\ntype RowResult = [Row, NF.Row, Q.Usages, Binder[]];\n\nconst elaborate = V2.regen(\n\t(r: R.Row<Src.Pattern, Src.Variable>): V2.Elaboration<RowResult> =>\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\tconst rr: RowResult = yield match(r)\n\t\t\t\t.with({ type: \"empty\" }, r => V2.of([r, R.Constructors.Empty(), Q.noUsage(ctx.env.length), []] satisfies RowResult))\n\t\t\t\t.with({ type: \"variable\" }, ({ variable }) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst meta = yield* EB.freshMeta(ctx.env.length, NF.Row);\n\t\t\t\t\t\tconst zero = Q.noUsage(ctx.env.length);\n\t\t\t\t\t\tconst binder: Binder = [variable.value, NF.Constructors.Var(meta) /*zero*/];\n\t\t\t\t\t\treturn [R.Constructors.Variable(variable.value), R.Constructors.Variable(meta), zero, [binder]] satisfies RowResult;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with({ type: \"extension\" }, ({ label, value, row }) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst key = capitalize(value.type) as Capitalize<typeof value.type>;\n\t\t\t\t\t\tconst val = yield* infer[key].gen(value as any);\n\t\t\t\t\t\tconst r = yield* elaborate.gen(row);\n\t\t\t\t\t\tconst q = Q.add(val[2], r[2]);\n\t\t\t\t\t\tconst ty = NF.Constructors.Extension(label, val[1], r[1]);\n\t\t\t\t\t\tconst tm = EB.Constructors.Patterns.Extension(label, val[0], r[0]);\n\t\t\t\t\t\tconst binders = [val[3], r[3]].flat();\n\t\t\t\t\t\treturn [tm, ty, q, binders] satisfies RowResult;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.otherwise(_ => {\n\t\t\t\t\tthrow new Error(\"Expected Row Type\");\n\t\t\t\t});\n\n\t\t\treturn rr;\n\t\t}),\n);\n"],"mappings":"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","names":["tail","pats","binders","pat","r"]}