{"version":3,"sources":["../../../src/elaboration/inference/structs.ts"],"sourcesContent":["import * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as F from \"fp-ts/lib/function\";\n\nimport * as R from \"@yap/shared/rows\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\nimport { match } from \"ts-pattern\";\n\ntype Struct = Extract<Src.Term, { type: \"struct\" }>;\n\nexport const infer = (struct: Struct): V2.Elaboration<EB.AST> =>\n\tV2.track({ tag: \"src\", type: \"term\", term: struct, metadata: { action: \"infer\", description: \"Struct\" } }, commonStructInference(struct.row));\ninfer.gen = F.flow(infer, V2.pure);\n\nexport const commonStructInference = (row: Src.Row): V2.Elaboration<EB.AST> =>\n\tV2.Do(function* () {\n\t\tconst ctx = yield* V2.ask();\n\t\t// const [row, ty, qs] = yield* EB.Rows.inSigmaContext.gen(struct.row, collect(struct.row));\n\t\tconst { fields, tail } = yield* EB.Rows.inSigmaContext.gen(row, EB.Rows.collect(row));\n\n\t\tconst mkRows = (start: [EB.Row, NF.Row]) =>\n\t\t\tfields.reduceRight<[EB.Row, NF.Row]>(\n\t\t\t\t([rtm, rty], { label, term, value }) => [R.Constructors.Extension(label, term, rtm), R.Constructors.Extension(label, value, rty)],\n\t\t\t\tstart,\n\t\t\t);\n\n\t\tif (!tail) {\n\t\t\tconst [rtm, rty] = mkRows([R.Constructors.Empty(), R.Constructors.Empty()]);\n\t\t\t// No tail, simple struct and respective schema type\n\t\t\treturn [EB.Constructors.Struct(rtm), NF.Constructors.Schema(rty), Q.noUsage(ctx.env.length)] satisfies EB.AST;\n\t\t}\n\n\t\tconst [tm, ty] = yield* match(tail.ty)\n\t\t\t.with({ type: \"Lit\", value: { type: \"Atom\", value: \"Row\" } }, function* () {\n\t\t\t\t// If tail is a var of type Row, then our term is a schema, which is of type Type. We can safely ignore the per-label inferred values (types)\n\t\t\t\tconst rtm = fields.reduceRight<EB.Row>((r, { label, term }) => R.Constructors.Extension(label, term, r), R.Constructors.Variable(tail.variable));\n\t\t\t\treturn [EB.Constructors.Schema(rtm), NF.Type] as const;\n\t\t\t})\n\t\t\t.with(NF.Patterns.Schema, function* (s) {\n\t\t\t\t// If tail is a schema itself, then our term is a \"struct merger\", meaning the type is a Schema composed of the fields + the tail schema's fields\n\t\t\t\tconst [rtm, rty] = mkRows([R.Constructors.Variable(tail.variable), s.arg.row]);\n\t\t\t\treturn [EB.Constructors.Struct(rtm), NF.Constructors.Schema(rty)] as const;\n\t\t\t})\n\t\t\t.with(NF.Patterns.Flex, function* (meta) {\n\t\t\t\t// If tail is a meta variable, we cannot be sure if it's a struct or a schema.\n\t\t\t\t// We default to struct, and emit a constraint equating the meta to a schema over a fresh meta of type Row.\n\t\t\t\t// This fresh meta will end up generalized, therefore quantifying this term over some polymorphic row type.\n\t\t\t\t// Therefore the type is the inferred row + the fresh meta of type Row\n\t\t\t\tconst freshRowMeta = yield* EB.freshMeta(ctx.env.length, NF.Row);\n\t\t\t\tconst schemaTy = NF.Constructors.Schema(R.Constructors.Variable(freshRowMeta));\n\t\t\t\tyield* V2.tell(\"constraint\", { type: \"assign\", left: meta, right: schemaTy });\n\n\t\t\t\tconst [rtm, rty] = mkRows([R.Constructors.Variable(tail.variable), R.Constructors.Variable(freshRowMeta)]);\n\t\t\t\treturn [EB.Constructors.Struct(rtm), NF.Constructors.Schema(rty)] as const;\n\t\t\t})\n\t\t\t.otherwise(() => {\n\t\t\t\tthrow new Error(\"Elaborating Struct: Tail type is neither Schema, Row nor Flex\");\n\t\t\t});\n\n\t\treturn [tm, ty, Q.noUsage(ctx.env.length)] satisfies EB.AST;\n\t});\n"],"mappings":";AAAA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AAEpB,YAAY,QAAQ;AAGpB,YAAY,OAAO;AAEnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,SAAS,aAAa;AAIf,MAAM,QAAQ,CAAC,WACrB,GAAG,MAAM,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,QAAQ,UAAU,EAAE,QAAQ,SAAS,aAAa,SAAS,EAAE,GAAG,sBAAsB,OAAO,GAAG,CAAC;AAC7I,MAAM,MAAM,EAAE,KAAK,OAAO,GAAG,IAAI;AAE1B,MAAM,wBAAwB,CAAC,QACrC,GAAG,GAAG,aAAa;AAClB,QAAM,MAAM,OAAO,GAAG,IAAI;AAE1B,QAAM,EAAE,QAAQ,KAAK,IAAI,OAAO,GAAG,KAAK,eAAe,IAAI,KAAK,GAAG,KAAK,QAAQ,GAAG,CAAC;AAEpF,QAAM,SAAS,CAAC,UACf,OAAO;AAAA,IACN,CAAC,CAAC,KAAK,GAAG,GAAG,EAAE,OAAO,MAAM,MAAM,MAAM,CAAC,EAAE,aAAa,UAAU,OAAO,MAAM,GAAG,GAAG,EAAE,aAAa,UAAU,OAAO,OAAO,GAAG,CAAC;AAAA,IAChI;AAAA,EACD;AAED,MAAI,CAAC,MAAM;AACV,UAAM,CAAC,KAAK,GAAG,IAAI,OAAO,CAAC,EAAE,aAAa,MAAM,GAAG,EAAE,aAAa,MAAM,CAAC,CAAC;AAE1E,WAAO,CAAC,GAAG,aAAa,OAAO,GAAG,GAAG,GAAG,aAAa,OAAO,GAAG,GAAG,EAAE,QAAQ,IAAI,IAAI,MAAM,CAAC;AAAA,EAC5F;AAEA,QAAM,CAAC,IAAI,EAAE,IAAI,OAAO,MAAM,KAAK,EAAE,EACnC,KAAK,EAAE,MAAM,OAAO,OAAO,EAAE,MAAM,QAAQ,OAAO,MAAM,EAAE,GAAG,aAAa;AAE1E,UAAM,MAAM,OAAO,YAAoB,CAAC,GAAG,EAAE,OAAO,KAAK,MAAM,EAAE,aAAa,UAAU,OAAO,MAAM,CAAC,GAAG,EAAE,aAAa,SAAS,KAAK,QAAQ,CAAC;AAC/I,WAAO,CAAC,GAAG,aAAa,OAAO,GAAG,GAAG,GAAG,IAAI;AAAA,EAC7C,CAAC,EACA,KAAK,GAAG,SAAS,QAAQ,WAAW,GAAG;AAEvC,UAAM,CAAC,KAAK,GAAG,IAAI,OAAO,CAAC,EAAE,aAAa,SAAS,KAAK,QAAQ,GAAG,EAAE,IAAI,GAAG,CAAC;AAC7E,WAAO,CAAC,GAAG,aAAa,OAAO,GAAG,GAAG,GAAG,aAAa,OAAO,GAAG,CAAC;AAAA,EACjE,CAAC,EACA,KAAK,GAAG,SAAS,MAAM,WAAW,MAAM;AAKxC,UAAM,eAAe,OAAO,GAAG,UAAU,IAAI,IAAI,QAAQ,GAAG,GAAG;AAC/D,UAAM,WAAW,GAAG,aAAa,OAAO,EAAE,aAAa,SAAS,YAAY,CAAC;AAC7E,WAAO,GAAG,KAAK,cAAc,EAAE,MAAM,UAAU,MAAM,MAAM,OAAO,SAAS,CAAC;AAE5E,UAAM,CAAC,KAAK,GAAG,IAAI,OAAO,CAAC,EAAE,aAAa,SAAS,KAAK,QAAQ,GAAG,EAAE,aAAa,SAAS,YAAY,CAAC,CAAC;AACzG,WAAO,CAAC,GAAG,aAAa,OAAO,GAAG,GAAG,GAAG,aAAa,OAAO,GAAG,CAAC;AAAA,EACjE,CAAC,EACA,UAAU,MAAM;AAChB,UAAM,IAAI,MAAM,+DAA+D;AAAA,EAChF,CAAC;AAEF,SAAO,CAAC,IAAI,IAAI,EAAE,QAAQ,IAAI,IAAI,MAAM,CAAC;AAC1C,CAAC;","names":[]}