{"version":3,"sources":["../../../src/elaboration/inference/pi.ts"],"sourcesContent":["import * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\ntype Pi = Extract<Src.Term, { type: \"pi\" } | { type: \"arrow\" }>;\n\nexport const infer = (pi: Pi): V2.Elaboration<EB.AST> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: pi, metadata: { action: \"infer\", description: \"Pi\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst v = pi.type === \"pi\" ? pi.variable : `t${EB.nextCount()}`;\n\t\t\tconst body = pi.type === \"pi\" ? pi.body : pi.rhs;\n\n\t\t\tconst ann = pi.type === \"pi\" ? pi.annotation : pi.lhs;\n\t\t\tconst [ty, us] = yield* EB.check.gen(ann, NF.Type);\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst va = NF.evaluate(ctx, ty);\n\n\t\t\tconst [bodyTm, [, ...bus]] = yield* V2.local(_ctx => EB.bind(_ctx, { type: \"Pi\", variable: v }, va), EB.check(body, NF.Type));\n\n\t\t\treturn [EB.Constructors.Pi(v, pi.icit, ty, bodyTm), NF.Type, Q.add(us, bus)] satisfies EB.AST;\n\t\t}),\n\t);\n"],"mappings":";AAAA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AAEnB,YAAY,QAAQ;AAKb,MAAM,QAAQ,CAAC,OACrB,GAAG;AAAA,EACF,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,IAAI,UAAU,EAAE,QAAQ,SAAS,aAAa,KAAK,EAAE;AAAA,EACvF,GAAG,GAAG,aAAa;AAClB,UAAM,IAAI,GAAG,SAAS,OAAO,GAAG,WAAW,IAAI,GAAG,UAAU,CAAC;AAC7D,UAAM,OAAO,GAAG,SAAS,OAAO,GAAG,OAAO,GAAG;AAE7C,UAAM,MAAM,GAAG,SAAS,OAAO,GAAG,aAAa,GAAG;AAClD,UAAM,CAAC,IAAI,EAAE,IAAI,OAAO,GAAG,MAAM,IAAI,KAAK,GAAG,IAAI;AACjD,UAAM,MAAM,OAAO,GAAG,IAAI;AAC1B,UAAM,KAAK,GAAG,SAAS,KAAK,EAAE;AAE9B,UAAM,CAAC,QAAQ,CAAC,EAAE,GAAG,GAAG,CAAC,IAAI,OAAO,GAAG,MAAM,UAAQ,GAAG,KAAK,MAAM,EAAE,MAAM,MAAM,UAAU,EAAE,GAAG,EAAE,GAAG,GAAG,MAAM,MAAM,GAAG,IAAI,CAAC;AAE5H,WAAO,CAAC,GAAG,aAAa,GAAG,GAAG,GAAG,MAAM,IAAI,MAAM,GAAG,GAAG,MAAM,EAAE,IAAI,IAAI,GAAG,CAAC;AAAA,EAC5E,CAAC;AACF;","names":[]}