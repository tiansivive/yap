{"version":3,"sources":["../../../../src/elaboration/inference/__tests__/util.ts"],"sourcesContent":["import Nearley from \"nearley\";\nimport Grammar from \"@yap/src/grammar\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Lib from \"@yap/shared/lib/primitives\";\nimport { omit } from \"lodash/fp\";\n\n// Create a fresh parser for expressions (Ann grammar start)\nexport const mkParser = () => {\n\tconst g = { ...Grammar, ParserStart: \"Ann\" } as typeof Grammar;\n\treturn new Nearley.Parser(Nearley.Grammar.fromCompiled(g), { keepHistory: true });\n};\n\nexport const parseExpr = (src: string) => {\n\tconst parser = mkParser();\n\tconst data = parser.feed(src);\n\tif (data.results.length !== 1) {\n\t\tthrow new Error(`Ambiguous or failed parse: expected 1 result, got ${data.results.length}`);\n\t}\n\treturn data.results[0];\n};\n\nexport const mkCtx = () => Lib.defaultContext();\n\n// Run elaboration/inference for a source string; returns elaborated term, type, usages, constraints and displays.\nexport const elaborateFrom = (src: string) => {\n\tEB.resetSupply(\"meta\");\n\tEB.resetSupply(\"var\");\n\n\tconst term = parseExpr(src);\n\tconst ctx = mkCtx();\n\n\tconst result = EB.V2.Do(function* () {\n\t\tconst [tm, ty] = yield* EB.infer.gen(term);\n\t\tconst { constraints: csts, metas, types } = yield* EB.V2.listen();\n\t\tconst constraints = csts.map(c => (c.type === \"assign\" ? omit(\"trace\", c) : c));\n\t\treturn { tm, ty, constraints, metas, types } as const;\n\t});\n\n\tconst out = result(ctx);\n\tif (out.result._tag === \"Left\") {\n\t\tthrow new Error(EB.V2.display(out.result.left));\n\t}\n\tconst { tm, ty, constraints, metas, types } = out.result.right;\n\n\tconst pretty = {\n\t\tterm: EB.Display.Term(tm, { env: ctx.env, zonker: ctx.zonker, metas: { ...ctx.metas, ...metas } }),\n\t\ttype: NF.display(ty, { env: ctx.env, zonker: ctx.zonker, metas: { ...ctx.metas, ...metas } }),\n\t\tconstraints: constraints.map((c: any) => EB.Display.Constraint(c, { env: ctx.env, zonker: ctx.zonker, metas: { ...ctx.metas, ...metas } })),\n\t};\n\n\t// Build a snapshot-friendly object\n\treturn {\n\t\tsrc,\n\t\tdisplays: pretty,\n\t\tstructure: {\n\t\t\tterm: tm,\n\t\t\ttype: ty,\n\t\t\tconstraints,\n\t\t\tmetas,\n\t\t\ttypedTerms: types,\n\t\t},\n\t};\n};\n"],"mappings":";AAAA,OAAO,aAAa;AACpB,OAAO,aAAa;AAEpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,SAAS,YAAY;AAGd,MAAM,WAAW,MAAM;AAC7B,QAAM,IAAI,EAAE,GAAG,SAAS,aAAa,MAAM;AAC3C,SAAO,IAAI,QAAQ,OAAO,QAAQ,QAAQ,aAAa,CAAC,GAAG,EAAE,aAAa,KAAK,CAAC;AACjF;AAEO,MAAM,YAAY,CAAC,QAAgB;AACzC,QAAM,SAAS,SAAS;AACxB,QAAM,OAAO,OAAO,KAAK,GAAG;AAC5B,MAAI,KAAK,QAAQ,WAAW,GAAG;AAC9B,UAAM,IAAI,MAAM,qDAAqD,KAAK,QAAQ,MAAM,EAAE;AAAA,EAC3F;AACA,SAAO,KAAK,QAAQ,CAAC;AACtB;AAEO,MAAM,QAAQ,MAAM,IAAI,eAAe;AAGvC,MAAM,gBAAgB,CAAC,QAAgB;AAC7C,KAAG,YAAY,MAAM;AACrB,KAAG,YAAY,KAAK;AAEpB,QAAM,OAAO,UAAU,GAAG;AAC1B,QAAM,MAAM,MAAM;AAElB,QAAM,SAAS,GAAG,GAAG,GAAG,aAAa;AACpC,UAAM,CAACA,KAAIC,GAAE,IAAI,OAAO,GAAG,MAAM,IAAI,IAAI;AACzC,UAAM,EAAE,aAAa,MAAM,OAAAC,QAAO,OAAAC,OAAM,IAAI,OAAO,GAAG,GAAG,OAAO;AAChE,UAAMC,eAAc,KAAK,IAAI,OAAM,EAAE,SAAS,WAAW,KAAK,SAAS,CAAC,IAAI,CAAE;AAC9E,WAAO,EAAE,IAAAJ,KAAI,IAAAC,KAAI,aAAAG,cAAa,OAAAF,QAAO,OAAAC,OAAM;AAAA,EAC5C,CAAC;AAED,QAAM,MAAM,OAAO,GAAG;AACtB,MAAI,IAAI,OAAO,SAAS,QAAQ;AAC/B,UAAM,IAAI,MAAM,GAAG,GAAG,QAAQ,IAAI,OAAO,IAAI,CAAC;AAAA,EAC/C;AACA,QAAM,EAAE,IAAI,IAAI,aAAa,OAAO,MAAM,IAAI,IAAI,OAAO;AAEzD,QAAM,SAAS;AAAA,IACd,MAAM,GAAG,QAAQ,KAAK,IAAI,EAAE,KAAK,IAAI,KAAK,QAAQ,IAAI,QAAQ,OAAO,EAAE,GAAG,IAAI,OAAO,GAAG,MAAM,EAAE,CAAC;AAAA,IACjG,MAAM,GAAG,QAAQ,IAAI,EAAE,KAAK,IAAI,KAAK,QAAQ,IAAI,QAAQ,OAAO,EAAE,GAAG,IAAI,OAAO,GAAG,MAAM,EAAE,CAAC;AAAA,IAC5F,aAAa,YAAY,IAAI,CAAC,MAAW,GAAG,QAAQ,WAAW,GAAG,EAAE,KAAK,IAAI,KAAK,QAAQ,IAAI,QAAQ,OAAO,EAAE,GAAG,IAAI,OAAO,GAAG,MAAM,EAAE,CAAC,CAAC;AAAA,EAC3I;AAGA,SAAO;AAAA,IACN;AAAA,IACA,UAAU;AAAA,IACV,WAAW;AAAA,MACV,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,YAAY;AAAA,IACb;AAAA,EACD;AACD;","names":["tm","ty","metas","types","constraints"]}