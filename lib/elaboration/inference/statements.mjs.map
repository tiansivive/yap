{"version":3,"sources":["../../../src/elaboration/inference/statements.ts"],"sourcesContent":["import * as Src from \"@yap/src/index\";\nimport * as EB from \"@yap/elaboration\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as M from \"@yap/elaboration/shared/monad\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\nimport * as F from \"fp-ts/lib/function\";\n\nimport { match } from \"ts-pattern\";\nimport { freshMeta } from \"@yap/elaboration/shared/supply\";\nimport { Liquid } from \"@yap/verification/modalities\";\nimport * as Modal from \"@yap/verification/modalities\";\n\nexport type ElaboratedStmt = [EB.Statement, NF.Value, Q.Usages];\nexport const infer = (stmt: Src.Statement): V2.Elaboration<ElaboratedStmt> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"stmt\", stmt, metadata: { action: \"infer\", description: \"Statement\" } },\n\t\t(() =>\n\t\t\tmatch(stmt)\n\t\t\t\t.with({ type: \"let\" }, letdec =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\t\t\t\tconst ann = letdec.annotation\n\t\t\t\t\t\t\t? yield* EB.check.gen(letdec.annotation, NF.Type)\n\t\t\t\t\t\t\t: ([EB.Constructors.Var(yield* freshMeta(ctx.env.length, NF.Type)), Q.noUsage(ctx.env.length)] as const);\n\t\t\t\t\t\tconst va = NF.evaluate(ctx, ann[0]);\n\n\t\t\t\t\t\tconst inferred = yield* V2.local(\n\t\t\t\t\t\t\t_ctx => EB.bind(_ctx, { type: \"Let\", variable: letdec.variable }, va),\n\t\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\t\tconst inferred = yield* EB.check.gen(letdec.value, va);\n\t\t\t\t\t\t\t\tconst [bTerm, [vu, ...bus]] = inferred;\n\t\t\t\t\t\t\t\t//yield* V2.tell(\"constraint\", { type: \"usage\", expected: q, computed: vu });\n\n\t\t\t\t\t\t\t\treturn [bTerm, va, bus] satisfies EB.AST; // remove the usage of the bound variable (same as the lambda rule)\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst { binders } = yield* V2.listen();\n\n\t\t\t\t\t\t// TODO: This binders array is not overly useful for now\n\t\t\t\t\t\t// // In theory, all we need is to emit a flag signalling the letdec var has been used\n\t\t\t\t\t\t// FIXME: We should really leverage the `check` function to understand when to wrap in a mu\n\t\t\t\t\t\tconst tm = binders.find(b => b.type === \"Mu\" && b.variable === letdec.variable)\n\t\t\t\t\t\t\t? EB.Constructors.Mu(\"x\", letdec.variable, ann[0], inferred[0])\n\t\t\t\t\t\t\t: inferred[0];\n\t\t\t\t\t\tconst def = EB.Constructors.Stmt.Let(letdec.variable, tm, va);\n\t\t\t\t\t\treturn [def, inferred[1], inferred[2]] satisfies ElaboratedStmt;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with({ type: \"expression\" }, ({ value }) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [expr, ty, us] = yield* EB.infer.gen(value);\n\t\t\t\t\t\treturn [EB.Constructors.Stmt.Expr(expr), ty, us] satisfies ElaboratedStmt;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with({ type: \"using\" }, ({ value }) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [tm, ty, us] = yield* EB.infer.gen(value);\n\t\t\t\t\t\treturn [{ type: \"Using\", value: tm, annotation: ty }, ty, us] satisfies ElaboratedStmt;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.otherwise(() => {\n\t\t\t\t\tthrow new Error(\"Not implemented yet\");\n\t\t\t\t}))(),\n\t);\n\ninfer.gen = F.flow(infer, V2.pure);\n"],"mappings":";AACA,YAAY,QAAQ;AAEpB,YAAY,QAAQ;AAEpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AAEnB,SAAS,aAAa;AACtB,SAAS,iBAAiB;AAKnB,MAAM,QAAQ,CAAC,SACrB,GAAG;AAAA,EACF,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,UAAU,EAAE,QAAQ,SAAS,aAAa,YAAY,EAAE;AAAA,GACzF,MACA,MAAM,IAAI,EACR;AAAA,IAAK,EAAE,MAAM,MAAM;AAAA,IAAG,YACtB,GAAG,GAAG,aAAa;AAClB,YAAM,MAAM,OAAO,GAAG,IAAI;AAE1B,YAAM,MAAM,OAAO,aAChB,OAAO,GAAG,MAAM,IAAI,OAAO,YAAY,GAAG,IAAI,IAC7C,CAAC,GAAG,aAAa,IAAI,OAAO,UAAU,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,QAAQ,IAAI,IAAI,MAAM,CAAC;AAC9F,YAAM,KAAK,GAAG,SAAS,KAAK,IAAI,CAAC,CAAC;AAElC,YAAM,WAAW,OAAO,GAAG;AAAA,QAC1B,UAAQ,GAAG,KAAK,MAAM,EAAE,MAAM,OAAO,UAAU,OAAO,SAAS,GAAG,EAAE;AAAA,QACpE,GAAG,GAAG,aAAa;AAClB,gBAAMA,YAAW,OAAO,GAAG,MAAM,IAAI,OAAO,OAAO,EAAE;AACrD,gBAAM,CAAC,OAAO,CAAC,IAAI,GAAG,GAAG,CAAC,IAAIA;AAG9B,iBAAO,CAAC,OAAO,IAAI,GAAG;AAAA,QACvB,CAAC;AAAA,MACF;AACA,YAAM,EAAE,QAAQ,IAAI,OAAO,GAAG,OAAO;AAKrC,YAAM,KAAK,QAAQ,KAAK,OAAK,EAAE,SAAS,QAAQ,EAAE,aAAa,OAAO,QAAQ,IAC3E,GAAG,aAAa,GAAG,KAAK,OAAO,UAAU,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,IAC5D,SAAS,CAAC;AACb,YAAM,MAAM,GAAG,aAAa,KAAK,IAAI,OAAO,UAAU,IAAI,EAAE;AAC5D,aAAO,CAAC,KAAK,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AAAA,IACtC,CAAC;AAAA,EACF,EACC;AAAA,IAAK,EAAE,MAAM,aAAa;AAAA,IAAG,CAAC,EAAE,MAAM,MACtC,GAAG,GAAG,aAAa;AAClB,YAAM,CAAC,MAAM,IAAI,EAAE,IAAI,OAAO,GAAG,MAAM,IAAI,KAAK;AAChD,aAAO,CAAC,GAAG,aAAa,KAAK,KAAK,IAAI,GAAG,IAAI,EAAE;AAAA,IAChD,CAAC;AAAA,EACF,EACC;AAAA,IAAK,EAAE,MAAM,QAAQ;AAAA,IAAG,CAAC,EAAE,MAAM,MACjC,GAAG,GAAG,aAAa;AAClB,YAAM,CAAC,IAAI,IAAI,EAAE,IAAI,OAAO,GAAG,MAAM,IAAI,KAAK;AAC9C,aAAO,CAAC,EAAE,MAAM,SAAS,OAAO,IAAI,YAAY,GAAG,GAAG,IAAI,EAAE;AAAA,IAC7D,CAAC;AAAA,EACF,EACC,UAAU,MAAM;AAChB,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACtC,CAAC,GAAG;AACP;AAED,MAAM,MAAM,EAAE,KAAK,OAAO,GAAG,IAAI;","names":["inferred"]}