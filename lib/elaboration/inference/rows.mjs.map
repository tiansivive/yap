{"version":3,"sources":["../../../src/elaboration/inference/rows.ts"],"sourcesContent":["import * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as F from \"fp-ts/function\";\nimport * as R from \"@yap/shared/rows\";\n\nimport { match } from \"ts-pattern\";\nimport { entries, setProp } from \"@yap/utils\";\n\ntype TRow = Extract<Src.Term, { type: \"row\" }>;\n\nexport const infer = (term: TRow): V2.Elaboration<EB.AST> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term, metadata: { action: \"infer\", description: \"Row\" } },\n\t\tV2.Do(() =>\n\t\t\tV2.local(\n\t\t\t\tEB.muContext,\n\t\t\t\tV2.Do(function* () {\n\t\t\t\t\tconst { fields, tail } = yield* inSigmaContext.gen(term.row, collect(term.row));\n\n\t\t\t\t\tif (tail) {\n\t\t\t\t\t\tthrow new Error(\"Row literals with tails are not supported\");\n\t\t\t\t\t}\n\n\t\t\t\t\tconst tm = fields.reduce<EB.Row>((r, { label, term }) => R.Constructors.Extension(label, term, r), R.Constructors.Empty());\n\t\t\t\t\treturn [EB.Constructors.Row(tm), NF.Row, Q.noUsage(0)] satisfies EB.AST;\n\t\t\t\t}),\n\t\t\t),\n\t\t),\n\t);\ninfer.gen = F.flow(infer, V2.pure);\n\n// TODO:FIXME update the sigma env to a stack of sigma records to properly handle nested row types\nexport const inSigmaContext = <A>(row: Src.Row, f: V2.Elaboration<A>): V2.Elaboration<A> =>\n\tV2.Do(function* () {\n\t\tconst ctx = yield* V2.ask();\n\t\tconst bindings = yield* extract(row, ctx.env.length);\n\t\treturn yield* V2.local(ctx_ => entries(bindings).reduce((ctx, [label, mv]) => EB.extendSigma(ctx, label, mv), ctx_), f);\n\t});\ninSigmaContext.gen = <A>(row: Src.Row, f: V2.Elaboration<A>) => V2.pure(inSigmaContext(row, f));\n\ntype Collected = { fields: { label: string; term: EB.Term; value: NF.Value }[]; tail?: { variable: EB.Variable; ty: NF.Value } };\nexport const collect = (row: Src.Row): V2.Elaboration<Collected> =>\n\tV2.Do(function* () {\n\t\tconst ctx = yield* V2.ask();\n\n\t\tconst initial: Collected = { fields: [] };\n\t\tconst collected: Collected = yield R.fold<Src.Term, Src.Variable, V2.Elaboration<Collected>>(\n\t\t\trow,\n\t\t\t(val, lbl, acc) =>\n\t\t\t\tV2.Do(function* () {\n\t\t\t\t\tconst [vtm, vty, qs] = yield* EB.infer.gen(val);\n\t\t\t\t\tconst sigma = ctx.sigma[lbl];\n\t\t\t\t\tif (!sigma) {\n\t\t\t\t\t\tthrow new Error(\"Elaborating Row Extension: Label not found\");\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nf = NF.evaluate(ctx, vtm);\n\t\t\t\t\tyield* V2.tell(\"constraint\", [\n\t\t\t\t\t\t{ type: \"assign\", left: nf, right: sigma.nf },\n\t\t\t\t\t\t{ type: \"assign\", left: vty, right: sigma.ann },\n\t\t\t\t\t]);\n\n\t\t\t\t\tconst accumulated: Collected = yield acc;\n\t\t\t\t\treturn { fields: [...accumulated.fields, { label: lbl, term: vtm, value: vty }], tail: accumulated.tail };\n\t\t\t\t}),\n\t\t\t(v, acc) =>\n\t\t\t\tV2.Do(function* () {\n\t\t\t\t\tconst [tm, ty, qs] = yield* EB.lookup.gen(v, ctx);\n\t\t\t\t\tif (tm.type !== \"Var\") {\n\t\t\t\t\t\tthrow new Error(\"Elaborating Row Var: Not a variable\");\n\t\t\t\t\t}\n\n\t\t\t\t\tconst _ty = NF.unwrapNeutral(ty);\n\n\t\t\t\t\tconst accumulated: Collected = yield acc;\n\t\t\t\t\treturn { fields: accumulated.fields, tail: { variable: tm.variable, ty: _ty } };\n\t\t\t\t}),\n\t\t\tV2.of(initial),\n\t\t);\n\n\t\treturn collected;\n\t});\ncollect.gen = F.flow(collect, V2.pure);\n\nexport const extract = function* (row: Src.Row, lvl: number, types?: NF.Row): Generator<V2.Elaboration<any>, Record<string, EB.Sigma>, any> {\n\tif (row.type === \"empty\") {\n\t\treturn {};\n\t}\n\n\tif (row.type === \"variable\") {\n\t\treturn {};\n\t}\n\n\tconst ktm = NF.Constructors.Var(yield* EB.freshMeta(lvl, NF.Type));\n\tconst tm = NF.Constructors.Var(yield* EB.freshMeta(lvl, ktm));\n\n\tconst kty = NF.Constructors.Var(yield* EB.freshMeta(lvl, NF.Type));\n\tconst ty = NF.Constructors.Var(yield* EB.freshMeta(lvl, kty));\n\tconst info: EB.Sigma = { nf: tm, ann: ty, multiplicity: Q.Many };\n\n\tconst rest = yield* extract({ ...row.row, location: row.location }, lvl + 1);\n\treturn setProp(rest, row.label, info);\n\t// return [[row.label, [v, Q.Many]], ...extract({ ...row.row, location: row.location }, lvl + 1)]\n};\n"],"mappings":"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","names":["term","ctx"]}