{"version":3,"sources":["../../../src/elaboration/inference/holes.ts"],"sourcesContent":["import * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as F from \"fp-ts/lib/function\";\n\ntype Hole = Extract<Src.Term, { type: \"hole\" }>;\n\nexport const infer = (h: Hole): V2.Elaboration<EB.AST> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: h, metadata: { action: \"infer\", description: \"Hole\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst kind = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\tconst meta = EB.Constructors.Var(yield* EB.freshMeta(ctx.env.length, kind));\n\t\t\tconst ty = NF.evaluate(ctx, meta);\n\t\t\t// const modal = NF.infer(env, annotation);\n\t\t\treturn [meta, ty, Q.noUsage(ctx.env.length)] satisfies EB.AST;\n\t\t}),\n\t);\ninfer.gen = F.flow(infer, V2.pure);\n"],"mappings":";AAAA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AAEpB,YAAY,QAAQ;AAGpB,YAAY,OAAO;AAEnB,YAAY,OAAO;AAIZ,MAAM,QAAQ,CAAC,MACrB,GAAG;AAAA,EACF,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,GAAG,UAAU,EAAE,QAAQ,SAAS,aAAa,OAAO,EAAE;AAAA,EACxF,GAAG,GAAG,aAAa;AAClB,UAAM,MAAM,OAAO,GAAG,IAAI;AAC1B,UAAM,OAAO,GAAG,aAAa,IAAI,OAAO,GAAG,UAAU,IAAI,IAAI,QAAQ,GAAG,IAAI,CAAC;AAC7E,UAAM,OAAO,GAAG,aAAa,IAAI,OAAO,GAAG,UAAU,IAAI,IAAI,QAAQ,IAAI,CAAC;AAC1E,UAAM,KAAK,GAAG,SAAS,KAAK,IAAI;AAEhC,WAAO,CAAC,MAAM,IAAI,EAAE,QAAQ,IAAI,IAAI,MAAM,CAAC;AAAA,EAC5C,CAAC;AACF;AACD,MAAM,MAAM,EAAE,KAAK,OAAO,GAAG,IAAI;","names":[]}