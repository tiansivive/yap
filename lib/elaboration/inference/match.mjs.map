{"version":3,"sources":["../../../src/elaboration/inference/match.ts"],"sourcesContent":["import * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport { Patterns } from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as F from \"fp-ts/function\";\n\nimport { match } from \"ts-pattern\";\n\nimport * as P from \"@yap/elaboration/shared/provenance\";\n\nimport * as Modal from \"@yap/verification/modalities/shared\";\nimport { Liquid } from \"@yap/verification/modalities\";\n\ntype Match = Extract<Src.Term, { type: \"match\" }>;\n\nexport const infer = (tm: Match): V2.Elaboration<EB.AST> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: tm, metadata: { action: \"infer\", description: \"Match\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst ast = yield* EB.infer.gen(tm.scrutinee);\n\t\t\tconst alternatives: AltNode[] = yield V2.traverse(tm.alternatives, elaborate(ast, EB.infer));\n\n\t\t\t// Ensure all alternatives have the same type - we pick the type of the first alternative as the common type\n\t\t\tconst common = alternatives[0][1];\n\t\t\tyield V2.traverse(alternatives, ([alt, ty, us], i) => {\n\t\t\t\tconst provenance: P.Provenance[] = [\n\t\t\t\t\t{\n\t\t\t\t\t\ttag: \"alt\",\n\t\t\t\t\t\talt: tm.alternatives[i],\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\taction: \"alternative\",\n\t\t\t\t\t\t\ttype: ty,\n\t\t\t\t\t\t\tmotive: `attempting to unify with previous alternative of type ${NF.display(ty, ctx)}:\\t${Src.Alt.display(tm.alternatives[i])}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{ tag: \"src\", type: \"term\", term: tm.alternatives[i].term, metadata: { action: \"infer\", description: \"\" } },\n\t\t\t\t];\n\t\t\t\treturn V2.track(\n\t\t\t\t\tprovenance,\n\t\t\t\t\tV2.Do(() => V2.tell(\"constraint\", { type: \"assign\", left: ty, right: common, lvl: ctx.env.length })),\n\t\t\t\t);\n\t\t\t});\n\n\t\t\t// TODO: Also deal with usage semantics\n\t\t\tconst [scrutinee, scuty, sus] = ast;\n\t\t\tconst match = EB.Constructors.Match(\n\t\t\t\tscrutinee,\n\t\t\t\talternatives.map(([alt]) => alt),\n\t\t\t);\n\t\t\tconst kind = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\tconst matchTy = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, kind));\n\n\t\t\tconst constraints = alternatives.map(([, ty]): EB.Constraint => ({ type: \"assign\", left: ty, right: matchTy, lvl: ctx.env.length }));\n\t\t\tyield* V2.tell(\"constraint\", constraints);\n\n\t\t\treturn [match, matchTy, sus] satisfies EB.AST;\n\t\t}),\n\t);\ninfer.gen = F.flow(infer, V2.pure);\n\n/**\n * \n\tTODO: Allow for returning a Variant type    \n\tTODO: Augment the context with the scrutinee narrowed to the pattern   \n */\nexport type AltNode = [EB.Alternative, NF.Value, Q.Usages];\nexport const elaborate =\n\t([scrutinee, scuty, sus]: EB.AST, action: (alt: Src.Term) => V2.Elaboration<EB.AST>) =>\n\t(alt: Src.Alternative): V2.Elaboration<AltNode> =>\n\t\tV2.track(\n\t\t\t{ tag: \"alt\", alt, metadata: { action: \"alternative\", motive: \"elaborating pattern\", type: scuty } },\n\t\t\t(() => {\n\t\t\t\tconst extend = (binders: Patterns.Binder[]) => (ctx_: EB.Context) =>\n\t\t\t\t\tbinders.reduce((ctx, [name, va]) => EB.bind(ctx, { type: \"Lambda\", variable: name }, va), ctx_);\n\n\t\t\t\tconst inferAltBy =\n\t\t\t\t\t<K extends keyof Patterns.Inference<Src.Pattern, \"type\">>(key: K) =>\n\t\t\t\t\t(alt: Src.Alternative & { pattern: Extract<Src.Pattern, { type: K }> }) =>\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tconst [pat, patty, patus, binders] = yield* Patterns.infer[key].gen(alt.pattern);\n\t\t\t\t\t\t\tyield* V2.tell(\"constraint\", { type: \"assign\", left: patty, right: scuty });\n\n\t\t\t\t\t\t\tconst node = yield* V2.local(\n\t\t\t\t\t\t\t\textend(binders),\n\t\t\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\t\t\tconst [branch, branty, brus]: EB.AST = yield action(alt.term);\n\t\t\t\t\t\t\t\t\treturn [EB.Constructors.Alternative(pat, branch, binders), branty, brus] satisfies AltNode;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn node;\n\t\t\t\t\t\t});\n\n\t\t\t\tconst r = match(alt)\n\t\t\t\t\t.with({ pattern: { type: \"lit\" } }, inferAltBy(\"Lit\"))\n\t\t\t\t\t.with({ pattern: { type: \"var\" } }, inferAltBy(\"Var\"))\n\t\t\t\t\t.with({ pattern: { type: \"struct\" } }, inferAltBy(\"Struct\"))\n\t\t\t\t\t.with({ pattern: { type: \"variant\" } }, inferAltBy(\"Variant\"))\n\t\t\t\t\t.with({ pattern: { type: \"list\" } }, inferAltBy(\"List\"))\n\t\t\t\t\t.otherwise(alt => {\n\t\t\t\t\t\tthrow new Error(`Pattern Matching for ${alt.pattern.type}: Not implemented`);\n\t\t\t\t\t});\n\n\t\t\t\treturn r;\n\t\t\t})(),\n\t\t);\n"],"mappings":"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","names":["match","alt"]}