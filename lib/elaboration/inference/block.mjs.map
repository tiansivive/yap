{"version":3,"sources":["../../../src/elaboration/inference/block.ts"],"sourcesContent":["import * as F from \"fp-ts/lib/function\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as Lit from \"@yap/shared/literals\";\nimport { Liquid } from \"@yap/verification/modalities\";\n\ntype Block = Extract<Src.Term, { type: \"block\" }>;\n\nexport const infer = (block: Block) =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: block, metadata: { action: \"infer\", description: \"Block statements\" } },\n\t\t(() => {\n\t\t\tconst { statements, return: ret } = block;\n\t\t\tconst recurse = (stmts: Src.Statement[], results: EB.Statement[]): V2.Elaboration<EB.AST> =>\n\t\t\t\tV2.Do(function* () {\n\t\t\t\t\tif (stmts.length === 0) {\n\t\t\t\t\t\treturn yield* inferReturn(block, results);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst [current, ...rest] = stmts;\n\t\t\t\t\tconst [stmt, sty, sus] = yield* EB.Stmt.infer.gen(current);\n\n\t\t\t\t\tif (stmt.type !== \"Let\") {\n\t\t\t\t\t\treturn yield* V2.pure(recurse(rest, [...results, stmt]));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn yield* V2.local(\n\t\t\t\t\t\tctx => EB.bind(ctx, { type: \"Let\", variable: stmt.variable }, sty),\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tconst [tm, ty, [vu, ...rus]] = yield* V2.pure(recurse(rest, [...results, stmt]));\n\t\t\t\t\t\t\tyield* V2.tell(\"constraint\", { type: \"usage\", expected: Q.Many, computed: vu });\n\t\t\t\t\t\t\t// Remove the usage of the bound variable (same as the lambda rule)\n\t\t\t\t\t\t\t// Multiply the usages of the let binder by the multiplicity of the new let binding (same as the application rule)\n\t\t\t\t\t\t\treturn [tm, ty, Q.add(rus, Q.multiply(Q.Many, sus))] as EB.AST;\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\treturn recurse(statements, []);\n\t\t})(),\n\t);\n\nconst inferReturn = function* ({ return: ret }: Block, results: EB.Statement[]) {\n\tif (!ret) {\n\t\t//TODO: add effect tracking\n\t\tconst ty = NF.Constructors.Lit(Lit.Atom(\"Unit\"));\n\t\tconst unit = EB.Constructors.Lit(Lit.Atom(\"unit\"));\n\t\tconst tm = EB.Constructors.Block(results, unit);\n\t\tconst { env } = yield* V2.ask();\n\t\treturn [tm, ty, Q.noUsage(env.length)] satisfies EB.AST;\n\t}\n\n\tconst [t, ty, rus] = yield* EB.infer.gen(ret);\n\treturn [EB.Constructors.Block(results, t), ty, rus] satisfies EB.AST;\n};\n\ninfer.gen = F.flow(infer, V2.pure);\n"],"mappings":";AAAA,YAAY,OAAO;AAEnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AAEnB,YAAY,QAAQ;AAGpB,YAAY,SAAS;AAKd,MAAM,QAAQ,CAAC,UACrB,GAAG;AAAA,EACF,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,OAAO,UAAU,EAAE,QAAQ,SAAS,aAAa,mBAAmB,EAAE;AAAA,GACvG,MAAM;AACN,UAAM,EAAE,YAAY,QAAQ,IAAI,IAAI;AACpC,UAAM,UAAU,CAAC,OAAwB,YACxC,GAAG,GAAG,aAAa;AAClB,UAAI,MAAM,WAAW,GAAG;AACvB,eAAO,OAAO,YAAY,OAAO,OAAO;AAAA,MACzC;AAEA,YAAM,CAAC,SAAS,GAAG,IAAI,IAAI;AAC3B,YAAM,CAAC,MAAM,KAAK,GAAG,IAAI,OAAO,GAAG,KAAK,MAAM,IAAI,OAAO;AAEzD,UAAI,KAAK,SAAS,OAAO;AACxB,eAAO,OAAO,GAAG,KAAK,QAAQ,MAAM,CAAC,GAAG,SAAS,IAAI,CAAC,CAAC;AAAA,MACxD;AAEA,aAAO,OAAO,GAAG;AAAA,QAChB,SAAO,GAAG,KAAK,KAAK,EAAE,MAAM,OAAO,UAAU,KAAK,SAAS,GAAG,GAAG;AAAA,QACjE,GAAG,GAAG,aAAa;AAClB,gBAAM,CAAC,IAAI,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,OAAO,GAAG,KAAK,QAAQ,MAAM,CAAC,GAAG,SAAS,IAAI,CAAC,CAAC;AAC/E,iBAAO,GAAG,KAAK,cAAc,EAAE,MAAM,SAAS,UAAU,EAAE,MAAM,UAAU,GAAG,CAAC;AAG9E,iBAAO,CAAC,IAAI,IAAI,EAAE,IAAI,KAAK,EAAE,SAAS,EAAE,MAAM,GAAG,CAAC,CAAC;AAAA,QACpD,CAAC;AAAA,MACF;AAAA,IACD,CAAC;AAEF,WAAO,QAAQ,YAAY,CAAC,CAAC;AAAA,EAC9B,GAAG;AACJ;AAED,MAAM,cAAc,WAAW,EAAE,QAAQ,IAAI,GAAU,SAAyB;AAC/E,MAAI,CAAC,KAAK;AAET,UAAMA,MAAK,GAAG,aAAa,IAAI,IAAI,KAAK,MAAM,CAAC;AAC/C,UAAM,OAAO,GAAG,aAAa,IAAI,IAAI,KAAK,MAAM,CAAC;AACjD,UAAM,KAAK,GAAG,aAAa,MAAM,SAAS,IAAI;AAC9C,UAAM,EAAE,IAAI,IAAI,OAAO,GAAG,IAAI;AAC9B,WAAO,CAAC,IAAIA,KAAI,EAAE,QAAQ,IAAI,MAAM,CAAC;AAAA,EACtC;AAEA,QAAM,CAAC,GAAG,IAAI,GAAG,IAAI,OAAO,GAAG,MAAM,IAAI,GAAG;AAC5C,SAAO,CAAC,GAAG,aAAa,MAAM,SAAS,CAAC,GAAG,IAAI,GAAG;AACnD;AAEA,MAAM,MAAM,EAAE,KAAK,OAAO,GAAG,IAAI;","names":["ty"]}