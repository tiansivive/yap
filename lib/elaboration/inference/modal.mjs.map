{"version":3,"sources":["../../../src/elaboration/inference/modal.ts"],"sourcesContent":["import * as F from \"fp-ts/lib/function\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\nimport { Liquid } from \"@yap/verification/modalities\";\n\ntype Modal = Extract<Src.Term, { type: \"modal\" }>;\nexport const infer = (modal: Modal): V2.Elaboration<EB.AST> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term: modal, metadata: { action: \"infer\", description: \"Modal term\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst [tm, ty, us] = yield* EB.infer.gen(modal.term);\n\n\t\t\tconst nf = NF.evaluate(ctx, tm); // Modalities work on the term (in normal form), not on its type\n\t\t\tconst liquid = modal.modalities.liquid ? yield* EB.Liquid.typecheck(modal.modalities.liquid, nf) : Liquid.Predicate.Neutral(tm);\n\t\t\tconst quantity = modal.modalities.quantity ?? Q.Many;\n\n\t\t\treturn [EB.Constructors.Modal(tm, { quantity, liquid }), nf, us] satisfies EB.AST;\n\t\t}),\n\t);\n\ninfer.gen = F.flow(infer, V2.pure);\n"],"mappings":";AAAA,YAAY,OAAO;AAEnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AAEnB,YAAY,QAAQ;AAEpB,SAAS,cAAc;AAGhB,MAAM,QAAQ,CAAC,UACrB,GAAG;AAAA,EACF,EAAE,KAAK,OAAO,MAAM,QAAQ,MAAM,OAAO,UAAU,EAAE,QAAQ,SAAS,aAAa,aAAa,EAAE;AAAA,EAClG,GAAG,GAAG,aAAa;AAClB,UAAM,MAAM,OAAO,GAAG,IAAI;AAC1B,UAAM,CAAC,IAAI,IAAI,EAAE,IAAI,OAAO,GAAG,MAAM,IAAI,MAAM,IAAI;AAEnD,UAAM,KAAK,GAAG,SAAS,KAAK,EAAE;AAC9B,UAAM,SAAS,MAAM,WAAW,SAAS,OAAO,GAAG,OAAO,UAAU,MAAM,WAAW,QAAQ,EAAE,IAAI,OAAO,UAAU,QAAQ,EAAE;AAC9H,UAAM,WAAW,MAAM,WAAW,YAAY,EAAE;AAEhD,WAAO,CAAC,GAAG,aAAa,MAAM,IAAI,EAAE,UAAU,OAAO,CAAC,GAAG,IAAI,EAAE;AAAA,EAChE,CAAC;AACF;AAED,MAAM,MAAM,EAAE,KAAK,OAAO,GAAG,IAAI;","names":[]}