{"version":3,"sources":["../../../src/elaboration/normalization/evaluation.ts"],"sourcesContent":["import { match, P } from \"ts-pattern\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as NF from \".\";\nimport _ from \"lodash\";\n\nimport * as E from \"fp-ts/lib/Either\";\nimport * as F from \"fp-ts/lib/function\";\n\nimport * as R from \"@yap/shared/rows\";\nimport { Option } from \"fp-ts/lib/Option\";\nimport * as O from \"fp-ts/lib/Option\";\nimport * as A from \"fp-ts/lib/NonEmptyArray\";\nimport { Liquid } from \"@yap/verification/modalities\";\nimport * as Modal from \"@yap/verification/modalities/shared\";\nimport { Implicitness } from \"@yap/shared/implicitness\";\n\nexport function evaluate(ctx: EB.Context, term: EB.Term): NF.Value {\n\t//Log.push(\"eval\");\n\t//Log.logger.debug(EB.Display.Term(term), { ctx.env,  term: EB.Display.Term(term) });\n\tconst res = match(term)\n\t\t.with({ type: \"Lit\" }, ({ value }): NF.Value => NF.Constructors.Lit(value))\n\t\t.with({ type: \"Var\", variable: { type: \"Label\" } }, ({ variable }): NF.Value => {\n\t\t\tconst sig = ctx.sigma[variable.name];\n\n\t\t\tif (!sig) {\n\t\t\t\tthrow new Error(\"Unbound label: \" + variable.name);\n\t\t\t}\n\n\t\t\treturn sig.nf;\n\t\t})\n\t\t.with({ type: \"Var\", variable: { type: \"Free\" } }, ({ variable }) => {\n\t\t\tconst val = ctx.imports[variable.name];\n\n\t\t\tif (!val) {\n\t\t\t\tthrow new Error(\"Unbound free variable: \" + variable.name);\n\t\t\t}\n\n\t\t\treturn evaluate(ctx, val[0]);\n\t\t})\n\t\t.with({ type: \"Var\", variable: { type: \"Meta\" } }, ({ variable }) => {\n\t\t\tif (!ctx.zonker[variable.val]) {\n\t\t\t\tconst v = NF.Constructors.Var(variable);\n\t\t\t\treturn NF.Constructors.Neutral(v);\n\t\t\t}\n\n\t\t\treturn ctx.zonker[variable.val];\n\t\t})\n\t\t.with({ type: \"Var\", variable: { type: \"Bound\" } }, ({ variable }) => {\n\t\t\tconst entry = ctx.env[variable.index];\n\t\t\tif (entry.type[0].type === \"Mu\") {\n\t\t\t\treturn NF.Constructors.Neutral(entry.nf);\n\t\t\t}\n\t\t\treturn entry.nf;\n\t\t})\n\t\t.with({ type: \"Var\", variable: { type: \"Foreign\" } }, ({ variable }) => {\n\t\t\tconst val = ctx.ffi[variable.name];\n\t\t\tif (!val) {\n\t\t\t\treturn NF.Constructors.Neutral(NF.Constructors.Var(variable));\n\t\t\t}\n\n\t\t\tif (val && val.arity === 0) {\n\t\t\t\treturn val.compute();\n\t\t\t}\n\n\t\t\tconst external = NF.Constructors.External(variable.name, val.arity, val.compute, []);\n\t\t\treturn external;\n\t\t})\n\n\t\t.with({ type: \"Abs\", binding: { type: \"Lambda\" } }, ({ body, binding }) => {\n\t\t\tconst ann = evaluate(ctx, binding.annotation);\n\t\t\treturn NF.Constructors.Lambda(binding.variable, binding.icit, NF.Constructors.Closure(ctx, body), ann);\n\t\t})\n\t\t.with({ type: \"Abs\", binding: { type: \"Pi\" } }, ({ body, binding }): NF.Value => {\n\t\t\tconst ann = evaluate(ctx, binding.annotation);\n\t\t\treturn NF.Constructors.Pi(binding.variable, binding.icit, ann, NF.Constructors.Closure(ctx, body));\n\t\t})\n\t\t.with({ type: \"Abs\", binding: { type: \"Mu\" } }, (mu): NF.Value => {\n\t\t\tconst ann = evaluate(ctx, mu.binding.annotation);\n\t\t\tconst val = NF.Constructors.Mu(mu.binding.variable, mu.binding.source, ann, NF.Constructors.Closure(ctx, mu.body));\n\t\t\treturn val;\n\t\t\t// NOTE: This is commented out because we want to defer unfolding of mu types to unification. This has the benefit of displaying the recursive type more closely to the source\n\t\t\t// const extended = EB.unfoldMu(ctx, { type: \"Mu\", variable: mu.binding.variable }, val);\n\t\t\t// return evaluate(extended, mu.body);\n\t\t})\n\t\t.with({ type: \"App\" }, ({ func, arg, icit }) => {\n\t\t\tconst nff = evaluate(ctx, func);\n\t\t\tconst nfa = evaluate(ctx, arg);\n\t\t\treturn reduce(nff, nfa, icit);\n\t\t})\n\t\t.with({ type: \"Row\" }, ({ row }) => {\n\t\t\treturn NF.Constructors.Row(evalRow(ctx, row));\n\t\t})\n\t\t.with({ type: \"Match\" }, v => {\n\t\t\t// console.warn(\"Evaluating match terms not yet implemented. Returning scrutinee as Normal Form for the time being\");\n\t\t\tconst scrutinee = evaluate(ctx, v.scrutinee);\n\t\t\tif (scrutinee.type === \"Neutral\" || (scrutinee.type === \"Var\" && scrutinee.variable.type === \"Meta\")) {\n\t\t\t\tconst lambda = NF.Constructors.Lambda(\"_scrutinee\", \"Explicit\", NF.Constructors.Closure(ctx, v), NF.Any);\n\t\t\t\tconst app = NF.Constructors.App(lambda, scrutinee, \"Explicit\");\n\t\t\t\treturn NF.Constructors.Neutral(app);\n\t\t\t}\n\n\t\t\tconst res = matching(ctx, scrutinee, v.alternatives);\n\n\t\t\tif (!res) {\n\t\t\t\tthrow new Error(\"Match: No alternative matched\");\n\t\t\t}\n\t\t\treturn res;\n\t\t})\n\t\t.with({ type: \"Proj\" }, ({ term, label }) => {\n\t\t\tconst base = evaluate(ctx, term);\n\n\t\t\ttype ProjectAttempt = { tag: \"found\"; value: NF.Value } | { tag: \"blocked\" } | { tag: \"missing\" } | { tag: \"not-applicable\" };\n\n\t\t\tconst lookupRow = (row: NF.Row): ProjectAttempt => {\n\t\t\t\tswitch (row.type) {\n\t\t\t\t\tcase \"empty\":\n\t\t\t\t\t\treturn { tag: \"missing\" };\n\t\t\t\t\tcase \"variable\":\n\t\t\t\t\t\treturn { tag: \"blocked\" };\n\t\t\t\t\tcase \"extension\":\n\t\t\t\t\t\tif (row.label === label) {\n\t\t\t\t\t\t\treturn { tag: \"found\", value: row.value };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn lookupRow(row.row);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst attemptProject = (value: NF.Value): ProjectAttempt => {\n\t\t\t\tconst target = unwrapNeutral(value);\n\n\t\t\t\treturn match(target)\n\t\t\t\t\t.with({ type: \"Neutral\" }, (): ProjectAttempt => ({ tag: \"blocked\" }))\n\t\t\t\t\t.with(NF.Patterns.Row, ({ row }) => lookupRow(row))\n\t\t\t\t\t.with(NF.Patterns.Struct, NF.Patterns.Schema, NF.Patterns.Variant, ({ arg }) => lookupRow(arg.row))\n\t\t\t\t\t.otherwise((): ProjectAttempt => ({ tag: \"not-applicable\" }));\n\t\t\t};\n\n\t\t\tconst attempt = attemptProject(base);\n\n\t\t\tif (attempt.tag === \"found\") {\n\t\t\t\treturn attempt.value;\n\t\t\t}\n\n\t\t\tif (attempt.tag === \"missing\") {\n\t\t\t\tthrow new Error(`Projection: label ${label} not found`);\n\t\t\t}\n\n\t\t\tconst binder = `$proj_${label}`;\n\t\t\tconst body = EB.Constructors.Proj(label, EB.Constructors.Var({ type: \"Bound\", index: 0 }));\n\t\t\tconst lambda = NF.Constructors.Lambda(binder, \"Explicit\", NF.Constructors.Closure(ctx, body), NF.Any); //QUESTION: Is the Any here ok? This is a dummy type anyways...\n\t\t\tconst app = NF.Constructors.App(lambda, base, \"Explicit\");\n\t\t\treturn NF.Constructors.Neutral(app);\n\t\t})\n\t\t.with({ type: \"Inj\" }, ({ term, label, value: valueTerm }) => {\n\t\t\tconst base = evaluate(ctx, term);\n\t\t\tconst injected = evaluate(ctx, valueTerm);\n\n\t\t\ttype InjectAttempt = { tag: \"updated\"; value: NF.Value } | { tag: \"blocked\" } | { tag: \"not-applicable\" };\n\n\t\t\tconst setRowValue = (row: NF.Row): NF.Row => {\n\t\t\t\tswitch (row.type) {\n\t\t\t\t\tcase \"empty\":\n\t\t\t\t\t\treturn NF.Constructors.Extension(label, injected, row);\n\t\t\t\t\tcase \"variable\":\n\t\t\t\t\t\treturn NF.Constructors.Extension(label, injected, row);\n\t\t\t\t\tcase \"extension\": {\n\t\t\t\t\t\tif (row.label === label) {\n\t\t\t\t\t\t\treturn NF.Constructors.Extension(label, injected, row.row);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst rest = setRowValue(row.row);\n\t\t\t\t\t\treturn NF.Constructors.Extension(row.label, row.value, rest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst attemptInject = (value: NF.Value): InjectAttempt => {\n\t\t\t\tconst target = unwrapNeutral(value);\n\n\t\t\t\treturn match(target)\n\t\t\t\t\t.with({ type: \"Neutral\" }, (): InjectAttempt => ({ tag: \"blocked\" }))\n\t\t\t\t\t.with(NF.Patterns.Row, ({ row }): InjectAttempt => {\n\t\t\t\t\t\tconst updated = setRowValue(row);\n\t\t\t\t\t\treturn { tag: \"updated\", value: NF.Constructors.Row(updated) };\n\t\t\t\t\t})\n\t\t\t\t\t.with(NF.Patterns.Struct, NF.Patterns.Schema, NF.Patterns.Variant, matched => {\n\t\t\t\t\t\tconst updated = setRowValue(matched.arg.row);\n\n\t\t\t\t\t\tconst updatedRow = NF.Constructors.Row(updated);\n\t\t\t\t\t\treturn { tag: \"updated\", value: NF.Constructors.App(matched.func, updatedRow, matched.icit) } satisfies InjectAttempt;\n\t\t\t\t\t})\n\t\t\t\t\t.otherwise((): InjectAttempt => ({ tag: \"not-applicable\" }));\n\t\t\t};\n\n\t\t\tconst attempt = attemptInject(base);\n\n\t\t\tif (attempt.tag === \"updated\") {\n\t\t\t\treturn attempt.value;\n\t\t\t}\n\n\t\t\tconst binder = `$inj_${label}`;\n\t\t\tconst body = EB.Constructors.Inj(label, valueTerm, EB.Constructors.Var({ type: \"Bound\", index: 0 }));\n\t\t\tconst lambda = NF.Constructors.Lambda(binder, \"Explicit\", NF.Constructors.Closure(ctx, body), NF.Any);\n\t\t\tconst app = NF.Constructors.App(lambda, base, \"Explicit\");\n\t\t\treturn NF.Constructors.Neutral(app);\n\t\t})\n\t\t.with({ type: \"Modal\" }, ({ term, modalities }) => {\n\t\t\tconst nf = evaluate(ctx, term);\n\n\t\t\treturn NF.Constructors.Modal(nf, {\n\t\t\t\tquantity: modalities.quantity,\n\t\t\t\tliquid: NF.evaluate(ctx, modalities.liquid),\n\t\t\t});\n\t\t})\n\t\t.otherwise(tm => {\n\t\t\tconsole.log(\"Eval: Not implemented yet\", EB.Display.Term(tm, ctx));\n\t\t\tthrow new Error(\"Not implemented\");\n\t\t});\n\n\treturn res;\n}\n\nexport const reduce = (nff: NF.Value, nfa: NF.Value, icit: Implicitness): NF.Value =>\n\tmatch(nff)\n\t\t.with({ type: \"Neutral\" }, ({ value }) => NF.Constructors.Neutral(NF.Constructors.App(value, nfa, icit)))\n\t\t.with({ type: \"Modal\" }, ({ modalities, value }) => {\n\t\t\t// QUESTION: Perhaps we preserve the modalities on the result of the application?\n\t\t\t// Is this related to the concept of \"measures\" in Liquid Haskell\n\t\t\t// If we have a fn `f: (Int -> Int){ x | <refinement on an arrow type? }\n\t\t\t// What could we refine f itself to be?\n\t\t\t// And if we apply f to an argument, what could we refine the result to be?\n\t\t\tconsole.warn(\"Applying a modal function. The modality of the argument will be ignored. What should happen here?\");\n\t\t\treturn reduce(value, nfa, icit);\n\t\t})\n\t\t.with({ type: \"Abs\", binder: { type: \"Mu\" } }, mu => {\n\t\t\t// Unfold the mu\n\t\t\t// const body = apply(mu.binder, mu.closure, mu);\n\t\t\t// return reduce(body, nfa, icit);\n\n\t\t\t// NOTE: Do not unfold the mu during normalization/evaluation. Defer that to unification as that's where we actually need to see the structure inside recursive types\n\t\t\treturn NF.Constructors.Neutral(NF.Constructors.App(nff, nfa, icit));\n\t\t})\n\t\t.with({ type: \"Abs\" }, ({ closure, binder }) => {\n\t\t\treturn apply(binder, closure, nfa);\n\t\t})\n\t\t.with({ type: \"Lit\", value: { type: \"Atom\" } }, ({ value }) => NF.Constructors.App(NF.Constructors.Lit(value), nfa, icit))\n\t\t.with({ type: \"Var\", variable: { type: \"Meta\" } }, _ => NF.Constructors.Neutral(NF.Constructors.App(nff, nfa, icit)))\n\t\t.with({ type: \"Var\", variable: { type: \"Foreign\" } }, ({ variable }) => NF.Constructors.Neutral(NF.Constructors.App(nff, nfa, icit)))\n\n\t\t.with({ type: \"App\" }, ({ func, arg, icit }) => {\n\t\t\tconst nff = reduce(func, arg, icit);\n\t\t\treturn NF.Constructors.App(nff, nfa, icit);\n\t\t})\n\t\t.with({ type: \"External\" }, ({ name, args, arity, compute }) => {\n\t\t\tif (arity === 0) {\n\t\t\t\treturn compute();\n\t\t\t}\n\n\t\t\tconst accumulated = [...args, nfa];\n\t\t\tif (accumulated.length === arity && accumulated.every(a => a.type !== \"Neutral\")) {\n\t\t\t\treturn compute(...accumulated.map(ignoraModal));\n\t\t\t}\n\t\t\treturn NF.Constructors.External(name, arity, compute, accumulated);\n\t\t})\n\t\t.otherwise(() => {\n\t\t\tthrow new Error(\"Impossible: Tried to apply a non-function while evaluating: \" + JSON.stringify(nff));\n\t\t});\n\nexport const matching = (ctx: EB.Context, nf: NF.Value, alts: EB.Alternative[]): NF.Value | undefined => {\n\treturn match(alts)\n\t\t.with([], () => undefined)\n\t\t.with([P._, ...P.array()], ([alt, ...rest]) =>\n\t\t\tF.pipe(\n\t\t\t\tmeet(ctx, alt.pattern, nf),\n\t\t\t\tO.map(binders => {\n\t\t\t\t\tconst extended = binders.reduce(\n\t\t\t\t\t\t(_ctx, { binder, quantity, liquid }) => EB.extend(_ctx, binder, NF.Constructors.Modal(nf, { quantity, liquid })),\n\t\t\t\t\t\tctx,\n\t\t\t\t\t);\n\t\t\t\t\treturn evaluate(extended, alt.term);\n\t\t\t\t}),\n\t\t\t\tO.getOrElse(() => matching(ctx, nf, rest)),\n\t\t\t),\n\t\t)\n\t\t.exhaustive();\n};\n\nexport const apply = (binder: EB.Binder, closure: NF.Closure, value: NF.Value): NF.Value => {\n\tconst { ctx, term } = closure;\n\tconst extended = EB.extend(ctx, binder, value);\n\n\tif (closure.type === \"Closure\") {\n\t\treturn evaluate(extended, term);\n\t}\n\n\tconst args = extended.env.slice(0, closure.arity).map(({ nf }) => nf);\n\treturn closure.compute(...args);\n};\n\nexport const unwrapNeutral = (value: NF.Value): NF.Value => {\n\treturn match(value)\n\t\t.with({ type: \"Neutral\" }, ({ value }) => unwrapNeutral(value))\n\t\t.otherwise(() => value);\n};\n\nexport const force = (ctx: EB.Context, value: NF.Value): NF.Value => {\n\treturn match(value)\n\t\t.with({ type: \"Neutral\" }, v => force(ctx, unwrapNeutral(v)))\n\t\t.with(NF.Patterns.Flex, ({ variable }) => {\n\t\t\tif (ctx.zonker[variable.val]) {\n\t\t\t\treturn force(ctx, ctx.zonker[variable.val]);\n\t\t\t}\n\t\t\treturn value;\n\t\t})\n\t\t.otherwise(() => value);\n};\n\nexport const ignoraModal = (value: NF.Value): NF.Value => {\n\treturn match(value)\n\t\t.with({ type: \"Modal\" }, ({ value }) => ignoraModal(value))\n\t\t.otherwise(() => value);\n};\n\nexport const builtinsOps = [\"+\", \"-\", \"*\", \"/\", \"&&\", \"||\", \"==\", \"!=\", \"<\", \">\", \"<=\", \">=\", \"%\"];\n\ntype MeetResult = { binder: EB.Binder } & NF.Modalities;\nconst meet = (ctx: EB.Context, pattern: EB.Pattern, nf: NF.Value): Option<MeetResult[]> => {\n\tconst truthy = (v: NF.Value) => Liquid.Predicate.NeutralNF(v, ctx);\n\treturn match([unwrapNeutral(nf), pattern])\n\t\t.with([P._, { type: \"Wildcard\" }], () => O.some([]))\n\t\t.with([P._, { type: \"Binder\" }], ([v, p]) => {\n\t\t\tconst binder: EB.Binder = { type: \"Lambda\", variable: p.value };\n\t\t\treturn O.some<MeetResult[]>([{ binder, quantity: Q.Many, liquid: truthy(v) }]);\n\t\t})\n\t\t.with(\n\t\t\t[{ type: \"Lit\" }, { type: \"Lit\" }],\n\t\t\t([v, p]) => _.isEqual(v.value, p.value),\n\t\t\t() => O.some([]),\n\t\t)\n\n\t\t.with([NF.Patterns.Schema, { type: \"Struct\" }], [NF.Patterns.Struct, { type: \"Struct\" }], ([{ arg }, p]) => meetAll(ctx, p.row, arg.row))\n\t\t.with([NF.Patterns.Row, { type: \"Row\" }], ([v, p]) => {\n\t\t\treturn meetAll(ctx, p.row, v.row);\n\t\t})\n\t\t.with([NF.Patterns.Variant, { type: \"Variant\" }], [NF.Patterns.Struct, { type: \"Variant\" }], ([{ arg }, p]) => {\n\t\t\treturn meetOne(ctx, p.row, arg.row);\n\t\t})\n\t\t.with([NF.Patterns.HashMap, { type: \"List\" }], ([v, p]) => {\n\t\t\tconsole.warn(\"List pattern matching not yet implemented\");\n\t\t\treturn O.some([]);\n\t\t})\n\t\t.with(\n\t\t\t[NF.Patterns.Atom, { type: \"Var\" }],\n\t\t\t([{ value: v }, { value: p }]) => v.value === p,\n\t\t\t() => O.some([]),\n\t\t)\n\t\t.otherwise(() => O.none);\n};\n\nconst meetAll = (ctx: EB.Context, pats: R.Row<EB.Pattern, string>, vals: NF.Row): Option<MeetResult[]> => {\n\tconst truthy = (v: NF.Value) => Liquid.Predicate.NeutralNF(v, ctx);\n\treturn match([pats, vals])\n\t\t.with([{ type: \"empty\" }, P._], () => O.some([])) // empty row matches anything\n\t\t.with([{ type: \"variable\" }, P._], ([r]) => {\n\t\t\t// bind the variable\n\t\t\tconst binder: EB.Binder = { type: \"Lambda\", variable: r.variable };\n\t\t\treturn O.some([{ binder, quantity: Q.Many, liquid: truthy(NF.Any) }]);\n\t\t})\n\n\t\t.with([{ type: \"extension\" }, { type: \"empty\" }], () => O.none)\n\t\t.with([{ type: \"extension\" }, { type: \"variable\" }], () => O.none)\n\t\t.with([{ type: \"extension\" }, { type: \"extension\" }], ([r1, r2]) => {\n\t\t\tconst rewritten = R.rewrite(r2, r1.label);\n\t\t\tif (E.isLeft(rewritten)) {\n\t\t\t\treturn O.none;\n\t\t\t}\n\n\t\t\tif (rewritten.right.type !== \"extension\") {\n\t\t\t\tthrow new Error(\"Rewritting a row extension should result in another row extension\");\n\t\t\t}\n\t\t\tconst { row } = rewritten.right;\n\t\t\treturn F.pipe(\n\t\t\t\tO.Do,\n\t\t\t\tO.apS(\"current\", meet(ctx, r1.value, rewritten.right.value)),\n\t\t\t\tO.apS(\"rest\", meetAll(ctx, r1.row, row)),\n\t\t\t\tO.map(({ current, rest }) => current.concat(rest)),\n\t\t\t);\n\t\t})\n\t\t.exhaustive();\n};\n\nconst meetOne = (ctx: EB.Context, pats: R.Row<EB.Pattern, string>, vals: NF.Row): Option<MeetResult[]> => {\n\tconst truthy = (v: NF.Value) => Liquid.Predicate.NeutralNF(v, ctx);\n\treturn match([pats, vals])\n\t\t.with([{ type: \"empty\" }, P._], () => O.none)\n\t\t.with([{ type: \"variable\" }, P._], ([r]) => {\n\t\t\t// bind the variable\n\t\t\tconst binder: EB.Binder = { type: \"Lambda\", variable: r.variable };\n\t\t\treturn O.some([{ binder, quantity: Q.Many, liquid: truthy(NF.Any) }]);\n\t\t})\n\t\t.with([{ type: \"extension\" }, { type: \"empty\" }], () => O.none)\n\t\t.with([{ type: \"extension\" }, { type: \"variable\" }], () => O.none)\n\t\t.with([{ type: \"extension\" }, { type: \"extension\" }], ([r1, r2]) => {\n\t\t\tconst rewritten = R.rewrite(r2, r1.label);\n\t\t\tif (E.isLeft(rewritten)) {\n\t\t\t\treturn meetOne(ctx, r1.row, r2);\n\t\t\t}\n\n\t\t\tif (rewritten.right.type !== \"extension\") {\n\t\t\t\tthrow new Error(\"Rewritting a row extension should result in another row extension\");\n\t\t\t}\n\t\t\treturn meet(ctx, r1.value, rewritten.right.value);\n\t\t})\n\t\t.exhaustive();\n};\n\nconst evalRow = (ctx: EB.Context, row: EB.Row): NF.Row =>\n\tmatch(row)\n\t\t.with({ type: \"empty\" }, r => r)\n\t\t.with({ type: \"extension\" }, ({ label, value: term, row }) => {\n\t\t\tconst value = evaluate(ctx, term);\n\t\t\tconst rest = evalRow(ctx, row);\n\t\t\treturn NF.Constructors.Extension(label, value, rest);\n\t\t})\n\t\t.with({ type: \"variable\" }, (r): NF.Row => {\n\t\t\tif (r.variable.type === \"Meta\") {\n\t\t\t\treturn { type: \"variable\", variable: r.variable };\n\t\t\t}\n\n\t\t\tif (r.variable.type === \"Bound\") {\n\t\t\t\tconst { nf } = ctx.env[r.variable.index];\n\t\t\t\tconst val = unwrapNeutral(nf);\n\n\t\t\t\tif (val.type === \"Row\") {\n\t\t\t\t\treturn val.row;\n\t\t\t\t}\n\n\t\t\t\tif (val.type === \"Var\") {\n\t\t\t\t\treturn { type: \"variable\", variable: val.variable };\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(\"Evaluating a row variable that is not a row or a variable: \" + NF.display(val, ctx));\n\t\t\t}\n\n\t\t\tthrow new Error(`Eval Row Variable: Not implemented yet: ${JSON.stringify(r)}`);\n\t\t})\n\t\t.otherwise(() => {\n\t\t\tthrow new Error(\"Not implemented\");\n\t\t});\n"],"mappings":"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","names":["res","term","_","icit","nff","value","row"]}