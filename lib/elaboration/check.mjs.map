{"version":3,"sources":["../../src/elaboration/check.ts"],"sourcesContent":["import { match, P } from \"ts-pattern\";\n\nimport * as F from \"fp-ts/lib/function\";\nimport * as E from \"fp-ts/lib/Either\";\nimport * as RCD from \"fp-ts/lib/Record\";\nimport * as A from \"fp-ts/lib/Array\";\n\nimport * as EB from \".\";\nimport * as NF from \"./normalization\";\nimport * as M from \"./shared/monad\";\nimport * as V2 from \"./shared/monad.v2\";\n\nimport * as Src from \"@yap/src/index\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as R from \"@yap/shared/rows\";\n\nimport { freshMeta } from \"./shared/supply\";\n\nimport _ from \"lodash\";\nimport { extract } from \"./inference/rows\";\nimport { entries, set } from \"@yap/utils\";\n\nimport * as Err from \"./shared/errors\";\nimport { Liquid } from \"@yap/verification/modalities\";\n\ntype Result = [EB.Term, Q.Usages];\nexport const check = (term: Src.Term, type: NF.Value): V2.Elaboration<[EB.Term, Q.Usages]> =>\n\tV2.track(\n\t\t{ tag: \"src\", type: \"term\", term, metadata: { action: \"checking\", against: type } },\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\tconst result = match<[Src.Term, NF.Value], V2.Elaboration<[EB.Term, Q.Usages]>>([term, type])\n\t\t\t\t.with([{ type: \"hole\" }, P._], () =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst k = NF.Constructors.Var(yield* EB.freshMeta(ctx.env.length, NF.Type));\n\t\t\t\t\t\treturn [EB.Constructors.Var(yield* freshMeta(ctx.env.length, k)), []] satisfies Result;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[{ type: \"lambda\" }, { type: \"Abs\", binder: { type: \"Pi\" } }],\n\t\t\t\t\t([tm, ty]) => tm.icit === ty.binder.icit,\n\t\t\t\t\t([tm, ty]) =>\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tconst bType = NF.apply(ty.binder, ty.closure, NF.Constructors.Rigid(ctx.env.length));\n\n\t\t\t\t\t\t\tconst ann = tm.annotation ? (yield* EB.check.gen(tm.annotation, ty.binder.annotation))[0] : NF.quote(ctx, ctx.env.length, ty.binder.annotation);\n\n\t\t\t\t\t\t\treturn yield* V2.local(\n\t\t\t\t\t\t\t\tctx => EB.bind(ctx, { type: \"Lambda\", variable: tm.variable }, ty.binder.annotation),\n\t\t\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\t\t\tconst [body, us] = yield* Check.val.gen(tm.body, bType);\n\t\t\t\t\t\t\t\t\t// const [vu] = us;\n\t\t\t\t\t\t\t\t\t//yield* V2.tell(\"constraint\", { type: \"usage\", expected: ty.binder.annotation.nf, computed: vu });\n\t\t\t\t\t\t\t\t\treturn [EB.Constructors.Lambda(tm.variable, tm.icit, body, ann), us] satisfies Result;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[P._, { type: \"Abs\", binder: { type: \"Pi\" } }],\n\t\t\t\t\t([_, ty]) => ty.binder.icit === \"Implicit\",\n\t\t\t\t\t([tm, ty]) =>\n\t\t\t\t\t\tV2.Do(() => {\n\t\t\t\t\t\t\tconst ann = NF.quote(ctx, ctx.env.length, ty.binder.annotation);\n\t\t\t\t\t\t\treturn V2.local(\n\t\t\t\t\t\t\t\tctx => EB.bind(ctx, { type: \"Lambda\", variable: ty.binder.variable }, ty.binder.annotation, \"inserted\"),\n\t\t\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\t\t\tconst bType = NF.apply(ty.binder, ty.closure, NF.Constructors.Rigid(ctx.env.length));\n\t\t\t\t\t\t\t\t\tconst [_tm, us] = yield* Check.val.gen(tm, bType);\n\t\t\t\t\t\t\t\t\tconst [vu] = us;\n\t\t\t\t\t\t\t\t\t//\tyield* V2.tell(\"constraint\", { type: \"usage\", expected: ty.binder.annotation[1], computed: vu });\n\t\t\t\t\t\t\t\t\treturn [EB.Constructors.Lambda(ty.binder.variable, \"Implicit\", _tm, ann), us] satisfies Result;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}),\n\t\t\t\t)\n\n\t\t\t\t.with([{ type: \"variant\" }, NF.Patterns.Type], ([{ row }]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [r, us] = yield* Check.row.gen(row, NF.Type, ctx.env.length);\n\t\t\t\t\t\treturn [EB.Constructors.Variant(r), us] satisfies Result;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([{ type: \"tuple\" }, NF.Patterns.Type], ([{ row }]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [r, us] = yield* Check.row.gen(row, NF.Type, ctx.env.length);\n\t\t\t\t\t\treturn [EB.Constructors.Schema(r), us] satisfies Result;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([{ type: \"struct\" }, NF.Patterns.Type], ([{ row }]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [r, us] = yield* Check.row.gen(row, NF.Type, ctx.env.length);\n\t\t\t\t\t\treturn [EB.Constructors.Schema(r), us] satisfies Result;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([{ type: \"injection\" }, NF.Patterns.Type], ([inj, ty]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [tm, us] = yield* Check.val.gen(inj.value, ty);\n\t\t\t\t\t\tconst [checked] = yield* Check.val.gen(inj.term, ty);\n\n\t\t\t\t\t\treturn [EB.Constructors.Inj(inj.label, tm, checked), us] satisfies Result;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t// QUESTION: How to check the resulting proj type is a NF.Type? Should we?\n\t\t\t\t// .with([{ type: \"projection\"}, NF.Patterns.Type], ([proj, ty]) => V2.Do(function* () {\n\t\t\t\t// \tconst [tm, inferred, us] = yield* EB.infer.gen(proj);\n\t\t\t\t// \treturn [EB.Constructors.Proj(proj.label, tm), us] satisfies Result;\n\t\t\t\t// }))\n\t\t\t\t.with([{ type: \"struct\" }, NF.Patterns.HashMap], ([struct, hashmap]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [r, us] = yield* Check.row.gen(struct.row, hashmap.value.func.arg, ctx.env.length);\n\t\t\t\t\t\tyield* V2.tell(\"constraint\", {\n\t\t\t\t\t\t\ttype: \"assign\",\n\t\t\t\t\t\t\tleft: hashmap.value.arg,\n\t\t\t\t\t\t\tright: NF.Constructors.Var({ type: \"Foreign\", name: \"defaultHashMap\" }),\n\t\t\t\t\t\t\tlvl: ctx.env.length,\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn [EB.Constructors.Struct(r), us] satisfies Result;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([{ type: \"struct\" }, NF.Patterns.Schema], ([tm, val]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst bindings = yield* extract(tm.row, ctx.env.length);\n\t\t\t\t\t\tconst [r, us] = yield* V2.local(\n\t\t\t\t\t\t\tctx => entries(bindings).reduce((ctx, [label, mv]) => EB.extendSigma(ctx, label, mv), ctx),\n\t\t\t\t\t\t\tCheck.row.traverse(tm.row, val.arg.row, Q.noUsage(ctx.env.length), bindings),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn [EB.Constructors.Struct(r), us] satisfies Result;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([{ type: \"match\" }, NF.Patterns.Type], ([match, ty]) => {\n\t\t\t\t\treturn V2.Do(function* () {\n\t\t\t\t\t\tconst ast = yield* EB.infer.gen(match.scrutinee);\n\t\t\t\t\t\tconst alternatives = yield* V2.pure(\n\t\t\t\t\t\t\tV2.traverse(\n\t\t\t\t\t\t\t\tmatch.alternatives,\n\t\t\t\t\t\t\t\tEB.Inference.Match.elaborate(ast, src =>\n\t\t\t\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\t\t\t\tconst [tm, us] = yield* EB.check.gen(src, ty);\n\t\t\t\t\t\t\t\t\t\treturn [tm, ty, us];\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst [scrutinee, , sus] = ast;\n\t\t\t\t\t\tconst tm = EB.Constructors.Match(\n\t\t\t\t\t\t\tscrutinee,\n\t\t\t\t\t\t\talternatives.map(([alt]) => alt),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn [tm, sus] satisfies Result;\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.with(\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: \"lit\", value: { type: \"Num\" } },\n\t\t\t\t\t\t{ type: \"Lit\", value: { type: \"Num\" } },\n\t\t\t\t\t],\n\t\t\t\t\t([tm, val]) => {\n\t\t\t\t\t\tif (tm.value.value === val.value.value) {\n\t\t\t\t\t\t\treturn V2.of([EB.Constructors.Lit(tm.value), Q.noUsage(ctx.env.length)] satisfies Result);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn V2.Do(() => V2.fail(Err.TypeMismatch(NF.Constructors.Lit(tm.value), val)));\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\t.with([{ type: \"lit\", value: { type: \"Num\" } }, NF.Patterns.Type], ([tm, _]) => {\n\t\t\t\t\treturn V2.of([EB.Constructors.Lit(tm.value), Q.noUsage(ctx.env.length)] satisfies Result);\n\t\t\t\t})\n\t\t\t\t.with([P._, { type: \"Modal\" }], ([tm, val]) => Check.val(tm, val.value))\n\t\t\t\t.with([{ type: \"modal\" }, P._], ([tm, val]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [checked, us] = yield* Check.val.gen(tm.term, val);\n\n\t\t\t\t\t\tconst liquid = tm.modalities.liquid\n\t\t\t\t\t\t\t? yield* EB.Liquid.typecheck(tm.modalities.liquid, NF.evaluate(ctx, checked))\n\t\t\t\t\t\t\t: Liquid.Predicate.Neutral(checked);\n\t\t\t\t\t\tconst quantity = tm.modalities.quantity ?? Q.Many;\n\n\t\t\t\t\t\treturn [EB.Constructors.Modal(checked, { liquid, quantity }), us] satisfies Result;\n\t\t\t\t\t}),\n\t\t\t\t)\n\n\t\t\t\t.otherwise(([src, ty]) =>\n\t\t\t\t\tV2.Do(() =>\n\t\t\t\t\t\tV2.local(\n\t\t\t\t\t\t\tctx => (_.isEqual(ty, NF.Type) ? EB.muContext(ctx) : ctx),\n\t\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\t\tconst ast: EB.AST = yield* EB.infer.gen(src);\n\t\t\t\t\t\t\t\tconst [tm, inferred, us]: EB.AST = yield* EB.Icit.insert.gen(ast);\n\t\t\t\t\t\t\t\tyield* V2.tell(\"constraint\", { type: \"assign\", left: inferred, right: ty, lvl: ctx.env.length });\n\t\t\t\t\t\t\t\treturn [tm, us] satisfies Result;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\tconst [tm, us] = yield* V2.pure(result);\n\t\t\t//yield* V2.tell(\"type\", { term: tm, nf: type, modalities: {} as any });\n\n\t\t\treturn [tm, us];\n\t\t}),\n\t);\n\nconst checkRow = (row: Src.Row, ty: NF.Value, lvl: number): V2.Elaboration<[EB.Row, Q.Usages]> =>\n\tEB.Rows.inSigmaContext(\n\t\trow,\n\t\tR.fold(\n\t\t\trow,\n\t\t\t(val, lbl, acc) =>\n\t\t\t\tV2.Do(function* () {\n\t\t\t\t\tconst ctx = yield* V2.ask();\n\t\t\t\t\tconst [tm, us] = yield* Check.val.gen(val, ty);\n\t\t\t\t\tconst sigma = ctx.sigma[lbl];\n\t\t\t\t\tif (!sigma) {\n\t\t\t\t\t\tthrow new Error(\"Elaborating Row Extension: Label not found\");\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nf = NF.evaluate(ctx, tm);\n\t\t\t\t\tyield* V2.tell(\"constraint\", [\n\t\t\t\t\t\t{ type: \"assign\", left: nf, right: sigma.nf, lvl: ctx.env.length },\n\t\t\t\t\t\t{ type: \"assign\", left: ty, right: sigma.ann, lvl: ctx.env.length },\n\t\t\t\t\t]);\n\t\t\t\t\tconst [r, usages]: [EB.Row, Q.Usages] = yield acc;\n\n\t\t\t\t\treturn [{ type: \"extension\", label: lbl, value: tm, row: r }, Q.add(us, usages)] satisfies [EB.Row, Q.Usages];\n\t\t\t\t}),\n\t\t\t({ value }) => {\n\t\t\t\tthrow new Error(\"Not implemented yet: Cannot have row var in a map value\");\n\t\t\t},\n\t\t\tV2.of<[EB.Row, Q.Usages]>([{ type: \"empty\" }, Q.noUsage(lvl)]),\n\t\t),\n\t);\n\nconst traverseRow = (r1: Src.Row, r2: NF.Row, us: Q.Usages, bindings: Record<string, EB.Sigma>): V2.Elaboration<[EB.Row, Q.Usages]> =>\n\tV2.Do(function* () {\n\t\tconst result = match([r1, r2])\n\t\t\t.with([{ type: \"empty\" }, { type: \"empty\" }], () => V2.lift([{ type: \"empty\" }, us] satisfies [EB.Row, Q.Usages]))\n\t\t\t.with([{ type: \"empty\" }, { type: \"variable\" }], () => V2.lift([{ type: \"empty\" }, us] satisfies [EB.Row, Q.Usages]))\n\t\t\t.with([{ type: \"empty\" }, { type: \"extension\" }], ([r, { label }]) => V2.fail<[EB.Row, Q.Usages]>(Err.MissingLabel(label, r)))\n\t\t\t.with([{ type: \"variable\" }, P._], () => V2.fail<[EB.Row, Q.Usages]>({ type: \"Impossible\", message: \"Cannot have row var in a struct value\" }))\n\n\t\t\t.with([{ type: \"extension\" }, { type: \"extension\" }], ([{ label, value, row }, r]) => {\n\t\t\t\tconst rewritten = R.rewrite(r, label);\n\t\t\t\tif (E.isLeft(rewritten)) {\n\t\t\t\t\treturn V2.fail<[EB.Row, Q.Usages]>(Err.MissingLabel(label, r));\n\t\t\t\t}\n\n\t\t\t\tif (rewritten.right.type !== \"extension\") {\n\t\t\t\t\treturn V2.fail<[EB.Row, Q.Usages]>({ type: \"Impossible\", message: \"Rewritting a row extension should result in another row extension\" });\n\t\t\t\t}\n\n\t\t\t\tconst { value: rv, row: rr } = rewritten.right;\n\n\t\t\t\treturn V2.local(\n\t\t\t\t\tctx => set(ctx, `sigma.${label}.ann`, rv),\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst [tm, tus] = yield* Check.val.gen(value, rv);\n\t\t\t\t\t\tconst sigma = bindings[label];\n\t\t\t\t\t\tif (!sigma) {\n\t\t\t\t\t\t\tthrow new Error(\"Elaborating Row Extension: Label not found\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst ctx = yield* V2.ask();\n\t\t\t\t\t\tconst nf = NF.evaluate(ctx, tm);\n\t\t\t\t\t\tyield* V2.tell(\"constraint\", [\n\t\t\t\t\t\t\t{ type: \"assign\", left: nf, right: sigma.nf, lvl: ctx.env.length },\n\t\t\t\t\t\t\t// NOTE: Since in this case, we already know the type, we can remove the sigma check.\n\t\t\t\t\t\t\t// This also prevents emitting constraints of lambdas without inserted implicits against implicit pi types\n\t\t\t\t\t\t\t// QUESTION: Can we simplify the bindings extraction?\n\t\t\t\t\t\t\t//{ type: \"assign\", left: rv, right: sigma.ann, lvl: ctx.env.length }\n\t\t\t\t\t\t]);\n\n\t\t\t\t\t\tconst [rt, rus] = yield* Check.row.traverse.gen(row as Src.Row, rr, us, bindings);\n\t\t\t\t\t\tconst q = Q.add(tus, rus);\n\t\t\t\t\t\tconst xtension = EB.Constructors.Extension(label, tm, rt);\n\t\t\t\t\t\treturn [xtension, q] satisfies [EB.Row, Q.Usages];\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t})\n\t\t\t.with([{ type: \"extension\" }, P._], ([{ label }, r]) => V2.fail<[EB.Row, Q.Usages]>(Err.MissingLabel(label, r)))\n\t\t\t.otherwise(r => {\n\t\t\t\tthrow new Error(\"Unknown row action\");\n\t\t\t});\n\n\t\treturn yield* result;\n\t});\n\nexport const Check = {\n\tval: check,\n\trow: checkRow,\n};\ncheck.gen = F.flow(check, V2.pure);\ncheckRow.gen = F.flow(checkRow, V2.pure);\ncheckRow.traverse = traverseRow;\ntraverseRow.gen = F.flow(traverseRow, V2.pure);\n"],"mappings":"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","names":["tm","ctx","us","_","match"]}