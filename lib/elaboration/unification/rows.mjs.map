{"version":3,"sources":["../../../src/elaboration/unification/rows.ts"],"sourcesContent":["import { match, P } from \"ts-pattern\";\nimport _ from \"lodash\";\n\nimport * as F from \"fp-ts/lib/function\";\nimport * as A from \"fp-ts/Array\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as Sub from \"./substitution\";\nimport { Subst } from \"./substitution\";\n\nimport * as Err from \"@yap/elaboration/shared/errors\";\nimport * as R from \"@yap/shared/rows\";\n\nimport { number } from \"fp-ts\";\nimport { bind } from \".\";\n\nimport * as U from \"@yap/elaboration/unification\";\n\nlet count = 0;\nexport const unify = (r1: NF.Row, r2: NF.Row, s: Subst): V2.Elaboration<Subst> =>\n\tV2.track(\n\t\t{ tag: \"unify\", type: \"row\", rows: [r1, r2], metadata: { action: \"unification\" } },\n\t\tV2.Do(function* () {\n\t\t\t// count++;\n\t\t\t// console.log(\"Unify rows:\", count);\n\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\tconst lvl = ctx.env.length;\n\t\t\tconst subst = match([r1, r2])\n\t\t\t\t.with([{ type: \"empty\" }, { type: \"empty\" }], () => V2.of(s))\n\t\t\t\t.with(\n\t\t\t\t\t[{ type: \"variable\" }, { type: \"variable\" }],\n\t\t\t\t\t([{ variable: v1 }, { variable: v2 }]) => _.isEqual(v1, v2),\n\t\t\t\t\t() => V2.of(s),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[{ type: \"variable\", variable: { type: \"Meta\" } }, P._],\n\t\t\t\t\t([{ variable }]) => !!s[variable.val],\n\t\t\t\t\t([v, r]) => {\n\t\t\t\t\t\tconst nf = s[v.variable.val];\n\n\t\t\t\t\t\tif (nf.type !== \"Row\") {\n\t\t\t\t\t\t\tthrow new Error(\"Expected row\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn unify(nf.row, r, s);\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[P._, { type: \"variable\", variable: { type: \"Meta\" } }],\n\t\t\t\t\t([P_, { variable }]) => !!s[variable.val],\n\t\t\t\t\t([r, v]) => {\n\t\t\t\t\t\tconst nf = s[v.variable.val];\n\n\t\t\t\t\t\tif (nf.type !== \"Row\") {\n\t\t\t\t\t\t\tthrow new Error(\"Expected row\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn unify(r, nf.row, s);\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\t.with([{ type: \"variable\", variable: { type: \"Meta\" } }, P._], ([{ variable }, r]) => V2.of(bind(ctx, variable, NF.Constructors.Row(r))))\n\t\t\t\t.with([P._, { type: \"variable\", variable: { type: \"Meta\" } }], ([r, { variable }]) => V2.of(bind(ctx, variable, NF.Constructors.Row(r))))\n\n\t\t\t\t.with([{ type: \"extension\" }, P._], ([{ label, value, row }, r]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t// console.log(\"\\nUnify rows rewrites\", count);\n\t\t\t\t\t\t// const print = R.display<NF.Value, NF.Variable>({ term: v => NF.display(v, ctx.zonker), var: v => NF.display({ type: \"Var\", variable: v }, ctx.zonker) });\n\t\t\t\t\t\t// console.log(\"LHS:\", print(r1));\n\t\t\t\t\t\t// console.log(\"RHS:\", print(r2));\n\t\t\t\t\t\t// console.log(\"Current substitution:\\n\", Sub.display(s));\n\n\t\t\t\t\t\t// const intersection = A.intersection(number.Eq)(tail(row), Object.keys(s).map(Number));\n\n\t\t\t\t\t\t// if (intersection.length !== 0) {\n\t\t\t\t\t\t// \tthrow new Error(\"Circular row type\");\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tconst [rewritten, o1] = yield* V2.pure(rewrite(r, label, s));\n\t\t\t\t\t\tif (rewritten.type !== \"extension\") {\n\t\t\t\t\t\t\treturn yield* V2.fail<Subst>(Err.Impossible(\"Expected extension\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst o2 = yield* U.unify.gen(value, rewritten.value, lvl, Sub.compose(o1, s));\n\t\t\t\t\t\tconst o3 = yield* unify.gen(row, rewritten.row, o2);\n\n\t\t\t\t\t\treturn F.pipe(o3, Sub.compose(o2), Sub.compose(o1));\n\t\t\t\t\t}),\n\t\t\t\t)\n\n\t\t\t\t.with([{ type: \"empty\" }, { type: \"extension\" }], ([r, { label }]) => V2.Do<Subst, unknown>(() => V2.fail(Err.MissingLabel(label, r))))\n\t\t\t\t.with([{ type: \"extension\" }, { type: \"empty\" }], ([{ label }, r]) => V2.Do<Subst, unknown>(() => V2.fail(Err.MissingLabel(label, r))))\n\n\t\t\t\t.otherwise(r => {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unification: Row unification is described in Daan Leijen's paper 'Extensible records with scoped labels'.\" +\n\t\t\t\t\t\t\tJSON.stringify(r) +\n\t\t\t\t\t\t\t\"\\n\\nCall V2.fail()?\",\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\treturn yield* V2.pure(subst);\n\t\t}),\n\t);\nunify.gen = (r1: NF.Row, r2: NF.Row, s: Subst) => V2.pure(unify(r1, r2, s));\n\nconst tail = (row: NF.Row): number[] =>\n\tmatch(row)\n\t\t.with({ type: \"empty\" }, () => [])\n\t\t.with({ type: \"extension\" }, ({ row }) => tail(row))\n\t\t.with({ type: \"variable\" }, ({ variable }) =>\n\t\t\tmatch(variable)\n\t\t\t\t.with({ type: \"Meta\" }, ({ val }) => [val])\n\t\t\t\t.otherwise(() => []),\n\t\t)\n\t\t.exhaustive();\n\n// TODO: Use `rewrite` from `rows.ts`\nconst rewrite = (r: NF.Row, label: string, s: Subst): V2.Elaboration<[NF.Row, Subst]> =>\n\tV2.Do(function* () {\n\t\tconst ctx = yield* V2.ask();\n\t\tconst lvl = ctx.env.length;\n\t\tconst res = match(r)\n\t\t\t.with({ type: \"empty\" }, (): V2.Elaboration<[NF.Row, Subst]> => V2.Do(() => V2.fail(Err.MissingLabel(label, r))))\n\t\t\t.with(\n\t\t\t\t{ type: \"extension\" },\n\t\t\t\t({ label: l }) => label === l,\n\t\t\t\t({ label: l, value, row }) => V2.of<[NF.Row, Subst]>([R.Constructors.Extension(l, value, row), Sub.empty]),\n\t\t\t)\n\t\t\t.with(\n\t\t\t\t{ type: \"extension\" },\n\t\t\t\t({ label: lbl, value: val, row }): V2.Elaboration<[NF.Row, Subst]> =>\n\t\t\t\t\tV2.Do<[NF.Row, Subst], [NF.Row, Subst]>(function* () {\n\t\t\t\t\t\tconst [rewritten, sub] = yield rewrite(row, label, s);\n\n\t\t\t\t\t\tconst res = yield match(rewritten)\n\t\t\t\t\t\t\t.with({ type: \"extension\" }, ({ label: l, value: v, row: r }) =>\n\t\t\t\t\t\t\t\tV2.of<[NF.Row, Subst]>([R.Constructors.Extension(l, v, R.Constructors.Extension(lbl, val, r)), sub]),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.otherwise(() =>\n\t\t\t\t\t\t\t\tV2.Do(() =>\n\t\t\t\t\t\t\t\t\tV2.fail(\n\t\t\t\t\t\t\t\t\t\tErr.Impossible(\"Expected extension: \" + R.display<NF.Value, NF.Variable>({ term: v => NF.display(v, ctx), var: v => JSON.stringify(v) })),\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}),\n\t\t\t)\n\t\t\t.with(\n\t\t\t\t{ type: \"variable\" },\n\t\t\t\t({ variable }): V2.Elaboration<[NF.Row, Subst]> =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tif (variable.type !== \"Meta\") {\n\t\t\t\t\t\t\treturn yield* V2.fail<[NF.Row, Subst]>(Err.Impossible(\"Expected meta variable\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this meta variable is already solved in the current substitution, chase it first\n\t\t\t\t\t\tconst solved = s[variable.val];\n\t\t\t\t\t\tif (solved) {\n\t\t\t\t\t\t\tif (solved.type !== \"Row\") {\n\t\t\t\t\t\t\t\tthrow new Error(\"Expected row\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn yield* V2.pure(rewrite(solved.row, label, s));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst kvar = NF.Constructors.Var(yield* EB.freshMeta(lvl, NF.Type));\n\t\t\t\t\t\tconst tvar = NF.Constructors.Var(yield* EB.freshMeta(lvl, kvar));\n\t\t\t\t\t\tconst rvar: NF.Row = R.Constructors.Variable(yield* EB.freshMeta(lvl, NF.Row));\n\t\t\t\t\t\tconst rf = R.Constructors.Extension(label, tvar, rvar);\n\t\t\t\t\t\tconst sub = Sub.of(variable.val, NF.Constructors.Row(rf));\n\t\t\t\t\t\treturn [rf, sub] satisfies [NF.Row, Subst];\n\t\t\t\t\t}),\n\t\t\t)\n\t\t\t.exhaustive();\n\n\t\treturn yield* V2.pure(res);\n\t});\n"],"mappings":"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","names":["row","res","r"]}