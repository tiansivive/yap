{"version":3,"sources":["../../../src/elaboration/unification/unification.ts"],"sourcesContent":["import { match, P } from \"ts-pattern\";\nimport _ from \"lodash\";\n\nimport * as O from \"fp-ts/Option\";\nimport * as F from \"fp-ts/function\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as Sub from \"./substitution\";\nimport { Subst } from \"./substitution\";\n\nimport * as Err from \"@yap/elaboration/shared/errors\";\nimport * as R from \"@yap/shared/rows\";\n\nimport { update } from \"@yap/utils\";\n\nimport * as Row from \"@yap/elaboration/unification/rows\";\n\nexport const unify = (left: NF.Value, right: NF.Value, lvl: number, subst: Subst): V2.Elaboration<Subst> => {\n\tif (left.type === \"Neutral\") {\n\t\treturn unify(left.value, right, lvl, subst);\n\t}\n\n\tif (right.type === \"Neutral\") {\n\t\treturn unify(left, right.value, lvl, subst);\n\t}\n\n\treturn V2.track(\n\t\t{ tag: \"unify\", type: \"nf\", vals: [left, right], metadata: { action: \"unification\" } },\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst unifier = match([left, right])\n\t\t\t\t.with([NF.Patterns.Flex, NF.Patterns.Flex], ([meta1, meta2]) =>\n\t\t\t\t\tV2.Do<Subst, Subst>(function* () {\n\t\t\t\t\t\tconst s = Sub.compose(bind(ctx, meta1.variable, meta2), subst);\n\n\t\t\t\t\t\tconst ann1 = ctx.metas[meta1.variable.val].ann;\n\t\t\t\t\t\tconst ann2 = ctx.metas[meta2.variable.val].ann;\n\t\t\t\t\t\tconst s1 = yield* unify.gen(ann1, ann2, lvl, s);\n\t\t\t\t\t\treturn s1;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[NF.Patterns.Flex, P._],\n\t\t\t\t\t([{ variable }]) => !!subst[variable.val],\n\t\t\t\t\t([meta, v]) => unify(subst[meta.variable.val], v, lvl, subst),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[P._, NF.Patterns.Flex],\n\t\t\t\t\t([v, { variable }]) => !!subst[variable.val],\n\t\t\t\t\t([v, meta]) => unify(v, subst[meta.variable.val], lvl, subst),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.Flex, P._], ([meta, v]) => V2.of(Sub.compose(bind(ctx, meta.variable, v), subst)))\n\t\t\t\t.with([P._, NF.Patterns.Flex], ([v, meta]) => V2.of(Sub.compose(bind(ctx, meta.variable, v), subst)))\n\t\t\t\t.with([NF.Patterns.Lit, NF.Patterns.Lit], ([lit1, lit2]) =>\n\t\t\t\t\tV2.Do<Subst, Subst>(function* () {\n\t\t\t\t\t\tif (!_.isEqual(lit1.value, lit2.value)) {\n\t\t\t\t\t\t\treturn yield* V2.fail(Err.UnificationFailure(lit1, lit2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn subst;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.Modal, P._], ([{ value }, val]) => unify(value, val, lvl, subst))\n\t\t\t\t.with([P._, NF.Patterns.Modal], ([val, { value }]) => unify(val, value, lvl, subst))\n\t\t\t\t.with(\n\t\t\t\t\t[NF.Patterns.Lambda, NF.Patterns.Lambda],\n\t\t\t\t\t([lam1, lam2]) => lam1.binder.icit === lam2.binder.icit,\n\t\t\t\t\t([lam1, lam2]) =>\n\t\t\t\t\t\tV2.Do<Subst, Subst>(function* () {\n\t\t\t\t\t\t\tconst body1 = NF.apply(lam1.binder, lam1.closure, NF.Constructors.Rigid(lvl));\n\t\t\t\t\t\t\tconst body2 = NF.apply(lam2.binder, lam2.closure, NF.Constructors.Rigid(lvl));\n\t\t\t\t\t\t\treturn yield unify(body1, body2, lvl + 1, subst);\n\t\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[NF.Patterns.Pi, NF.Patterns.Pi],\n\t\t\t\t\t([pi1, pi2]) => pi1.binder.icit === pi2.binder.icit,\n\t\t\t\t\t([pi1, pi2]) =>\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tconst sub = yield* V2.pure(unify(pi1.binder.annotation, pi2.binder.annotation, lvl, subst));\n\t\t\t\t\t\t\tconst composed = Sub.compose(sub, subst);\n\t\t\t\t\t\t\tconst body1 = NF.apply(pi1.binder, pi1.closure, NF.Constructors.Rigid(lvl));\n\t\t\t\t\t\t\tconst body2 = NF.apply(pi2.binder, pi2.closure, NF.Constructors.Rigid(lvl));\n\t\t\t\t\t\t\treturn yield* V2.pure(unify(body1, body2, lvl + 1, composed));\n\t\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.Mu, NF.Patterns.Mu], ([mu1, mu2]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst sub = yield* V2.pure(unify(mu1.binder.annotation, mu2.binder.annotation, lvl, subst));\n\t\t\t\t\t\tconst composed = Sub.compose(sub, subst);\n\t\t\t\t\t\tconst body1 = NF.apply(mu1.binder, mu1.closure, NF.Constructors.Rigid(lvl));\n\t\t\t\t\t\tconst body2 = NF.apply(mu2.binder, mu2.closure, NF.Constructors.Rigid(lvl));\n\t\t\t\t\t\treturn yield* V2.pure(unify(body1, body2, lvl + 1, composed));\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([P._, NF.Patterns.Mu], ([v, mu]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst unfolded = NF.apply(mu.binder, mu.closure, mu);\n\t\t\t\t\t\treturn yield* V2.local(ctx => EB.unfoldMu(ctx, { type: \"Mu\", variable: mu.binder.variable }, mu), unify(v, unfolded, lvl + 1, subst));\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.Mu, P._], ([mu, v]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst unfolded = NF.apply(mu.binder, mu.closure, mu);\n\t\t\t\t\t\treturn yield* V2.local(ctx => EB.unfoldMu(ctx, { type: \"Mu\", variable: mu.binder.variable }, mu), unify(unfolded, v, lvl + 1, subst));\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.Rigid, NF.Patterns.Rigid], ([rigid1, rigid2]) =>\n\t\t\t\t\tV2.Do<Subst, Subst>(function* () {\n\t\t\t\t\t\tif (!_.isEqual(rigid1.variable, rigid2.variable)) {\n\t\t\t\t\t\t\treturn yield* V2.fail(Err.RigidVariableMismatch(rigid1, rigid2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn subst;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[NF.Patterns.Schema, NF.Patterns.Schema],\n\t\t\t\t\t[NF.Patterns.Struct, NF.Patterns.Struct],\n\t\t\t\t\t[NF.Patterns.Variant, NF.Patterns.Variant],\n\t\t\t\t\t([left, right]) => {\n\t\t\t\t\t\treturn unify(left.arg, right.arg, lvl, subst);\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.Indexed, NF.Patterns.Indexed], ([left, right]) =>\n\t\t\t\t\tV2.Do<Subst, Subst>(function* () {\n\t\t\t\t\t\tconst o1 = yield unify(left.func.func.arg, right.func.func.arg, lvl, subst);\n\t\t\t\t\t\tconst o2 = yield unify(left.func.arg, right.func.arg, lvl, o1);\n\t\t\t\t\t\tconst o3 = yield unify(left.arg, right.arg, lvl, o2);\n\t\t\t\t\t\treturn o3;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.Recursive, NF.Patterns.Recursive], ([left, right]) =>\n\t\t\t\t\tV2.Do<Subst, Subst>(function* () {\n\t\t\t\t\t\tconst o1 = yield unify(left.func, right.func, lvl, subst);\n\t\t\t\t\t\tconst o2 = yield unify(left.arg, right.arg, lvl, o1);\n\t\t\t\t\t\treturn o2;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.App, NF.Patterns.App], ([left, right]) =>\n\t\t\t\t\tV2.Do<Subst, Subst>(function* () {\n\t\t\t\t\t\tconst unfoldedL = unfoldMu(left);\n\t\t\t\t\t\tconst unfoldedR = unfoldMu(right);\n\n\t\t\t\t\t\t// NOTE: Using reference equality to check if unfolding made a change. Unfolding returns the same object if no unfolding was done.\n\t\t\t\t\t\tif (O.isNone(unfoldedL) && O.isNone(unfoldedR)) {\n\t\t\t\t\t\t\tconst o1 = yield unify(left.func, right.func, lvl, subst);\n\t\t\t\t\t\t\tconst o2 = yield unify(left.arg, right.arg, lvl, o1);\n\t\t\t\t\t\t\treturn o2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst sub = yield unify(\n\t\t\t\t\t\t\tF.pipe(\n\t\t\t\t\t\t\t\tunfoldedL,\n\t\t\t\t\t\t\t\tO.getOrElse<NF.Value>(() => left),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tF.pipe(\n\t\t\t\t\t\t\t\tunfoldedR,\n\t\t\t\t\t\t\t\tO.getOrElse<NF.Value>(() => right),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tlvl,\n\t\t\t\t\t\t\tsubst,\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn sub;\n\t\t\t\t\t\t// \t.with(\n\t\t\t\t\t\t// \t\t[NF.Patterns.Mu, P._],\n\t\t\t\t\t\t// \t\t([, v]) => v.type !== \"Abs\" || v.binder.type !== \"Mu\",\n\t\t\t\t\t\t// \t\t([mu, v]) => {\n\t\t\t\t\t\t// \t\t\tconst unfolded = NF.apply(mu.binder, mu.closure, mu);\n\t\t\t\t\t\t// \t\t\tconst applied = NF.reduce(unfolded, left.arg, \"Explicit\");\n\t\t\t\t\t\t// \t\t\treturn unify(applied, right, lvl, subst);\n\t\t\t\t\t\t// \t\t},\n\t\t\t\t\t\t// \t)\n\t\t\t\t\t\t// \t.with(\n\t\t\t\t\t\t// \t\t[P._, NF.Patterns.Mu],\n\t\t\t\t\t\t// \t\t([v]) => v.type !== \"Abs\" || v.binder.type !== \"Mu\",\n\t\t\t\t\t\t// \t\t([v, mu]) => {\n\t\t\t\t\t\t// \t\t\tconst unfolded = NF.apply(mu.binder, mu.closure, mu);\n\t\t\t\t\t\t// \t\t\tconst applied = NF.reduce(unfolded, right.arg, \"Explicit\");\n\t\t\t\t\t\t// \t\t\treturn unify(left, applied, lvl, subst);\n\t\t\t\t\t\t// \t\t},\n\t\t\t\t\t\t// \t)\n\t\t\t\t\t\t// \t.otherwise(() =>\n\t\t\t\t\t\t// \t\tV2.Do(function* () {\n\t\t\t\t\t\t// \t\t\tconst o1 = yield* V2.pure(unify(left.func, right.func, lvl, subst));\n\t\t\t\t\t\t// \t\t\tconst o2 = yield* V2.pure(unify(left.arg, right.arg, lvl, o1));\n\t\t\t\t\t\t// \t\t\treturn Sub.compose(o2, o1);\n\t\t\t\t\t\t// \t\t}),\n\t\t\t\t\t\t// \t);\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.App, P._], ([app, v]) => {\n\t\t\t\t\tconst unfolded = unfoldMu(app);\n\t\t\t\t\treturn unify(\n\t\t\t\t\t\tF.pipe(\n\t\t\t\t\t\t\tunfolded,\n\t\t\t\t\t\t\tO.getOrElse<NF.Value>(() => app),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tv,\n\t\t\t\t\t\tlvl,\n\t\t\t\t\t\tsubst,\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t\t.with([P._, NF.Patterns.App], ([v, app]) => {\n\t\t\t\t\tconst unfolded = unfoldMu(app);\n\t\t\t\t\treturn unify(\n\t\t\t\t\t\tv,\n\t\t\t\t\t\tF.pipe(\n\t\t\t\t\t\t\tunfolded,\n\t\t\t\t\t\t\tO.getOrElse<NF.Value>(() => app),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tlvl,\n\t\t\t\t\t\tsubst,\n\t\t\t\t\t);\n\t\t\t\t})\n\n\t\t\t\t.with([NF.Patterns.Row, NF.Patterns.Row], ([{ row: r1 }, { row: r2 }]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst sub = yield* Row.unify.gen(r1, r2, subst);\n\t\t\t\t\t\treturn Sub.compose(sub, subst);\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t// NOTE: Foreign variables are not strictly Î±-equivalent, but they get shadowed, so we can assume this is somewhat sound\n\t\t\t\t\t// ideally we'll want fully qualified names, but that's not yet implemented\n\t\t\t\t\t// SOLUTION: fully qualified names\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: \"Var\", variable: { type: \"Foreign\" } },\n\t\t\t\t\t\t{ type: \"Var\", variable: { type: \"Foreign\" } },\n\t\t\t\t\t],\n\t\t\t\t\t([ffi1, ffi2]) => ffi1.variable.name === ffi2.variable.name,\n\t\t\t\t\t() => V2.of(subst),\n\t\t\t\t)\n\t\t\t\t.otherwise(ts => {\n\t\t\t\t\treturn V2.Do<Subst, unknown>(() => V2.fail(Err.TypeMismatch(left, right)));\n\t\t\t\t});\n\n\t\t\tconst sub = yield* V2.pure(unifier);\n\t\t\treturn Sub.compose(sub, subst);\n\t\t}),\n\t);\n};\n\nunify.gen = (left: NF.Value, right: NF.Value, lvl: number, subst: Subst) => V2.pure(unify(left, right, lvl, subst));\n\nconst unfoldMu = (app: Extract<NF.Value, { type: \"App\" }>): O.Option<NF.Value> => {\n\tconst { func, arg, icit } = app;\n\treturn (\n\t\tmatch(func)\n\t\t\t.with({ type: \"App\" }, fn =>\n\t\t\t\tF.pipe(\n\t\t\t\t\tunfoldMu(fn),\n\t\t\t\t\tO.map(f => NF.reduce(f, arg, icit)),\n\t\t\t\t),\n\t\t\t)\n\t\t\t// \tconst unfolded = unfoldMu(fn);\n\t\t\t// \treturn O.Functor.map(unfolded, f => NF.reduce(f, arg, icit));\n\t\t\t// \t//return NF.reduce(unfolded, arg, icit);\n\t\t\t// })\n\t\t\t.with({ type: \"Abs\", binder: { type: \"Mu\" } }, mu => {\n\t\t\t\tconst body = NF.apply(mu.binder, mu.closure, mu);\n\t\t\t\tconst unfolded = NF.reduce(body, arg, icit);\n\t\t\t\treturn O.some(unfolded);\n\t\t\t})\n\t\t\t.otherwise(() => O.none)\n\t);\n};\n\ntype Meta = Extract<EB.Variable, { type: \"Meta\" }>;\nexport const bind = (ctx: EB.Context, v: Meta, ty: NF.Value): Subst => {\n\tif (ty.type === \"Var\" && _.isEqual(ty.variable, v)) {\n\t\treturn Sub.empty;\n\t}\n\n\tif (!occursCheck(ctx, v, ty)) {\n\t\tif (ty.type === \"Abs\") {\n\t\t\t// NOTE: Pruning the environment to the level of the variable\n\t\t\t// Because closures capture the environment during elaboration, we ensure only the necessary variables are captured here\n\t\t\t// when unifying with a meta generated at a certain, lower level.\n\t\t\t// The other way around is not a problem, since the closure env already contains all the strictly necessary variables.\n\n\t\t\t// This is not an ideal solution, as it demands that metas contain the level at which they were generated.\n\t\t\t// An alternative would be higher-order unification, which is more complex to implement, but more powerful.\n\t\t\t//const _ty = { ...ty, closure: { ...ty.closure, env: ty.closure.env.slice(-v.lvl) } };\n\t\t\tconst _ty = update(ty, \"closure.ctx\", ctx => EB.prune(ctx, v.lvl));\n\t\t\treturn Sub.of(v.val, _ty);\n\t\t}\n\t\treturn Sub.of(v.val, ty);\n\t}\n\n\t// solution is a mu type\n\tthrow new Error(\"Unification: Occurs check failed. Need to implement mu type\");\n};\n\nconst occursCheck = (ctx: EB.Context, v: Meta, ty: NF.Value): boolean => {\n\treturn (\n\t\tmatch(ty)\n\t\t\t.with(NF.Patterns.Var, ({ variable }) => _.isEqual(variable, v))\n\t\t\t.with({ type: \"Neutral\" }, ({ value }) => occursCheck(ctx, v, value))\n\t\t\t//occursCheck(ctx, v, NF.apply(binder, closure, NF.Constructors.Rigid(ctx.env.length))))\n\t\t\t.with(NF.Patterns.Lambda, ({ binder, closure }) => occursInTerm(closure.ctx, v, closure.term))\n\t\t\t//occursCheck(ctx, v, NF.apply(binder, closure, NF.Constructors.Rigid(ctx.env.length))))\n\t\t\t.with(NF.Patterns.Pi, ({ binder, closure }) => occursInTerm(closure.ctx, v, closure.term))\n\t\t\t.with(NF.Patterns.App, ({ func, arg }) => occursCheck(ctx, v, func) || occursCheck(ctx, v, arg))\n\t\t\t.with(NF.Patterns.Modal, ({ value, modalities }) => occursCheck(ctx, v, value) || occursCheck(ctx, v, modalities.liquid))\n\n\t\t\t.with(NF.Patterns.Row, ({ row }) =>\n\t\t\t\tR.fold(\n\t\t\t\t\trow,\n\t\t\t\t\t(nf, _, acc) => acc || occursCheck(ctx, v, nf),\n\t\t\t\t\trv => rv.type === \"Meta\" && _.isEqual(rv, v),\n\t\t\t\t\tfalse,\n\t\t\t\t),\n\t\t\t)\n\t\t\t.otherwise(() => false)\n\t);\n};\n\nconst occursInTerm = (ctx: EB.Context, v: Meta, tm: EB.Term): boolean => {\n\treturn (\n\t\tmatch(tm)\n\t\t\t.with({ type: \"Var\", variable: { type: \"Meta\" } }, ({ variable }) => {\n\t\t\t\tif (ctx.zonker[variable.val]) {\n\t\t\t\t\treturn occursCheck(ctx, v, ctx.zonker[variable.val]);\n\t\t\t\t}\n\t\t\t\treturn _.isEqual(variable, v);\n\t\t\t})\n\t\t\t.with({ type: \"Abs\" }, ({ binding, body }) => occursInTerm(ctx, v, binding.annotation) || occursInTerm(ctx, v, body))\n\t\t\t.with({ type: \"App\" }, ({ func, arg }) => occursInTerm(ctx, v, func) || occursInTerm(ctx, v, arg))\n\t\t\t//.with({ type: \"Annotation\" }, ({ term, ann }) => occursInTerm(ctx, v, term) || occursInTerm(ctx, v, ann))\n\t\t\t.with({ type: \"Match\" }, ({ scrutinee, alternatives }) => occursInTerm(ctx, v, scrutinee) || alternatives.some(({ term }) => occursInTerm(ctx, v, term)))\n\t\t\t.with({ type: \"Block\" }, ({ return: ret, statements }) => occursInTerm(ctx, v, ret) || statements.some(s => occursInTerm(ctx, v, s.value)))\n\t\t\t.with({ type: \"Row\" }, ({ row }) =>\n\t\t\t\tR.fold(\n\t\t\t\t\trow,\n\t\t\t\t\t(nf, _, acc) => acc || occursInTerm(ctx, v, nf),\n\t\t\t\t\trv => {\n\t\t\t\t\t\tif (rv.type === \"Meta\" && ctx.zonker[rv.val]) {\n\t\t\t\t\t\t\treturn occursCheck(ctx, v, ctx.zonker[rv.val]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn _.isEqual(rv, v);\n\t\t\t\t\t},\n\t\t\t\t\tfalse,\n\t\t\t\t),\n\t\t\t)\n\t\t\t.with({ type: \"Proj\" }, ({ term }) => occursInTerm(ctx, v, term))\n\t\t\t.with({ type: \"Inj\" }, ({ value, term }) => occursInTerm(ctx, v, value) || occursInTerm(ctx, v, term))\n\t\t\t.with({ type: \"Lit\" }, () => false)\n\t\t\t.with({ type: \"Modal\" }, ({ term }) => occursInTerm(ctx, v, term))\n\t\t\t.otherwise(() => false)\n\t);\n};\n"],"mappings":"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","names":["sub","ctx","left","right","_"]}