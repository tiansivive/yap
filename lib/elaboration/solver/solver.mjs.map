{"version":3,"sources":["../../../src/elaboration/solver/solver.ts"],"sourcesContent":["import * as V2 from \"@yap/elaboration/shared/monad.v2\";\nimport * as EB from \"@yap/elaboration\";\nimport * as U from \"@yap/elaboration/unification\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport { match, P } from \"ts-pattern\";\nimport * as Sub from \"@yap/elaboration/unification/substitution\";\nimport { Subst } from \"@yap/elaboration/unification/substitution\";\n\nimport * as Err from \"@yap/elaboration/shared/errors\";\n\nimport * as F from \"fp-ts/lib/function\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\nimport { WithProvenance } from \"../shared/provenance\";\n\nexport type Constraint =\n\t| { type: \"assign\"; left: NF.Value; right: NF.Value; lvl: number }\n\t| { type: \"usage\"; computed: Q.Multiplicity; expected: Q.Multiplicity };\n//| { type: \"resolve\"; meta: Extract<EB.Variable, { type: \"Meta\" }>; annotation: NF.Value };\n// | { type: \"sigma\"; lvl: number; dict: Record<string, NF.Value> }\n\ntype Ctaint = WithProvenance<Constraint>;\nexport const solve = (cs: Array<Ctaint>): V2.Elaboration<Subst> =>\n\tV2.Do(function* () {\n\t\tconst ctx = yield* V2.ask();\n\t\tconst solution = yield* V2.pure(_solve(cs, ctx, Sub.empty));\n\n\t\treturn solution;\n\t});\n\nconst _solve = (cs: Array<Ctaint>, _ctx: EB.Context, subst: Subst): V2.Elaboration<Subst> => {\n\tif (cs.length === 0) {\n\t\treturn V2.of(subst);\n\t}\n\n\tconst [c, ...rest] = cs;\n\n\treturn match(c)\n\t\t.with({ type: \"assign\" }, ({ left, right, lvl }) =>\n\t\t\tV2.Do<Subst, Subst>(function* () {\n\t\t\t\tconst sub = yield* V2.local(F.identity, V2.track(c.trace, U.unify(left, right, lvl, subst)));\n\t\t\t\tconst sol = yield _solve(rest, _ctx, sub);\n\t\t\t\treturn sol;\n\t\t\t}),\n\t\t)\n\t\t.with({ type: \"usage\" }, ({ expected, computed }) => {\n\t\t\treturn match([expected, computed])\n\t\t\t\t.with([\"One\", \"One\"], [\"Many\", P._], [\"Zero\", \"Zero\"], () => _solve(rest, _ctx, subst))\n\t\t\t\t.otherwise(() => V2.Do(() => V2.fail<Subst>(Err.MultiplicityMismatch(expected, computed))));\n\t\t})\n\t\t.otherwise(() => {\n\t\t\tthrow new Error(\"Solve: Not implemented yet\");\n\t\t});\n};\n"],"mappings":";AAAA,YAAY,QAAQ;AAEpB,YAAY,OAAO;AAEnB,SAAS,OAAO,SAAS;AACzB,YAAY,SAAS;AAGrB,YAAY,SAAS;AAErB,YAAY,OAAO;AAYZ,MAAM,QAAQ,CAAC,OACrB,GAAG,GAAG,aAAa;AAClB,QAAM,MAAM,OAAO,GAAG,IAAI;AAC1B,QAAM,WAAW,OAAO,GAAG,KAAK,OAAO,IAAI,KAAK,IAAI,KAAK,CAAC;AAE1D,SAAO;AACR,CAAC;AAEF,MAAM,SAAS,CAAC,IAAmB,MAAkB,UAAwC;AAC5F,MAAI,GAAG,WAAW,GAAG;AACpB,WAAO,GAAG,GAAG,KAAK;AAAA,EACnB;AAEA,QAAM,CAAC,GAAG,GAAG,IAAI,IAAI;AAErB,SAAO,MAAM,CAAC,EACZ;AAAA,IAAK,EAAE,MAAM,SAAS;AAAA,IAAG,CAAC,EAAE,MAAM,OAAO,IAAI,MAC7C,GAAG,GAAiB,aAAa;AAChC,YAAM,MAAM,OAAO,GAAG,MAAM,EAAE,UAAU,GAAG,MAAM,EAAE,OAAO,EAAE,MAAM,MAAM,OAAO,KAAK,KAAK,CAAC,CAAC;AAC3F,YAAM,MAAM,MAAM,OAAO,MAAM,MAAM,GAAG;AACxC,aAAO;AAAA,IACR,CAAC;AAAA,EACF,EACC,KAAK,EAAE,MAAM,QAAQ,GAAG,CAAC,EAAE,UAAU,SAAS,MAAM;AACpD,WAAO,MAAM,CAAC,UAAU,QAAQ,CAAC,EAC/B,KAAK,CAAC,OAAO,KAAK,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,QAAQ,MAAM,GAAG,MAAM,OAAO,MAAM,MAAM,KAAK,CAAC,EACrF,UAAU,MAAM,GAAG,GAAG,MAAM,GAAG,KAAY,IAAI,qBAAqB,UAAU,QAAQ,CAAC,CAAC,CAAC;AAAA,EAC5F,CAAC,EACA,UAAU,MAAM;AAChB,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC7C,CAAC;AACH;","names":[]}