{"version":3,"sources":["../../../src/elaboration/syntax/term.ts"],"sourcesContent":["import { Types, update } from \"@yap/utils\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\nimport * as NF from \"../normalization\";\nimport * as R from \"@yap/shared/rows\";\nimport * as Lit from \"@yap/shared/literals\";\nimport { Implicitness } from \"@yap/shared/implicitness\";\nimport { Literal } from \"@yap/shared/literals\";\n\nimport * as F from \"fp-ts/lib/function\";\nimport { Simplify } from \"type-fest\";\n\nimport * as Modal from \"@yap/verification/modalities/shared\";\nimport * as Pat from \"@yap/elaboration/inference/patterns\";\nimport { Struct } from \"../inference\";\n\nexport type Term = Types.Brand<typeof tag, Constructor & { id: number }>;\nconst tag: unique symbol = Symbol(\"Term\");\ntype Constructor =\n\t| { type: \"Lit\"; value: Literal }\n\t| { type: \"Var\"; variable: Variable }\n\t| { type: \"Abs\"; binding: Binding; body: Term }\n\t| { type: \"App\"; icit: Implicitness; func: Term; arg: Term }\n\t| { type: \"Row\"; row: Row }\n\t| { type: \"Proj\"; label: string; term: Term }\n\t| { type: \"Inj\"; label: string; value: Term; term: Term }\n\t| { type: \"Match\"; scrutinee: Term; alternatives: Array<Alternative> }\n\t| { type: \"Block\"; statements: Array<Statement>; return: Term }\n\t| { type: \"Modal\"; term: Term; modalities: Modal.Annotations };\n\nexport type Variable =\n\t| { type: \"Bound\"; index: number }\n\t| { type: \"Free\"; name: string }\n\t| { type: \"Foreign\"; name: string }\n\t| { type: \"Label\"; name: string }\n\t/**\n\t * @see Unification.bind for the reason why we need to store the level\n\t */\n\t| { type: \"Meta\"; val: number; lvl: number };\nexport type Meta = Extract<Variable, { type: \"Meta\" }>;\nexport type Row = R.Row<Term, Variable>;\n\nexport type Binding = (\n\t| { type: \"Let\"; variable: string; value: Term }\n\t| { type: \"Lambda\"; variable: string; icit: Implicitness }\n\t| { type: \"Mu\"; variable: string; source: string }\n\t| { type: \"Pi\"; variable: string; icit: Implicitness }\n) &\n\t// | { type: \"Sigma\"; variable: string; annotation: Term, multiplicity: Q.Multiplicity; }\n\t{ annotation: Term };\n\nexport type Alternative = { pattern: Pattern; term: Term; binders: Pat.Binder[] };\nexport type Pattern =\n\t| { type: \"Binder\"; value: string }\n\t| { type: \"Var\"; value: string; term: Term }\n\t| { type: \"Lit\"; value: Literal }\n\t| { type: \"Row\"; row: R.Row<Pattern, string> }\n\t| { type: \"Struct\"; row: R.Row<Pattern, string> }\n\t| { type: \"Variant\"; row: R.Row<Pattern, string> }\n\t| { type: \"List\"; patterns: Pattern[]; rest?: string }\n\t| { type: \"Wildcard\" };\n\nexport type Statement =\n\t| { type: \"Expression\"; value: Term }\n\t| { type: \"Let\"; variable: string; value: Term; annotation: NF.Value }\n\t| { type: \"Using\"; value: Term; annotation: NF.Value };\n\nexport const Bound = (index: number): Variable => ({ type: \"Bound\", index });\nexport const Free = (name: string): Variable => ({ type: \"Free\", name });\nexport const Meta = (val: number, lvl: number): Variable => ({ type: \"Meta\", val, lvl });\n\nlet currentId = 0;\nconst nextId = () => ++currentId;\nexport const mk = <K extends Constructor[\"type\"]>(ctor: Extract<Constructor, { type: K }>) => {\n\tconst r = Types.make(tag, { ...ctor, id: nextId() });\n\treturn r as Simplify<typeof r>;\n};\n\nexport const Constructors = {\n\tAbs: (binding: Binding, body: Term): Extract<Term, { type: \"Abs\" }> => mk({ type: \"Abs\", binding, body }),\n\tLambda: (variable: string, icit: Implicitness, body: Term, annotation: Term): Term =>\n\t\tmk({\n\t\t\ttype: \"Abs\",\n\t\t\tbinding: { type: \"Lambda\" as const, variable, icit, annotation },\n\t\t\tbody,\n\t\t}),\n\tPi: (variable: string, icit: Implicitness, annotation: Term, body: Term): Term =>\n\t\tmk({\n\t\t\ttype: \"Abs\",\n\t\t\tbinding: { type: \"Pi\" as const, variable, icit, annotation },\n\t\t\tbody,\n\t\t}),\n\tMu: (variable: string, source: string, annotation: Term, body: Term): Term =>\n\t\tmk({\n\t\t\ttype: \"Abs\",\n\t\t\tbinding: { type: \"Mu\", variable, source, annotation },\n\t\t\tbody,\n\t\t}),\n\tVar: (variable: Variable): Term =>\n\t\tmk({\n\t\t\ttype: \"Var\",\n\t\t\tvariable,\n\t\t}),\n\tVars: {\n\t\tBound: (index: number): Variable => ({ type: \"Bound\", index }),\n\t\tFree: (name: string): Variable => ({ type: \"Free\", name }),\n\t\tForeign: (name: string): Variable => ({ type: \"Foreign\", name }),\n\t\tLabel: (name: string): Variable => ({ type: \"Label\", name }),\n\t\tMeta: (val: number, lvl: number): Variable => ({ type: \"Meta\", val, lvl }),\n\t},\n\tApp: (icit: Implicitness, func: Term, arg: Term): Term =>\n\t\tmk({\n\t\t\ttype: \"App\",\n\t\t\ticit,\n\t\t\tfunc,\n\t\t\targ,\n\t\t}),\n\tLit: (value: Literal): Term =>\n\t\tmk({\n\t\t\ttype: \"Lit\",\n\t\t\tvalue,\n\t\t}),\n\t// Annotation: (term: Term, ann: Term): Term => ({ type: \"Annotation\", term, ann }),\n\n\tRow: (row: Row): Term => mk({ type: \"Row\", row }),\n\tExtension: (label: string, value: Term, row: Row): Row => ({ type: \"extension\", label, value, row }),\n\n\tStruct: (row: Row): Term => Constructors.App(\"Explicit\", Constructors.Lit(Lit.Atom(\"Struct\")), Constructors.Row(row)),\n\tSchema: (row: Row): Term => Constructors.App(\"Explicit\", Constructors.Lit(Lit.Atom(\"Schema\")), Constructors.Row(row)),\n\tVariant: (row: Row): Term => Constructors.App(\"Explicit\", Constructors.Lit(Lit.Atom(\"Variant\")), Constructors.Row(row)),\n\tProj: (label: string, term: Term): Term => mk({ type: \"Proj\", label, term }),\n\tInj: (label: string, value: Term, term: Term): Term => mk({ type: \"Inj\", label, value, term }),\n\n\tIndexed: (index: Term, term: Term, strategy?: Term): Term => {\n\t\tconst indexing = Constructors.App(\"Explicit\", Constructors.Var({ type: \"Foreign\", name: \"Indexed\" }), index);\n\t\tconst values = Constructors.App(\"Explicit\", indexing, term);\n\t\tconst strat = Constructors.App(\"Implicit\", values, strategy ? strategy : Constructors.Var({ type: \"Foreign\", name: \"defaultHashMap\" }));\n\t\treturn strat;\n\t},\n\n\tMatch: (scrutinee: Term, alternatives: Array<Alternative>): Term => mk({ type: \"Match\", scrutinee, alternatives }),\n\tAlternative: (pattern: Pattern, term: Term, binders: Pat.Binder[]): Alternative => ({ pattern, term, binders }),\n\n\tBlock: (statements: Array<Statement>, term: Term): Term => mk({ type: \"Block\", statements, return: term }),\n\n\tModal: (term: Term, modalities: Modal.Annotations): Term => mk({ type: \"Modal\", term, modalities }),\n\n\tPatterns: {\n\t\tBinder: (value: string): Pattern => ({ type: \"Binder\", value }),\n\t\tVar: (value: string, term: Term): Pattern => ({ type: \"Var\", value, term }),\n\t\tLit: (value: Literal): Pattern => ({ type: \"Lit\", value }),\n\t\tRow: (row: R.Row<Pattern, string>): Pattern => ({ type: \"Row\", row }),\n\t\tExtension: (label: string, value: Pattern, row: R.Row<Pattern, string>): R.Row<Pattern, string> => R.Constructors.Extension(label, value, row),\n\t\tStruct: (row: R.Row<Pattern, string>): Pattern => ({ type: \"Struct\", row }),\n\t\tVariant: (row: R.Row<Pattern, string>): Pattern => ({ type: \"Variant\", row }),\n\t\tWildcard: (): Pattern => ({ type: \"Wildcard\" }),\n\t\tList: (patterns: Pattern[], rest?: string): Pattern => ({ type: \"List\", patterns, rest }),\n\t},\n\tStmt: {\n\t\tLet: (variable: string, value: Term, annotation: NF.Value): Statement => ({\n\t\t\ttype: \"Let\",\n\t\t\tvariable,\n\t\t\tvalue,\n\t\t\tannotation,\n\t\t}),\n\t\tExpr: (value: Term): Statement => ({ type: \"Expression\", value }),\n\t},\n};\n\nexport const CtorPatterns = {\n\tVar: { type: \"Var\" },\n\tLit: { type: \"Lit\" },\n\tLambda: { type: \"Abs\", binding: { type: \"Lambda\" } },\n\tPi: { type: \"Abs\", binding: { type: \"Pi\" } },\n\tMu: { type: \"Abs\", binding: { type: \"Mu\" } },\n\tMatch: { type: \"Match\" },\n\tRow: { type: \"Row\" },\n\tProj: { type: \"Proj\" },\n\tInj: { type: \"Inj\" },\n\tAnnotation: { type: \"Annotation\" },\n\tVariant: { type: \"App\", func: { type: \"Lit\", value: { type: \"Atom\", value: \"Variant\" } }, arg: { type: \"Row\" } },\n\tSchema: { type: \"App\", func: { type: \"Lit\", value: { type: \"Atom\", value: \"Schema\" } }, arg: { type: \"Row\" } },\n\tStruct: { type: \"App\", func: { type: \"Lit\", value: { type: \"Atom\", value: \"Struct\" } }, arg: { type: \"Row\" } },\n} as const;\n"],"mappings":";AAAA,SAAS,aAAqB;AAI9B,YAAY,OAAO;AACnB,YAAY,SAAS;AAYrB,MAAM,MAAqB,OAAO,MAAM;AAkDjC,MAAM,QAAQ,CAAC,WAA6B,EAAE,MAAM,SAAS,MAAM;AACnE,MAAM,OAAO,CAAC,UAA4B,EAAE,MAAM,QAAQ,KAAK;AAC/D,MAAM,OAAO,CAAC,KAAa,SAA2B,EAAE,MAAM,QAAQ,KAAK,IAAI;AAEtF,IAAI,YAAY;AAChB,MAAM,SAAS,MAAM,EAAE;AAChB,MAAM,KAAK,CAAgC,SAA4C;AAC7F,QAAM,IAAI,MAAM,KAAK,KAAK,EAAE,GAAG,MAAM,IAAI,OAAO,EAAE,CAAC;AACnD,SAAO;AACR;AAEO,MAAM,eAAe;AAAA,EAC3B,KAAK,CAAC,SAAkB,SAA+C,GAAG,EAAE,MAAM,OAAO,SAAS,KAAK,CAAC;AAAA,EACxG,QAAQ,CAAC,UAAkB,MAAoB,MAAY,eAC1D,GAAG;AAAA,IACF,MAAM;AAAA,IACN,SAAS,EAAE,MAAM,UAAmB,UAAU,MAAM,WAAW;AAAA,IAC/D;AAAA,EACD,CAAC;AAAA,EACF,IAAI,CAAC,UAAkB,MAAoB,YAAkB,SAC5D,GAAG;AAAA,IACF,MAAM;AAAA,IACN,SAAS,EAAE,MAAM,MAAe,UAAU,MAAM,WAAW;AAAA,IAC3D;AAAA,EACD,CAAC;AAAA,EACF,IAAI,CAAC,UAAkB,QAAgB,YAAkB,SACxD,GAAG;AAAA,IACF,MAAM;AAAA,IACN,SAAS,EAAE,MAAM,MAAM,UAAU,QAAQ,WAAW;AAAA,IACpD;AAAA,EACD,CAAC;AAAA,EACF,KAAK,CAAC,aACL,GAAG;AAAA,IACF,MAAM;AAAA,IACN;AAAA,EACD,CAAC;AAAA,EACF,MAAM;AAAA,IACL,OAAO,CAAC,WAA6B,EAAE,MAAM,SAAS,MAAM;AAAA,IAC5D,MAAM,CAAC,UAA4B,EAAE,MAAM,QAAQ,KAAK;AAAA,IACxD,SAAS,CAAC,UAA4B,EAAE,MAAM,WAAW,KAAK;AAAA,IAC9D,OAAO,CAAC,UAA4B,EAAE,MAAM,SAAS,KAAK;AAAA,IAC1D,MAAM,CAAC,KAAa,SAA2B,EAAE,MAAM,QAAQ,KAAK,IAAI;AAAA,EACzE;AAAA,EACA,KAAK,CAAC,MAAoB,MAAY,QACrC,GAAG;AAAA,IACF,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,EACD,CAAC;AAAA,EACF,KAAK,CAAC,UACL,GAAG;AAAA,IACF,MAAM;AAAA,IACN;AAAA,EACD,CAAC;AAAA;AAAA,EAGF,KAAK,CAAC,QAAmB,GAAG,EAAE,MAAM,OAAO,IAAI,CAAC;AAAA,EAChD,WAAW,CAAC,OAAe,OAAa,SAAmB,EAAE,MAAM,aAAa,OAAO,OAAO,IAAI;AAAA,EAElG,QAAQ,CAAC,QAAmB,aAAa,IAAI,YAAY,aAAa,IAAI,IAAI,KAAK,QAAQ,CAAC,GAAG,aAAa,IAAI,GAAG,CAAC;AAAA,EACpH,QAAQ,CAAC,QAAmB,aAAa,IAAI,YAAY,aAAa,IAAI,IAAI,KAAK,QAAQ,CAAC,GAAG,aAAa,IAAI,GAAG,CAAC;AAAA,EACpH,SAAS,CAAC,QAAmB,aAAa,IAAI,YAAY,aAAa,IAAI,IAAI,KAAK,SAAS,CAAC,GAAG,aAAa,IAAI,GAAG,CAAC;AAAA,EACtH,MAAM,CAAC,OAAe,SAAqB,GAAG,EAAE,MAAM,QAAQ,OAAO,KAAK,CAAC;AAAA,EAC3E,KAAK,CAAC,OAAe,OAAa,SAAqB,GAAG,EAAE,MAAM,OAAO,OAAO,OAAO,KAAK,CAAC;AAAA,EAE7F,SAAS,CAAC,OAAa,MAAY,aAA0B;AAC5D,UAAM,WAAW,aAAa,IAAI,YAAY,aAAa,IAAI,EAAE,MAAM,WAAW,MAAM,UAAU,CAAC,GAAG,KAAK;AAC3G,UAAM,SAAS,aAAa,IAAI,YAAY,UAAU,IAAI;AAC1D,UAAM,QAAQ,aAAa,IAAI,YAAY,QAAQ,WAAW,WAAW,aAAa,IAAI,EAAE,MAAM,WAAW,MAAM,iBAAiB,CAAC,CAAC;AACtI,WAAO;AAAA,EACR;AAAA,EAEA,OAAO,CAAC,WAAiB,iBAA2C,GAAG,EAAE,MAAM,SAAS,WAAW,aAAa,CAAC;AAAA,EACjH,aAAa,CAAC,SAAkB,MAAY,aAAwC,EAAE,SAAS,MAAM,QAAQ;AAAA,EAE7G,OAAO,CAAC,YAA8B,SAAqB,GAAG,EAAE,MAAM,SAAS,YAAY,QAAQ,KAAK,CAAC;AAAA,EAEzG,OAAO,CAAC,MAAY,eAAwC,GAAG,EAAE,MAAM,SAAS,MAAM,WAAW,CAAC;AAAA,EAElG,UAAU;AAAA,IACT,QAAQ,CAAC,WAA4B,EAAE,MAAM,UAAU,MAAM;AAAA,IAC7D,KAAK,CAAC,OAAe,UAAyB,EAAE,MAAM,OAAO,OAAO,KAAK;AAAA,IACzE,KAAK,CAAC,WAA6B,EAAE,MAAM,OAAO,MAAM;AAAA,IACxD,KAAK,CAAC,SAA0C,EAAE,MAAM,OAAO,IAAI;AAAA,IACnE,WAAW,CAAC,OAAe,OAAgB,QAAwD,EAAE,aAAa,UAAU,OAAO,OAAO,GAAG;AAAA,IAC7I,QAAQ,CAAC,SAA0C,EAAE,MAAM,UAAU,IAAI;AAAA,IACzE,SAAS,CAAC,SAA0C,EAAE,MAAM,WAAW,IAAI;AAAA,IAC3E,UAAU,OAAgB,EAAE,MAAM,WAAW;AAAA,IAC7C,MAAM,CAAC,UAAqB,UAA4B,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACxF;AAAA,EACA,MAAM;AAAA,IACL,KAAK,CAAC,UAAkB,OAAa,gBAAqC;AAAA,MACzE,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAAA,IACA,MAAM,CAAC,WAA4B,EAAE,MAAM,cAAc,MAAM;AAAA,EAChE;AACD;AAEO,MAAM,eAAe;AAAA,EAC3B,KAAK,EAAE,MAAM,MAAM;AAAA,EACnB,KAAK,EAAE,MAAM,MAAM;AAAA,EACnB,QAAQ,EAAE,MAAM,OAAO,SAAS,EAAE,MAAM,SAAS,EAAE;AAAA,EACnD,IAAI,EAAE,MAAM,OAAO,SAAS,EAAE,MAAM,KAAK,EAAE;AAAA,EAC3C,IAAI,EAAE,MAAM,OAAO,SAAS,EAAE,MAAM,KAAK,EAAE;AAAA,EAC3C,OAAO,EAAE,MAAM,QAAQ;AAAA,EACvB,KAAK,EAAE,MAAM,MAAM;AAAA,EACnB,MAAM,EAAE,MAAM,OAAO;AAAA,EACrB,KAAK,EAAE,MAAM,MAAM;AAAA,EACnB,YAAY,EAAE,MAAM,aAAa;AAAA,EACjC,SAAS,EAAE,MAAM,OAAO,MAAM,EAAE,MAAM,OAAO,OAAO,EAAE,MAAM,QAAQ,OAAO,UAAU,EAAE,GAAG,KAAK,EAAE,MAAM,MAAM,EAAE;AAAA,EAC/G,QAAQ,EAAE,MAAM,OAAO,MAAM,EAAE,MAAM,OAAO,OAAO,EAAE,MAAM,QAAQ,OAAO,SAAS,EAAE,GAAG,KAAK,EAAE,MAAM,MAAM,EAAE;AAAA,EAC7G,QAAQ,EAAE,MAAM,OAAO,MAAM,EAAE,MAAM,OAAO,OAAO,EAAE,MAAM,QAAQ,OAAO,SAAS,EAAE,GAAG,KAAK,EAAE,MAAM,MAAM,EAAE;AAC9G;","names":[]}