{"version":3,"sources":["../../../src/elaboration/shared/monad.v2.ts"],"sourcesContent":["import * as EB from \"@yap/elaboration\";\n\nimport * as E from \"fp-ts/Either\";\nimport * as F from \"fp-ts/function\";\nimport * as A from \"fp-ts/Array\";\n\nimport { Either } from \"fp-ts/lib/Either\";\nimport { Cause } from \"./errors\";\nimport * as Errors from \"./errors\";\n\nimport * as P from \"./provenance\";\n\nimport * as Modal from \"@yap/verification/modalities/shared\";\n\nexport type Elaboration<A> = (ctx: EB.Context, w?: Omit<Collector<A>, \"result\">) => Collector<A>;\n\ntype Collector<A> = {\n\tconstraints: P.WithProvenance<EB.Constraint>[];\n\tbinders: EB.Binder[];\n\tmetas: EB.Context[\"metas\"];\n\ttypes: Record<EB.Term[\"id\"], { nf: EB.NF.Value; modalities: Modal.Annotations }>;\n\tresult: Either<Err, A>;\n};\n\ntype Accumulator = Omit<Collector<unknown>, \"result\">;\nconst concat: (fa: Accumulator, fb: Accumulator) => Accumulator = (fa, fb) => ({\n\tconstraints: fa.constraints.concat(fb.constraints),\n\tbinders: fa.binders.concat(fb.binders),\n\tmetas: { ...fa.metas, ...fb.metas },\n\ttypes: { ...fa.types, ...fb.types },\n});\nconst empty: Accumulator = { constraints: [], binders: [], metas: {}, types: {} };\n\nexport type Err = Cause & { provenance?: P.Provenance[]; ctx: EB.Context };\n\nexport const display = (err: Err): string => {\n\tconst cause = Errors.display(err, err.ctx.zonker, err.ctx.metas);\n\tconst prov = err.provenance ? P.display(err.provenance, { cap: 100 }, err.ctx.zonker, err.ctx.metas) : \"\";\n\treturn prov ? `${cause}\\n\\nTrace:\\n${prov}` : cause;\n};\n\n/************************************************************************************************************************\n * Functor combinators\n ************************************************************************************************************************/\nexport function fmap<A, B>(fa: Collector<A>, f: (x: A) => B): Collector<B>;\nexport function fmap<A, B>(f: (x: A) => B): (fa: Collector<A>) => Collector<B>;\nexport function fmap<A, B>(...args: [(x: A) => B] | [Collector<A>, (x: A) => B]): any {\n\tif (args.length === 1) {\n\t\tconst [f] = args;\n\t\treturn (fa: Collector<A>) => ({ ...fa, result: E.Functor.map(fa.result, f) });\n\t}\n\n\tconst [fa, f] = args;\n\treturn { ...fa, result: E.Functor.map(fa.result, f) };\n}\n\nexport function chain<A, B>(fa: Collector<A>, f: (x: A) => Collector<B>): Collector<B>;\nexport function chain<A, B>(f: (x: A) => Collector<B>): (fa: Collector<A>) => Collector<B>;\nexport function chain<A, B>(...args: [(x: A) => Collector<B>] | [Collector<A>, (x: A) => Collector<B>]): any {\n\tconst _chain = (fa: Collector<A>, f: (x: A) => Collector<B>) => {\n\t\tif (E.isLeft(fa.result)) {\n\t\t\treturn fa;\n\t\t}\n\t\tconst next = f(fa.result.right);\n\t\tconst final = concat(fa, next);\n\t\treturn { ...final, result: next.result };\n\t};\n\tif (args.length === 1) {\n\t\tconst [f] = args;\n\t\treturn (fa: Collector<A>) => _chain(fa, f);\n\t}\n\n\tconst [fa, f] = args;\n\treturn _chain(fa, f);\n}\n\nexport const track: <A>(provenance: P.Provenance | P.Provenance[], fa: Elaboration<A>) => Elaboration<A> = (provenance, fa) => ctx => {\n\tconst extended = { ...ctx, trace: ctx.trace.concat(provenance) };\n\treturn fa(extended);\n};\n\n/************************************************************************************************************************\n * Foldable combinators\n ************************************************************************************************************************/\nexport const fold = <A, B>(f: (acc: B, a: A, i: number) => Elaboration<B>, initial: B, as: A[]): Elaboration<B> => {\n\treturn as.reduce(\n\t\t(e, a, i) =>\n\t\t\tDo<B, B>(function* () {\n\t\t\t\tconst acc = yield e;\n\t\t\t\treturn yield f(acc, a, i);\n\t\t\t}),\n\t\tof(initial),\n\t);\n};\n\n/************************************************************************************************************************\n * Traversable combinators\n ************************************************************************************************************************/\nexport const traverse = <A, B>(as: A[], f: (a: A, i: number) => Elaboration<B>): Elaboration<B[]> => {\n\treturn fold(\n\t\t(acc, a, i) =>\n\t\t\tDo<B[], B>(function* () {\n\t\t\t\tconst b = yield f(a, i);\n\t\t\t\treturn A.append(b)(acc);\n\t\t\t}),\n\t\t[] as B[],\n\t\tas,\n\t);\n};\n\nexport const mkCollector = <A>(a: A): Collector<A> => ({\n\t...empty,\n\tresult: E.right(a),\n});\n\nexport const of =\n\t<A>(a: A): Elaboration<A> =>\n\tctx =>\n\t\tmkCollector(a);\n/******************\n *\n * DO NOTATION\n *\n ******************/\nexport type Unwrap<T> = T extends Elaboration<infer A> ? A : never;\n\nexport const ask = function* (): Generator<Elaboration<EB.Context>, EB.Context, EB.Context> {\n\treturn yield mkCollector;\n};\n\nexport const asks = function* <A>(fn: (r: EB.Context) => A): Generator<Elaboration<A>, A, A> {\n\treturn yield F.flow(fn, mkCollector);\n};\n\nexport function local<A>(modify: (ctx: EB.Context) => EB.Context, ma: Elaboration<A>): Generator<Elaboration<A>, A, A>;\nexport function local(modify: (ctx: EB.Context) => EB.Context): <A>(ma: Elaboration<A>) => Generator<Elaboration<A>, A, A>;\nexport function local<A>(...args: any[]): any {\n\tif (args.length === 1) {\n\t\tconst [modify] = args as [(ctx: EB.Context) => EB.Context];\n\t\treturn <B>(ma: Elaboration<B>) =>\n\t\t\t(function* (): Generator<Elaboration<B>, B, B> {\n\t\t\t\tconst b: B = yield (ctx: EB.Context) => ma(modify(ctx));\n\t\t\t\treturn b;\n\t\t\t})();\n\t}\n\tconst [modify, ma] = args as [(ctx: EB.Context) => EB.Context, Elaboration<A>];\n\treturn (function* (): Generator<Elaboration<A>, A, A> {\n\t\tconst a: A = yield (ctx: EB.Context) => ma(modify(ctx));\n\t\treturn a;\n\t})();\n}\n\ntype Channel = \"constraint\" | \"binder\" | \"meta\" | \"type\";\ntype Payload<K extends Channel> = K extends \"constraint\"\n\t? OptionalLvl<EB.Constraint>\n\t: K extends \"binder\"\n\t\t? EB.Binder\n\t\t: K extends \"meta\"\n\t\t\t? { meta: EB.Meta; ann: EB.NF.Value }\n\t\t\t: K extends \"type\"\n\t\t\t\t? { term: EB.Term; nf: EB.NF.Value; modalities: Modal.Annotations }\n\t\t\t\t: never;\n\ntype OptionalLvl<T> = T extends { type: \"assign\"; lvl: infer L } ? Omit<T, \"lvl\"> & { lvl?: L } : T;\nexport const tell = function* <K extends Channel>(channel: K, payload: Payload<K> | Payload<K>[]): Generator<Elaboration<any>, void, any> {\n\tconst ctx = yield* ask();\n\tconst many = Array.isArray(payload) ? payload : [payload];\n\n\tconst addProvenance = (cs: EB.Constraint[]) => cs.map(c => ({ ...c, trace: ctx.trace }));\n\tconst writer: Omit<Collector<unknown>, \"result\"> = (() => {\n\t\tif (channel === \"constraint\") {\n\t\t\tconst cs = (many as Payload<\"constraint\">[]).map(c => {\n\t\t\t\tif (c.type !== \"assign\") {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t\treturn { ...c, lvl: ctx.env.length };\n\t\t\t});\n\t\t\treturn { constraints: addProvenance(cs), binders: [], metas: {}, types: {} };\n\t\t}\n\t\tif (channel === \"binder\") {\n\t\t\treturn { constraints: [], binders: many as Payload<\"binder\">[], metas: {}, types: {} };\n\t\t}\n\n\t\tif (channel === \"meta\") {\n\t\t\treturn {\n\t\t\t\tconstraints: [],\n\t\t\t\tbinders: [],\n\t\t\t\tmetas: (many as Payload<\"meta\">[]).reduce((m, { meta, ann }) => ({ ...m, [meta.val]: { meta, ann } }), {}),\n\t\t\t\ttypes: {},\n\t\t\t};\n\t\t}\n\n\t\tif (channel === \"type\") {\n\t\t\treturn {\n\t\t\t\tconstraints: [],\n\t\t\t\tbinders: [],\n\t\t\t\tmetas: {},\n\t\t\t\ttypes: (many as Payload<\"type\">[]).reduce((m, { term, nf, modalities }) => ({ ...m, [term.id]: { nf, modalities } }), {}),\n\t\t\t};\n\t\t}\n\t\tconsole.warn(\"Tell: unknown channel:\", channel);\n\t\tconsole.warn(\"Continuing without telling anything\");\n\t\treturn empty;\n\t})();\n\n\treturn yield* pure(ctx => ({ ...writer, result: E.right(undefined) }));\n};\n\nexport const listen = function* (): Generator<Elaboration<Accumulator>, Accumulator, Accumulator> {\n\treturn yield (_, w = { constraints: [], binders: [], metas: {}, types: {} }) => mkCollector(w);\n};\n\nexport const fail = function* <A>(cause: Cause): Generator<Elaboration<any>, A, any> {\n\tconst ctx = yield* ask();\n\treturn yield* liftE(E.left({ ...cause, provenance: ctx.trace, ctx }));\n};\n\n// export const catchErr = function* <A>(handler: (err: Err) => Elaboration<A>): Generator<Elaboration<A>, A, A> {\n// \treturn yield* (ctx: EB.Context) => {\n// \t\tconst result = handler(ctx);\n// \t\treturn mkCollector(result);\n// \t};\n// };\n\nexport const lift = function* <A>(a: A): Generator<Elaboration<A>, A, A> {\n\treturn yield _ => mkCollector(a);\n};\n\nexport const liftC = function* <A>(c: Collector<A>): Generator<Elaboration<A>, A, A> {\n\treturn yield _ => c;\n};\n\nexport const liftE = <A>(e: E.Either<Err, A>): Generator<Elaboration<A>, A, A> => {\n\treturn liftC({ ...empty, result: e });\n};\n\nexport const pure = function* <A>(ma: Elaboration<A>): Generator<Elaboration<A>, A, A> {\n\treturn yield ma;\n};\n\nexport const regen = <A, B>(f: (a: A) => Elaboration<B>) => {\n\tconst gen = F.flow(f, pure);\n\treturn Object.assign(f, { gen });\n};\n\nexport function Do<R, A>(gen: () => Generator<Elaboration<any>, R, A>): Elaboration<R> {\n\treturn ctx => {\n\t\tconst it = gen();\n\n\t\tlet collected: Omit<Collector<unknown>, \"result\"> = empty;\n\t\tlet state = it.next();\n\n\t\twhile (!state.done) {\n\t\t\tconst ma = state.value(ctx, collected); // pipe context for each step of the generator\n\t\t\tcollected = concat(collected, ma); // accumulate results a la Writer\n\n\t\t\t// accumulate results a la Writer\n\t\t\tif (E.isLeft(ma.result)) {\n\t\t\t\treturn ma;\n\t\t\t} // Error handling semantics // Error handling semantics\n\t\t\tstate = it.next(ma.result.right); // proceed with the sequence until the next yield\n\t\t}\n\t\tconst result = mkCollector(state.value);\n\t\tresult.binders = collected.binders;\n\t\tresult.constraints = collected.constraints;\n\t\tresult.metas = collected.metas;\n\t\tresult.types = collected.types;\n\t\treturn result;\n\t};\n}\n\n/**\n *\n *\n * GENERIC Do\n */\n// const URI = \"Collector\";\n// type URI = typeof URI;\n// declare module \"fp-ts/HKT\" {\n//     interface URItoKind<A> {\n//         readonly [URI]: Collector<A>;\n//     }\n// }\n// type UnwrapM<T> = T extends Kind<any, infer A> ? A : never;\n\n// // yield*-friendly helper\n// export function liftM<M extends URIS>() {\n//     return function* <A>(ma: Kind<M, A>): Generator<Kind<M, A>, A, A> {\n//         const a: A = yield ma as any;\n//         return a;\n//     };\n// }\n\n// // Do for any Monad1\n// export function DoM<M extends URIS>(M: Monad1<M>) {\n//     return function <Y extends Kind<M, any>, R>(\n//         gen: () => Generator<Y, R, UnwrapM<Y>>\n//     ): Kind<M, R> {\n\n//         const it = gen();\n//         let state = it.next();\n\n//         while (!state.done) {\n//             let exit = true;\n//             M.map(state.value as any, (a: UnwrapM<Y>) => {\n//                 state = it.next(a);\n//                 exit = false;\n//             });\n//             if (exit) break;\n//         }\n//         return state.value\n//     };\n// }\n"],"mappings":"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","names":["f","fa","modify","ma","ctx"]}