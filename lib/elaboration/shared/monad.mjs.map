{"version":3,"sources":["../../../src/elaboration/shared/monad.ts"],"sourcesContent":["import { Monoid } from \"fp-ts/lib/Monoid\";\nimport { Reader } from \"fp-ts/lib/Reader\";\nimport * as R from \"fp-ts/lib/Reader\";\nimport * as F from \"fp-ts/lib/function\";\n\nimport { Writer } from \"fp-ts/lib/Writer\";\nimport * as W from \"fp-ts/lib/Writer\";\nimport * as E from \"fp-ts/lib/Either\";\n\nimport * as EB from \"@yap/elaboration\";\nimport { Cause } from \"./errors\";\nimport { Either } from \"fp-ts/lib/Either\";\n\n// type Accumulator = {\n// \tconstraints: (EB.Constraint & { provenance: EB.Provenance[] })[];\n// \tbinders: EB.Binder[];\n// };\n\n// const monoid: Monoid<Accumulator> = {\n// \tconcat: (x, y) => ({\n// \t\tconstraints: x.constraints.concat(y.constraints),\n// \t\tbinders: x.binders.concat(y.binders),\n// \t}),\n// \tempty: { constraints: [], binders: [] },\n// };\n\n// const URI = \"Elaboration\";\n// type URI = typeof URI;\n\n// declare module \"fp-ts/HKT\" {\n// \tinterface URItoKind<A> {\n// \t\treadonly [URI]: Elaboration<A>;\n// \t}\n// }\n\n// /************************************************************************************************************************\n//  * Functor combinators\n//  ************************************************************************************************************************/\n// export function fmap<A, B>(fa: Elaboration<A>, f: (x: A) => B): Elaboration<B>;\n// export function fmap<A, B>(f: (x: A) => B): (fa: Elaboration<A>) => Elaboration<B>;\n// export function fmap<A, B>(...args: [(x: A) => B] | [Elaboration<A>, (x: A) => B]): any {\n// \tif (args.length === 1) {\n// \t\tconst [f] = args;\n// \t\treturn R.map<Emitter<A>, Emitter<B>>(W.map(E.map(f)));\n// \t}\n\n// \tconst [fa, f] = args;\n// \treturn R.Functor.map(fa, W.map(E.map(f)));\n// }\n\n// /************************************************************************************************************************\n//  * Monad combinators\n//  ************************************************************************************************************************/\n// export function chain<A, B>(fa: Elaboration<A>, f: (x: A) => Elaboration<B>): Elaboration<B>;\n// export function chain<A, B>(f: (x: A) => Elaboration<B>): (fa: Elaboration<A>) => Elaboration<B>;\n// export function chain<A, B>(...args: [(x: A) => Elaboration<B>] | [Elaboration<A>, (x: A) => Elaboration<B>]) {\n// \tconst _chain = (rw: Elaboration<A>, f: (x: A) => Elaboration<B>): Elaboration<B> => {\n// \t\treturn (r: EB.Context): Emitter<B> => {\n// \t\t\tconst [a, w1] = rw(r)();\n// \t\t\tif (E.isLeft(a)) {\n// \t\t\t\treturn W.Functor.map(W.tell(w1), _ => a);\n// \t\t\t}\n\n// \t\t\tconst [b, w2] = f(a.right)(r)();\n// \t\t\treturn W.Functor.map(W.tell(monoid.concat(w1, w2)), _ => b);\n// \t\t};\n// \t};\n\n// \tif (args.length === 1) {\n// \t\tconst [f] = args;\n// \t\treturn (rw: Elaboration<A>) => _chain(rw, f);\n// \t}\n\n// \tconst [rw, f] = args;\n// \treturn _chain(rw, f);\n// }\n\n// export const of = <A>(a: A): Elaboration<A> => F.pipe(a, E.right, W.getPointed(monoid).of, R.of);\n// export const discard = <A, B>(f: (a: A) => Elaboration<B>) => chain<A, A>(val => fmap(f(val), () => val));\n\n// /************************************************************************************************************************\n//  * Foldable combinators\n//  ************************************************************************************************************************/\n// export const fold = <A, B>(f: (acc: B, a: A, i: number) => Elaboration<B>, acc: B, as: A[]): Elaboration<B> =>\n// \tas.reduce((rw, a, i) => chain(rw, acc => f(acc, a, i)), of(acc));\n\n// /************************************************************************************************************************\n//  * Traversable combinators\n//  ************************************************************************************************************************/\n// export const traverse = <A, B>(as: A[], f: (a: A) => Elaboration<B>): Elaboration<B[]> => {\n// \treturn fold((acc, a) => fmap(f(a), b => acc.concat([b])), [] as B[], as);\n// };\n\n// /************************************************************************************************************************\n//  * Lifting\n//  ************************************************************************************************************************/\n// export const liftE = <A>(e: Either<Cause, A>): Elaboration<A> => R.of(W.getPointed(monoid).of(e));\n// export const liftW = <A>(w: Emitter<A>): Elaboration<A> => R.of(w);\n// export const liftR =\n// \t<A>(fa: Reader<EB.Context, A>): Elaboration<A> =>\n// \t(r: EB.Context) =>\n// \t\tW.getPointed(monoid).of(E.right(fa(r)));\n\n// /************************************************************************************************************************\n//  * Do notation\n//  ************************************************************************************************************************/\n// export const Do = of<{}>({});\n\n// export const bind =\n// \t<N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => Elaboration<B>) =>\n// \t(ma: Elaboration<A>): Elaboration<{ readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }> => {\n// \t\treturn chain(ma, a => {\n// \t\t\treturn fmap(f(a), b => Object.assign({}, a, { [name]: b }) as any);\n// \t\t});\n// \t};\n\n// export const bindTo = <N extends string>(name: N): (<A>(ma: Elaboration<A>) => Elaboration<{ [K in N]: A }>) => fmap(a => ({ [name]: a }) as any);\n\n// const _let = <N extends string, A, B>(\n// \tname: Exclude<N, keyof A>,\n// \tfa: Elaboration<B>,\n// ): ((ma: Elaboration<A>) => Elaboration<{ readonly [K in keyof A | N]: K extends keyof A ? A[K] : B }>) => bind(name, () => fa);\n// export { _let as let };\n\n// /************************************************************************************************************************\n//  * Utility combinators\n//  ************************************************************************************************************************/\n\n// /**********************************\n//  * Context combinators\n//  **********************************/\n// export const ask = F.flow(R.ask, liftR<EB.Context>);\n\n// type Local = EB.Context | ((ctx: EB.Context) => EB.Context);\n// export const local: <A>(f: Local, rw: Elaboration<A>) => Elaboration<A> = (f, rw) => {\n// \treturn (ctx: EB.Context) => {\n// \t\tconst _ctx = typeof f === \"function\" ? f(ctx) : f;\n// \t\treturn rw(_ctx);\n// \t};\n// };\n\n// /**********************************\n//  * Constraint combinators\n//  **********************************/\n// type Channel = \"constraint\" | \"binder\";\n// type Payload<K extends Channel> = K extends \"constraint\" ? EB.Constraint : EB.Binder;\n// export const tell = <K extends Channel>(channel: K, payload: Payload<K> | Payload<K>[]) =>\n// \tchain(ask(), ({ trace }) => {\n// \t\tconst many = Array.isArray(payload) ? payload : [payload];\n\n// \t\tconst addProvenance = (cs: EB.Constraint[]) => cs.map(c => ({ ...c, provenance: trace }));\n// \t\tconst acc: Accumulator =\n// \t\t\tchannel === \"constraint\" ? { constraints: addProvenance(many as EB.Constraint[]), binders: [] } : { constraints: [], binders: many as EB.Binder[] };\n\n// \t\tconst w = W.Functor.map(W.tell(acc), E.right);\n// \t\treturn liftW<void>(w);\n// \t});\n\n// export const listen =\n// \t<A, B>(f: (aw: [A, Accumulator]) => B) =>\n// \t(rw: Elaboration<A>): Elaboration<B> => {\n// \t\tconst tap = (emitter: Emitter<A>): Emitter<B> => {\n// \t\t\tconst [either, acc] = emitter();\n\n// \t\t\treturn W.Functor.map(W.tell(acc), _ => E.Functor.map(either, a => f([a, acc])));\n// \t\t};\n// \t\treturn F.pipe(rw, R.map(tap));\n// \t};\n\n// /**********************************\n//  * Provenance combinators\n//  **********************************/\n\n// export const track = <A>(provenance: EB.Provenance, rw: Elaboration<A>) =>\n// \tlocal(ctx => {\n// \t\treturn { ...ctx, trace: ctx.trace.concat([provenance]) };\n// \t}, rw);\n// export const trackMany = <A>(provenance: EB.Provenance[], rw: Elaboration<A>) =>\n// \tlocal(ctx => {\n// \t\treturn { ...ctx, trace: ctx.trace.concat(provenance) };\n// \t}, rw);\n\n// /**********************************\n//  * Exception handling\n//  **********************************/\n\n// export const fail = (cause: Err): Elaboration<never> =>\n// \tchain(ask(), ctx => {\n// \t\treturn liftE(E.left({ ...cause, provenance: ctx.trace.concat(cause.provenance || []) }));\n// \t});\n\n// export const catchError =\n// \t<A>(rw: Elaboration<A>, f: (e: Err) => Elaboration<A>): Elaboration<A> =>\n// \tr => {\n// \t\tconst [a, w] = rw(r)();\n// \t\tif (E.isRight(a)) {\n// \t\t\treturn W.getPointed(monoid).of(a);\n// \t\t}\n\n// \t\tconst [b, w2] = f(a.left)(r)();\n// \t\treturn W.Functor.map(W.tell(monoid.concat(w, w2)), _ => b);\n// \t};\n\n// export const onError = <A>(rw: Elaboration<A>, f: (e: Cause) => unknown) => {\n// \treturn catchError(rw, e => {\n// \t\tf(e);\n// \t\treturn fail(e);\n// \t});\n// };\n\n// /**********************************\n//  * Run the monad\n//  **********************************/\n// export const run = <A>(rw: Elaboration<A>, ctx: EB.Context) => rw(ctx)();\n"],"mappings":";;;AAAA;AAAA;AAAA;AAAA;","names":[]}