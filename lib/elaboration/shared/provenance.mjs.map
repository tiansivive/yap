{"version":3,"sources":["../../../src/elaboration/shared/provenance.ts"],"sourcesContent":["import * as A from \"fp-ts/Array\";\n\nimport * as EB from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as Src from \"@yap/src/index\";\n\nimport * as R from \"@yap/shared/rows\";\n\nexport type WithProvenance<T extends object> = T & { trace: Provenance[] };\nexport type Provenance = (\n\t| { tag: \"src\"; type: \"term\"; term: Src.Term }\n\t| { tag: \"src\"; type: \"stmt\"; stmt: Src.Statement }\n\t| { tag: \"eb\"; term: EB.Term }\n\t| { tag: \"nf\"; val: NF.Value }\n\t| { tag: \"alt\"; alt: Src.Alternative }\n\t| { tag: \"unify\"; type: \"nf\"; vals: [NF.Value, NF.Value] }\n\t| { tag: \"unify\"; type: \"row\"; rows: [NF.Row, NF.Row] }\n) & { metadata?: Metadata };\n\ntype Metadata =\n\t| { action: \"checking\"; against: NF.Value; description?: string }\n\t| { action: \"infer\"; description?: string }\n\t| { action: \"unification\" }\n\t| { action: \"alternative\"; type: NF.Value; motive: string };\n\nexport const display = (provenance: Provenance[] = [], opts = { cap: 10 }, zonker: EB.Zonker, metas: EB.Context[\"metas\"]): string => {\n\tconst displayCtx = { zonker, metas, env: [] };\n\treturn A.reverse(provenance)\n\t\t.map(p => {\n\t\t\tconst pretty = (prov => {\n\t\t\t\tif (prov.tag === \"unify\" && prov.type === \"nf\") {\n\t\t\t\t\treturn `\\n\\t${NF.display(prov.vals[0] as NF.Value, displayCtx)}\\nwith:\\n\\t${NF.display(prov.vals[1] as NF.Value, displayCtx)}`;\n\t\t\t\t}\n\n\t\t\t\tif (prov.tag === \"unify\" && prov.type === \"row\") {\n\t\t\t\t\tconst display = R.display<NF.Value, NF.Variable>({\n\t\t\t\t\t\tterm: tm => NF.display(tm, displayCtx),\n\t\t\t\t\t\tvar: v => NF.display(NF.Constructors.Var(v), displayCtx),\n\t\t\t\t\t});\n\t\t\t\t\treturn `\\n\\t${display(prov.rows[0])}\\nwith:\\n\\t${display(prov.rows[1])}`;\n\t\t\t\t}\n\n\t\t\t\tif (prov.tag === \"src\" && prov.type === \"term\") {\n\t\t\t\t\treturn Src.display(prov.term);\n\t\t\t\t}\n\n\t\t\t\tif (prov.tag === \"src\" && prov.type === \"stmt\") {\n\t\t\t\t\treturn Src.Stmt.display(prov.stmt);\n\t\t\t\t}\n\n\t\t\t\tif (prov.tag === \"eb\") {\n\t\t\t\t\treturn EB.Display.Term(prov.term, displayCtx);\n\t\t\t\t}\n\n\t\t\t\tif (prov.tag === \"nf\") {\n\t\t\t\t\treturn NF.display(prov.val, displayCtx);\n\t\t\t\t}\n\n\t\t\t\tif (prov.tag === \"alt\") {\n\t\t\t\t\treturn Src.Alt.display(prov.alt);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(\"Provenance [display]: Not implemented yet\");\n\t\t\t})(p);\n\n\t\t\tconst { metadata } = p;\n\n\t\t\tlet loc = \"\";\n\t\t\tif (p.tag === \"src\") {\n\t\t\t\tconst t = p.type === \"term\" ? p.term : p.stmt;\n\t\t\t\tloc = `\\n@ line: ${t.location.from.line}, col: ${t.location.from.column}\\n`;\n\t\t\t}\n\n\t\t\tif (metadata?.action === \"checking\") {\n\t\t\t\tconst reason = metadata.description ? `\\n\\nReason: ${metadata.description}` : \"\";\n\t\t\t\tconst msg = `While checking:\\n\\t${pretty}\\nagainst:\\n\\t${NF.display(metadata.against, displayCtx)}${reason}`;\n\t\t\t\treturn `${msg}\\n${loc}`;\n\t\t\t}\n\t\t\tif (metadata?.action === \"alternative\") {\n\t\t\t\tconst msg = `In alternative:\\n\\t${pretty}\\nwith type:\\n\\t${NF.display(metadata.type, displayCtx)}\\nWhile: ${metadata.motive}`;\n\t\t\t\treturn `${msg}\\n${loc}`;\n\t\t\t}\n\t\t\tif (metadata?.action === \"infer\") {\n\t\t\t\tconst reason = metadata.description ? `\\n\\nReason: ${metadata.description}` : \"\";\n\t\t\t\tconst msg = `While inferring:\\n\\t${pretty}${reason}`;\n\t\t\t\treturn `${msg}\\n${loc}`;\n\t\t\t}\n\t\t\tif (metadata?.action === \"unification\") {\n\t\t\t\tconst msg = `\\nWhile unifying:\\n\\t${pretty}`;\n\t\t\t\treturn `${msg}\\n${loc}`;\n\t\t\t}\n\n\t\t\treturn \"Provenance [display]: Not implemented yet:\\n\" + JSON.stringify(p);\n\t\t})\n\t\t.slice(0, opts.cap)\n\t\t.join(\"\\n--------------------------------------------------------------------------------------------\\n\\n\");\n};\n"],"mappings":"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","names":["display"]}