{"version":3,"sources":["../../../src/elaboration/shared/context.ts"],"sourcesContent":["import { replicate, unsafeUpdateAt } from \"fp-ts/lib/Array\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as EB from \"@yap/elaboration\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as Src from \"@yap/src/index\";\nimport * as P from \"@yap/shared/provenance\";\n\nimport * as U from \"@yap/elaboration/unification/index\";\nimport * as Sub from \"@yap/elaboration/unification/substitution\";\n\nimport * as F from \"fp-ts/function\";\nimport * as E from \"fp-ts/Either\";\nimport * as A from \"fp-ts/Array\";\nimport { set, update } from \"@yap/utils\";\nimport { Provenance } from \"./provenance\";\n\ntype Origin = \"inserted\" | \"source\";\n\nexport type Context = {\n\tenv: Array<{\n\t\ttype: [Binder, Origin, NF.Value];\n\t\tnf: NF.Value;\n\t\tname: Binder;\n\t}>;\n\timplicits: Array<[EB.Term, NF.Value]>;\n\tsigma: Record<string, Sigma>;\n\tzonker: Sub.Subst;\n\tmetas: Record<number, { meta: EB.Meta; ann: NF.Value }>;\n\timports: Record<string, EB.AST>;\n\tffi: Record<string, { arity: number; compute: (...args: NF.Value[]) => NF.Value }>;\n\ttrace: P.Stack<Provenance>;\n};\n\nexport type Zonker = Context[\"zonker\"];\n\nexport type Sigma = { nf: NF.Value; ann: NF.Value; multiplicity: Q.Multiplicity };\n\nexport type Binder = Pick<EB.Binding, \"type\" | \"variable\">;\n\nexport const lookup = (variable: Src.Variable, ctx: Context): V2.Elaboration<EB.AST> => {\n\tconst zeros = replicate<Q.Multiplicity>(ctx.env.length, Q.Zero);\n\t// labels are different syntax (:varname), so we can check them before bound variables as the latter will never shadow the former\n\tif (variable.type === \"label\") {\n\t\tconst key = ctx.sigma[variable.value];\n\t\tif (key) {\n\t\t\tconst { ann, multiplicity } = key;\n\t\t\tconst tm = EB.Constructors.Var({ type: \"Label\", name: variable.value });\n\t\t\treturn V2.of<EB.AST>([tm, ann, zeros]); // QUESTION: need to somehow handle multiplicity?\n\t\t}\n\t\tthrow new Error(`Label not found: ${variable.value}`);\n\t}\n\n\tconst _lookup = (i: number, variable: Src.Variable, types: Array<Context[\"env\"][number][\"type\"]>): V2.Elaboration<EB.AST> => {\n\t\t// free vars can be shadowed by bound vars, so only if no bound vars are found do we check for free vars\n\t\t// QUESTION: should we disallow this shadowing?\n\t\tif (types.length === 0) {\n\t\t\tconst free = ctx.imports[variable.value];\n\t\t\tif (free) {\n\t\t\t\tconst [, nf, us] = free;\n\n\t\t\t\tconst tm = EB.Constructors.Var({ type: \"Free\", name: variable.value });\n\t\t\t\treturn V2.of<EB.AST>([tm, nf, Q.add(us, zeros)]); //QUESTION: is this addition correct?\n\t\t\t}\n\n\t\t\tthrow new Error(`Variable not found: ${variable.value}`);\n\t\t}\n\n\t\tconst [[binder, origin, nf], ...rest] = types;\n\t\t//const usages = []//unsafeUpdateAt(i, modalities.quantity, zeros);\n\t\t// do we need to check origin here? I don't think it makes a difference whether it's an inserted (implicit) or source (explicit) binder\n\t\tif (binder.variable === variable.value) {\n\t\t\tconst tm = EB.Constructors.Var({ type: \"Bound\", index: i });\n\t\t\treturn V2.Do(function* () {\n\t\t\t\tyield* V2.tell(\"binder\", binder);\n\t\t\t\treturn [tm, nf, zeros] as EB.AST;\n\t\t\t});\n\t\t}\n\n\t\treturn _lookup(i + 1, variable, rest);\n\t};\n\n\treturn _lookup(\n\t\t0,\n\t\tvariable,\n\t\tctx.env.map(v => v.type),\n\t);\n};\nlookup.gen = F.flow(lookup, V2.pure);\n\nexport const resolveImplicit = (nf: NF.Value): V2.Elaboration<[EB.Term, Sub.Subst] | void> =>\n\tV2.Do(function* () {\n\t\tconst ctx = yield* V2.ask();\n\n\t\tconst lookup = (implicits: Context[\"implicits\"]): [EB.Term, Sub.Subst] | void => {\n\t\t\tif (implicits.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [[term, value], ...rest] = implicits;\n\t\t\tconst unification = U.unify(nf, value, ctx.env.length, Sub.empty);\n\t\t\tconst result = unification(ctx).result;\n\n\t\t\tif (E.isRight(result)) {\n\t\t\t\treturn [term, result.right];\n\t\t\t}\n\t\t\treturn lookup(rest);\n\t\t};\n\n\t\treturn lookup(ctx.implicits);\n\t});\nresolveImplicit.gen = F.flow(resolveImplicit, V2.pure);\n\nexport const bind = (context: Context, binder: Binder, annotation: NF.Value, origin: Origin = \"source\"): Context => {\n\tconst { env } = context;\n\tconst entry: Context[\"env\"][number] = {\n\t\tnf: NF.Constructors.Rigid(env.length),\n\t\ttype: [binder, origin, annotation],\n\t\tname: binder,\n\t};\n\n\treturn {\n\t\t...context,\n\t\tenv: [entry, ...env],\n\t};\n};\n\nexport const extend = (context: Context, binder: Binder, value: NF.Value, origin: Origin = \"source\"): Context => {\n\tconst { env } = context;\n\n\tconst entry: Context[\"env\"][number] = {\n\t\tnf: value,\n\t\ttype: [binder, origin, new Error(\"Need to implemented typed metas: Get the type from metas context\") as any],\n\t\tname: binder,\n\t};\n\treturn {\n\t\t...context,\n\t\tenv: [entry, ...env],\n\t};\n};\n\nexport const augment = (context: Context, binder: Binder, annotation: NF.Value, origin: Origin = \"inserted\") => {\n\tconst { env } = context;\n\tconst entry: Context[\"env\"][number] = {\n\t\tnf: NF.Constructors.Rigid(env.length),\n\t\ttype: [binder, origin, annotation],\n\t\tname: binder,\n\t};\n\n\treturn {\n\t\t...context,\n\t\tenv: [...env, entry],\n\t};\n};\n\nexport const unfoldMu = (context: Context, binder: Binder, annotation: NF.Value, origin: Origin = \"source\"): Context => {\n\tconst { env } = context;\n\tconst entry: Context[\"env\"][number] = {\n\t\tnf: annotation, // NOTE: mu types are directly placed in the env\n\t\ttype: [binder, origin, annotation],\n\t\tname: binder,\n\t};\n\treturn {\n\t\t...context,\n\t\tenv: [entry, ...env],\n\t};\n};\n\nexport const extendSigma = (ctx: Context, variable: string, sigma: Sigma): Context => {\n\treturn set(ctx, [\"sigma\", variable] as const, sigma);\n};\n\nexport const muContext = (ctx: Context): Context => {\n\treturn {\n\t\t...ctx,\n\t\tenv: ctx.env.map((e): Context[\"env\"][number] => {\n\t\t\tconst [b, ...rest] = e.type;\n\t\t\tif (b.type === \"Let\") {\n\t\t\t\treturn { ...e, type: [{ ...b, type: \"Mu\" }, ...rest] };\n\t\t\t}\n\t\t\treturn e;\n\t\t}),\n\t};\n};\n\nexport const prune = (ctx: Context, lvl: number): Context => {\n\treturn update(ctx, \"env\", A.takeRight(lvl));\n};\n\nexport const lvl2idx = (ctx: Context, lvl: number): number => {\n\treturn ctx.env.length - 1 - lvl;\n};\n"],"mappings":"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","names":["variable","nf","lookup"]}