{"version":3,"sources":["../../../src/elaboration/pretty/pretty.ts"],"sourcesContent":["import * as NF from \"../normalization\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport { match } from \"ts-pattern\";\nimport * as Icit from \"@yap/shared/implicitness\";\nimport * as Lit from \"@yap/shared/literals\";\nimport * as R from \"@yap/shared/rows\";\n\nimport * as EB from \"..\";\nimport { options } from \"@yap/shared/config/options\";\n\nconst display = (\n\tterm: EB.Term,\n\tctx: Pick<EB.Context, \"env\" | \"zonker\" | \"metas\">,\n\topts: { deBruijn: boolean; printEnv?: boolean } = { deBruijn: false, printEnv: false },\n): string => {\n\tconst bind = (name: string) => {\n\t\treturn { ...ctx, env: [{ name: { variable: name } }, ...ctx.env] } as Pick<EB.Context, \"env\" | \"zonker\" | \"metas\">;\n\t};\n\tconst _display = (term: EB.Term): string => {\n\t\treturn (\n\t\t\tmatch(term)\n\t\t\t\t.with({ type: \"Lit\" }, ({ value }) => Lit.display(value))\n\t\t\t\t.with({ type: \"Var\" }, ({ variable }) =>\n\t\t\t\t\tmatch(variable)\n\t\t\t\t\t\t.with({ type: \"Bound\" }, ({ index }) => {\n\t\t\t\t\t\t\tconst name = ctx.env[index]?.name.variable ?? `I${index}`;\n\t\t\t\t\t\t\treturn name + (opts.deBruijn ? `#I${index}` : \"\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.with({ type: \"Free\" }, ({ name }) => name)\n\t\t\t\t\t\t.with({ type: \"Foreign\" }, ({ name }) => `FFI.${name}`)\n\t\t\t\t\t\t.with({ type: \"Label\" }, ({ name }) => `:${name}`)\n\t\t\t\t\t\t.with({ type: \"Meta\" }, ({ val }) => {\n\t\t\t\t\t\t\tif (ctx.zonker[val]) {\n\t\t\t\t\t\t\t\treturn NF.display(ctx.zonker[val], ctx, opts);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst { ann } = ctx.metas[val];\n\t\t\t\t\t\t\treturn options.verbose ? `(?${val} :: ${NF.display(ann, ctx, opts)})` : `?${val}`;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.otherwise(() => \"Var _display: Not implemented\"),\n\t\t\t\t)\n\t\t\t\t.with({ type: \"Abs\", binding: { type: \"Mu\" } }, ({ binding, body }) => {\n\t\t\t\t\tif (!options.verbose) {\n\t\t\t\t\t\treturn binding.source;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn `([μ = ${binding.source}](${binding.variable}: ${_display(binding.annotation)})) -> ${display(body, bind(binding.variable), opts)}`;\n\t\t\t\t})\n\t\t\t\t.with({ type: \"Abs\" }, ({ binding, body }) => {\n\t\t\t\t\tconst b = match(binding)\n\t\t\t\t\t\t.with({ type: \"Lambda\" }, ({ variable }) => `λ${variable}`)\n\t\t\t\t\t\t.with({ type: \"Pi\" }, ({ variable, annotation }) => `Π(${variable}: ${_display(annotation)})`)\n\t\t\t\t\t\t.otherwise(() => {\n\t\t\t\t\t\t\tthrow new Error(\"_display Term Binder: Not implemented\");\n\t\t\t\t\t\t});\n\n\t\t\t\t\tconst arr = binding.type !== \"Let\" && binding.type !== \"Mu\" && binding.icit === \"Implicit\" ? \"=>\" : \"->\";\n\n\t\t\t\t\tconst xtended = bind(binding.variable);\n\t\t\t\t\tconst printedEnv = xtended.env\n\t\t\t\t\t\t.map(({ nf, name }) => {\n\t\t\t\t\t\t\tif (nf) {\n\t\t\t\t\t\t\t\treturn `${name.variable} = ${NF.display(nf, xtended, opts)}`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn name.variable;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.join(\"; \");\n\n\t\t\t\t\t//TODO:QUESTION: should we print the environment here?\n\t\t\t\t\tif (opts.printEnv) {\n\t\t\t\t\t\treturn `(${b} ${arr} ${display(body, bind(binding.variable), opts)} -| Γ = ${printedEnv})`;\n\t\t\t\t\t}\n\t\t\t\t\treturn `${b} ${arr} ${display(body, bind(binding.variable), opts)}`;\n\t\t\t\t})\n\t\t\t\t.with({ type: \"App\" }, ({ icit, func, arg }) => {\n\t\t\t\t\tconst f = _display(func);\n\t\t\t\t\tconst a = _display(arg);\n\n\t\t\t\t\tconst wrappedFn = func.type !== \"Var\" && func.type !== \"Lit\" && func.type !== \"App\" ? `(${f})` : f;\n\t\t\t\t\tconst wrappedArg = arg.type === \"Abs\" || arg.type === \"App\" ? `(${a})` : a;\n\n\t\t\t\t\treturn `${wrappedFn} ${Icit.display(icit)}${wrappedArg}`;\n\t\t\t\t})\n\n\t\t\t\t//.with({ type: \"Annotation\" }, ({ term, ann }) => `${_display(term)} : ${_display(ann)}`)\n\t\t\t\t.with({ type: \"Row\" }, ({ row }) =>\n\t\t\t\t\tR.display({\n\t\t\t\t\t\tterm: _display,\n\t\t\t\t\t\tvar: (v: EB.Variable) => _display(EB.Constructors.Var(v)),\n\t\t\t\t\t})(row),\n\t\t\t\t)\n\t\t\t\t.with({ type: \"Proj\" }, ({ label, term }) => `(${_display(term)}).${label}`)\n\t\t\t\t.with({ type: \"Inj\" }, ({ label, value, term }) => `{ ${_display(term)} | ${label} = ${_display(value)} }`)\n\t\t\t\t.with({ type: \"Match\" }, ({ scrutinee, alternatives }) => {\n\t\t\t\t\tconst scut = _display(scrutinee);\n\t\t\t\t\tconst alts = alternatives.map(a => Alt.display(a, ctx, opts)).join(\"\\n\");\n\t\t\t\t\treturn `match ${scut}\\n${alts}`;\n\t\t\t\t})\n\t\t\t\t.with({ type: \"Block\" }, ({ statements, return: ret }) => {\n\t\t\t\t\tconst stmts = statements.map(s => Stmt.display(s, ctx, opts)).join(\"; \");\n\t\t\t\t\treturn `{ ${stmts}; return ${_display(ret)}; }`;\n\t\t\t\t})\n\t\t\t\t.with({ type: \"Modal\" }, ({ term, modalities }) => {\n\t\t\t\t\treturn `<${Q.display(modalities.quantity)}> ${_display(term)} [| ${_display(modalities.liquid)} |]`;\n\t\t\t\t})\n\t\t\t\t//.otherwise(tm => `_display Term ${tm.type}: Not implemented`);\n\t\t\t\t.exhaustive()\n\t\t);\n\t};\n\treturn _display(term);\n};\n\nconst displayConstraint = (constraint: EB.Constraint, ctx: Pick<EB.Context, \"zonker\" | \"metas\" | \"env\">, opts = { deBruijn: false }): string => {\n\tif (constraint.type === \"assign\") {\n\t\treturn `${NF.display(constraint.left, ctx, opts)} ~~ ${NF.display(constraint.right, ctx, opts)}`;\n\t}\n\n\tif (constraint.type === \"usage\") {\n\t\treturn `${Q.display(constraint.computed)} <= ${Q.display(constraint.expected)}`;\n\t}\n\n\t// if (constraint.type === \"resolve\") {\n\t// \treturn `?${constraint.meta.val}\\n@ ${NF.display(constraint.annotation, zonker, metas)}`;\n\t// }\n\n\treturn \"Unknown Constraint\";\n};\n\nconst displayContext = (context: EB.Context, opts = { deBruijn: false }): object => {\n\tconst pretty = {\n\t\tenv: context.env.map(({ nf, type: [binder, origin, mv], name }) => ({\n\t\t\tnf: NF.display(nf, context, opts),\n\t\t\ttype: `${displayBinder(binder.type)} ${binder.variable} (${origin}): ${NF.display(mv, context, opts)}`,\n\t\t\tname,\n\t\t})),\n\t\timports: context.imports,\n\t};\n\treturn pretty;\n};\n\nconst displayBinder = (binder: EB.Binder[\"type\"]): string => {\n\treturn match(binder)\n\t\t.with(\"Let\", () => \"def\")\n\t\t.with(\"Lambda\", () => \"λ\")\n\t\t.with(\"Pi\", () => \"Π\")\n\t\t.with(\"Mu\", () => \"μ\")\n\t\t.otherwise(() => \"Binder Display: Not implemented\");\n};\n\nconst Alt = {\n\tdisplay: (alt: EB.Alternative, ctx: Pick<EB.Context, \"zonker\" | \"metas\" | \"env\">, opts = { deBruijn: false }): string => {\n\t\tconst xtended = alt.binders.reduce((acc, [b]) => ({ ...acc, env: [{ name: { variable: b } }, ...acc.env] }) as typeof ctx, ctx);\n\t\treturn `| ${Pat.display(alt.pattern)} -> ${display(alt.term, xtended, opts)}`;\n\t},\n};\n\nconst Pat = {\n\tdisplay: (pat: EB.Pattern): string => {\n\t\treturn (\n\t\t\tmatch(pat)\n\t\t\t\t.with({ type: \"Lit\" }, ({ value }) => Lit.display(value))\n\t\t\t\t.with({ type: \"Var\" }, ({ value }) => `Imports.${value}`)\n\t\t\t\t.with({ type: \"Binder\" }, ({ value }) => value)\n\t\t\t\t// .with({ type: \"Wildcard\" }, () => \"_\")\n\t\t\t\t.with({ type: \"Row\" }, ({ row }) =>\n\t\t\t\t\tR.display({\n\t\t\t\t\t\tterm: Pat.display,\n\t\t\t\t\t\tvar: (v: string) => v,\n\t\t\t\t\t})(row),\n\t\t\t\t)\n\t\t\t\t.with({ type: \"Struct\" }, ({ row }) => {\n\t\t\t\t\tconst r = R.display({\n\t\t\t\t\t\tterm: Pat.display,\n\t\t\t\t\t\tvar: (v: string) => v,\n\t\t\t\t\t})(row);\n\t\t\t\t\treturn `Struct ${r}`;\n\t\t\t\t})\n\t\t\t\t.with({ type: \"Variant\" }, ({ row }) => {\n\t\t\t\t\tconst r = R.display({\n\t\t\t\t\t\tterm: Pat.display,\n\t\t\t\t\t\tvar: (v: string) => v,\n\t\t\t\t\t})(row);\n\t\t\t\t\treturn `Variant ${r}`;\n\t\t\t\t})\n\t\t\t\t.with({ type: \"List\" }, ({ patterns, rest }) => {\n\t\t\t\t\tconst pats = patterns.map(Pat.display).join(\", \");\n\t\t\t\t\tconst r = rest ? ` | ${rest}` : \"\";\n\t\t\t\t\treturn `[ ${pats}${r} ]`;\n\t\t\t\t})\n\t\t\t\t.with({ type: \"Wildcard\" }, () => \"_\")\n\t\t\t\t.otherwise(() => \"Pattern Display: Not implemented\")\n\t\t);\n\t},\n};\n\nconst Stmt = {\n\tdisplay: (stmt: EB.Statement, ctx: Pick<EB.Context, \"zonker\" | \"metas\" | \"env\">, opts = { deBruijn: false }): string => {\n\t\treturn match(stmt)\n\t\t\t.with({ type: \"Expression\" }, ({ value }) => display(value, ctx, opts))\n\t\t\t.with({ type: \"Let\" }, ({ variable, value, annotation }) => `let ${variable}\\n\\t: ${NF.display(annotation, ctx, opts)}\\n\\t= ${display(value, ctx, opts)}`)\n\t\t\t.otherwise(() => \"Statement Display: Not implemented\");\n\t},\n};\n\nexport const Display = {\n\tTerm: display,\n\tConstraint: displayConstraint,\n\tContext: displayContext,\n\tAlternative: Alt.display,\n\tPattern: Pat.display,\n\tStatement: Stmt.display,\n};\n"],"mappings":"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","names":["term"]}