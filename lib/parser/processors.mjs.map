{"version":3,"sources":["../../src/parser/processors.ts"],"sourcesContent":["import { Postprocessor, PostProcessor } from \"nearley\";\n\nimport type { Statement, Term, Variable, Row } from \"./terms\";\nimport * as Src from \"./terms\";\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\nimport * as R from \"@yap/shared/rows\";\n\nimport { Token } from \"moo\";\nimport { Literal } from \"@yap/shared/literals\";\nimport * as L from \"@yap/shared/literals\";\nimport { Implicitness } from \"@yap/shared/implicitness\";\nimport * as P from \"@yap/shared/provenance\";\nimport * as Null from \"@yap/utils\";\n\nimport * as F from \"fp-ts/function\";\nimport * as NEA from \"fp-ts/NonEmptyArray\";\n\ntype Sourced<T> = [T, P.Location];\nconst Sourced = {\n\tof: <T>(value: T, location: P.Location): Sourced<T> => [value, location],\n\tmap:\n\t\t<A, B>(f: (a: A) => B) =>\n\t\t([a, loc]: Sourced<A>): Sourced<B> => [f(a), loc],\n\tlocated:\n\t\t<A, B>(f: (a: A) => B) =>\n\t\t([a, loc]: Sourced<A>): P.WithLocation<B> => ({ ...f(a), location: loc }),\n\tfold:\n\t\t<A, B>(f: (a: A, loc: P.Location) => B) =>\n\t\t([a, loc]: Sourced<A>): B =>\n\t\t\tf(a, loc),\n};\n\n/***********************************************************\n * Primitive processors\n ***********************************************************/\nexport const Name: PostProcessor<[Token], Variable> = tok =>\n\tF.pipe(\n\t\ttok,\n\t\tsourceLoc,\n\t\tSourced.fold<unknown, Variable>((value, location) => {\n\t\t\tif (typeof value !== \"string\") {\n\t\t\t\tthrow new Error(\"Expected string value for var name\");\n\t\t\t}\n\t\t\treturn { type: \"name\", value, location };\n\t\t}),\n\t);\n\nexport const Label: PostProcessor<[Colon, Token], Variable> = ([, tok]) => {\n\treturn F.pipe(\n\t\t[tok],\n\t\tsourceLoc,\n\t\tSourced.fold<unknown, Variable>((value, location) => {\n\t\t\tif (typeof value !== \"string\") {\n\t\t\t\tthrow new Error(\"Expected string value for var name\");\n\t\t\t}\n\t\t\treturn { type: \"label\", value, location };\n\t\t}),\n\t);\n};\n\nexport const Str: PostProcessor<[Sourced<string>], Sourced<Literal>> = F.flow(\n\tNEA.head,\n\tSourced.map(value => ({ type: \"String\", value })),\n);\nexport const Num: PostProcessor<[Sourced<number>], Sourced<Literal>> = F.flow(\n\tNEA.head,\n\tSourced.map(value => ({ type: \"Num\", value })),\n);\nexport const Bool: PostProcessor<[Sourced<boolean>], Sourced<Literal>> = F.flow(\n\tNEA.head,\n\tSourced.map(value => ({ type: \"Bool\", value })),\n);\n\nexport const Type = (tok: Token): Sourced<Literal> => [L.Type(), { from: loc(tok) }];\nexport const Unit =\n\t(level: \"value\" | \"type\") =>\n\t(tok: Token): Sourced<Literal> => {\n\t\tconst l = { from: loc(tok) };\n\t\treturn level === \"value\" ? [L.unit(), l] : [L.Unit(), l];\n\t};\n\nexport const LitRow = (tok: Token): Sourced<Literal> => [L.Row(), { from: loc(tok) }];\n\nexport const Hole: PostProcessor<[Token], Term> = tok =>\n\tF.pipe(\n\t\ttok,\n\t\tsourceLoc,\n\t\tSourced.located(() => ({ type: \"hole\" })),\n\t);\n\nexport const Lit: PostProcessor<[Sourced<Literal>], Term> = ([[lit, location]]) => ({ type: \"lit\", value: lit, location });\n\n/***********************************************************\n * Var constructor\n ***********************************************************/\nexport const Var: PostProcessor<[Variable], Term> = ([v]) => ({ type: \"var\", variable: v, location: v.location });\n\n/***********************************************************\n * Application processors\n ***********************************************************/\nconst App = (fn: Term, arg: Term): Term => ({\n\ttype: \"application\",\n\tfn,\n\targ,\n\ticit: \"Explicit\",\n\tlocation: span(fn, arg),\n});\nexport const Application: PostProcessor<[Term, Whitespace, Term], Term> = ([fn, , arg]) => App(fn, arg);\n\nexport const Operation: PostProcessor<[Term, Whitespace, [Token], Whitespace, Term], Term> = data => {\n\tconst [lhs, , [op], , rhs] = data;\n\tconst op_ = Var([Name([op])]);\n\treturn App(App(op_, lhs), rhs);\n};\n\n/***********************************************************\n * Annotation processors\n ***********************************************************/\ntype Annotation = [] | [Token, Colon, Whitespace, Term];\n//| [Token, Colon, Whitespace, [Q.Multiplicity], Whitespace, Term];\n\nconst Annotate = (term: Term, ann: Term): Term => ({\n\ttype: \"annotation\",\n\tterm,\n\tann,\n\tlocation: span(term, ann),\n});\n\nexport const Annotation = ([term, ...rest]: [Term, ...Annotation]): Term => {\n\tif (rest.length === 0) {\n\t\tthrow new Error(\"Expected annotation\");\n\t}\n\n\tconst [, , , ann] = rest;\n\treturn Annotate(term, ann);\n\n\t// const q = rest[3][0];\n\t// const ann = rest[5];\n\t// return Annotate(term, ann, q);\n};\n\n/***********************************************************\n * Lambda processors\n ***********************************************************/\n\ntype Implicit = [Backslash, Param, Whitespace, Arrow, Whitespace, Term];\ntype Explicit = [Backslash, Param, Whitespace, Arrow, Whitespace, Term];\ntype Param = { type: \"param\"; binding: Variable; annotation?: Term };\n\nconst Lam = (icit: Implicitness, param: Param, body: Term): Term => ({\n\ttype: \"lambda\",\n\ticit,\n\tvariable: param.binding.value,\n\tannotation: param.annotation,\n\tbody,\n\tlocation: locSpan(param.binding.location, body.location),\n});\n\nexport const Lambda: (icit: Implicitness) => PostProcessor<[Backslash, Param, Whitespace, Arrow, Whitespace, Term], Term> =\n\ticit =>\n\t([, param, , , , body]) => {\n\t\treturn Lam(icit, param, body);\n\t};\n\nexport const Pi: (icit: Implicitness) => PostProcessor<[Term, Whitespace, Token, Whitespace, Term], Term> =\n\ticit =>\n\t([expr, , arr, , body]) => {\n\t\tif (expr.type === \"annotation\") {\n\t\t\tconst { term, ann } = expr;\n\n\t\t\tif (term.type !== \"var\") {\n\t\t\t\tthrow new Error(\"Expected variable in Pi binding\");\n\t\t\t}\n\n\t\t\tif (ann.type === \"annotation\") {\n\t\t\t\tthrow new Error(\"No cumulative annotations in Pi bindings allowed\");\n\t\t\t}\n\n\t\t\treturn { type: \"pi\", icit, variable: term.variable.value, annotation: ann, body, location: span(expr, body) };\n\t\t}\n\n\t\treturn { type: \"arrow\", lhs: expr, rhs: body, icit, location: span(expr, body) };\n\t};\n\nexport const Param = ([binding, ...ann]: [Variable, ...Annotation]): Param => {\n\tif (ann.length === 0) {\n\t\treturn {\n\t\t\ttype: \"param\",\n\t\t\tbinding,\n\t\t};\n\t}\n\n\tconst [, , , term] = ann;\n\treturn {\n\t\ttype: \"param\",\n\t\tbinding,\n\t\tannotation: term,\n\t};\n};\n\n/***********************************************************\n * Row related processors\n ***********************************************************/\ntype KeyVal = Sourced<[string, Term]>;\n\nexport const keyval = (pair: [Variable, Whitespace, Colon, Whitespace, Term]): KeyVal => {\n\tconst [v, , , , value] = pair;\n\treturn Sourced.of([v.value, value], locSpan(v.location, value.location));\n};\n\nexport const emptyRow = ([location]: [P.Location]): Term => ({ type: \"row\", location, row: { ...R.Constructors.Empty(), location } });\n\nexport const row: PostProcessor<[[KeyVal[], Variable?]], Term> = ([[pairs, v]]): Term => {\n\tif (pairs.length === 0) {\n\t\tthrow new Error(\"Expected at least one key-value pair in row\");\n\t}\n\n\tconst last = pairs[pairs.length - 1];\n\tconst tail: Row = !v ? { type: \"empty\", location: last[1] } : { type: \"variable\", variable: v, location: v.location };\n\tconst row = pairs.reduceRight<Row>((r, [[label, value], loc]) => ({ type: \"extension\", label, value, row: r, location: loc }), tail);\n\n\treturn { type: \"row\", row, location: locSpan(pairs[0][1], tail.location) };\n};\n\nexport const emptyStruct = ([location]: [P.Location]): Term => ({ type: \"struct\", location, row: { ...R.Constructors.Empty(), location } });\n\nexport const struct: PostProcessor<[[KeyVal[], Variable?]], Term> = ([[pairs, v]]) => {\n\tif (pairs.length === 0) {\n\t\tthrow new Error(\"Expected at least one key-value pair in struct\");\n\t}\n\n\tconst last = pairs[pairs.length - 1];\n\tconst tail: Row = v ? { type: \"variable\", variable: v, location: v.location } : { type: \"empty\", location: last[1] };\n\n\tconst row = pairs.reduceRight<Row>((acc, [[label, value], location]) => ({ type: \"extension\", label, value, row: acc, location }), tail);\n\treturn { type: \"struct\", row, location: locSpan(pairs[0][1], tail.location) };\n};\n\nexport const dict: PostProcessor<[[Space, [Space, Term], Space, Colon, Space, Term]], Term> = ([data]) => {\n\tconst [, [, index], , , , term] = data;\n\treturn { type: \"dict\", index, term, location: locSpan(index.location, term.location) };\n};\n\nexport const tagged: PostProcessor<[Colon, Variable, Whitespace, Term], Term> = ([tok, v, , tm]) => {\n\treturn {\n\t\ttype: \"tagged\",\n\t\ttag: v.value,\n\t\tterm: tm,\n\t\tlocation: locSpan({ from: loc(tok) }, tm.location),\n\t};\n};\n\ntype Tagged = Extract<Term, { type: \"tagged\" }>;\nexport const variant = (data: [Bar, Tagged[]] | [Tagged[]]): Term => {\n\tconst mkVariant = (terms: Tagged[]): Term => {\n\t\tconst last = terms[terms.length - 1];\n\t\tconst tail: Row = { type: \"empty\", location: last.location };\n\t\tconst row = terms.reduceRight<Row>((acc, tm) => {\n\t\t\treturn { type: \"extension\", label: tm.tag, value: tm.term, row: acc, location: tm.location };\n\t\t}, tail);\n\t\treturn { type: \"variant\", row, location: locSpan(terms[0].location, tail.location) };\n\t};\n\tif (data.length === 1) {\n\t\treturn mkVariant(data[0]);\n\t}\n\treturn mkVariant(data[1]);\n};\n\nexport const tuple: PostProcessor<[[Term[], Variable?]], Term> = ([[terms, v]]) => {\n\tif (terms.length === 0) {\n\t\tthrow new Error(\"Expected at least one term in tuple\");\n\t}\n\tconst last = terms[terms.length - 1];\n\tconst tail: Row = v ? { type: \"variable\", variable: v, location: v.location } : { type: \"empty\", location: last.location };\n\treturn {\n\t\ttype: \"tuple\",\n\t\trow: terms.reduceRight<Row>((row, value, i) => ({ type: \"extension\", label: i.toString(), value, row, location: value.location }), tail),\n\t\tlocation: locSpan(terms[0].location, last.location),\n\t};\n};\n\nexport const emptyList = ([location]: [P.Location]): Term => ({ type: \"list\", elements: [], location });\n\nexport const list: PostProcessor<[[Term[], Variable?]], Term> = ([[terms, v]]) => {\n\tif (terms.length === 0) {\n\t\tthrow new Error(\"Expected at least one term in list\");\n\t}\n\tconst last = terms[terms.length - 1];\n\n\treturn {\n\t\ttype: \"list\",\n\t\telements: terms,\n\t\trest: v,\n\t\tlocation: locSpan(terms[0].location, last.location),\n\t};\n};\n\n/***********************************************************\n * Injection & Projection processors\n ***********************************************************/\n\nexport const Projection: PostProcessor<[Term, Dot, Variable] | [Dot, Variable], Term> = (input: [Term, Dot, Variable] | [Dot, Variable]) => {\n\tconst project = (label: Variable, term: Term): Term => ({ type: \"projection\", label: label.value, term, location: locSpan(label.location, term.location) });\n\n\tif (input.length === 2) {\n\t\tconst [tok, label] = input;\n\t\tconst binding: Variable = { type: \"name\", value: \"x\", location: { from: loc(tok) } };\n\t\treturn Lam(\"Explicit\", { type: \"param\", binding }, project(label, Var([binding])));\n\t}\n\tconst [term, , label] = input;\n\treturn project(label, term);\n};\n\ntype Injection = [Whitespace, Term, Whitespace, Bar, KeyVal[]] | [Whitespace, Bar, KeyVal[]];\nexport const Injection: PostProcessor<[Injection], Term> = ([inj]) => {\n\tconst inject = ([[label, value], loc]: KeyVal, term: Term): Term => ({\n\t\ttype: \"injection\",\n\t\tlabel,\n\t\tvalue,\n\t\tterm,\n\t\tlocation: locSpan(loc, term.location),\n\t});\n\n\tif (inj.length === 3) {\n\t\tconst [, tok, pairs] = inj;\n\t\tconst binding: Variable = { type: \"name\", value: \"x\", location: { from: loc(tok) } };\n\t\tconst body = pairs.reduce((tm, kv) => inject(kv, tm), Var([binding]));\n\t\treturn Lam(\"Explicit\", { type: \"param\", binding }, body);\n\t}\n\n\tconst [, term, , , pairs] = inj;\n\treturn pairs.reduce((tm, kv) => inject(kv, tm), term);\n};\n\n/***********************************************************\n * Pattern matching processors\n ***********************************************************/\n\nexport const Match: PostProcessor<[Keyword, Whitespace, Term, Src.Alternative[]], Term> = ([tok, , term, alts]) => {\n\tif (alts.length === 0) {\n\t\tthrow new Error(\"Expected at least one alternative in pattern match\");\n\t}\n\treturn {\n\t\ttype: \"match\",\n\t\tscrutinee: term,\n\t\talternatives: alts,\n\t\tlocation: locSpan({ from: loc(tok) }, alts[alts.length - 1].location),\n\t};\n};\n\nexport const Alternative: PostProcessor<[Space, Bar, Space, Src.Pattern, Space, Arrow, Space, Term], Src.Alternative> = alt => {\n\tconst bar = alt[1];\n\tconst pat = alt[3];\n\tconst term = alt[7];\n\treturn {\n\t\tpattern: pat,\n\t\tterm,\n\t\tlocation: locSpan({ from: loc(bar) }, term.location),\n\t};\n};\n\ntype PatKeyVal = [string, Src.Pattern];\nexport const keyvalPat = (pair: [Variable, Whitespace, Colon, Whitespace, Src.Pattern]): PatKeyVal => {\n\tconst [v, , , , pat] = pair;\n\treturn [v.value, pat];\n};\n\ntype PatTagged = [string, Src.Pattern];\nexport const taggedPat = ([tok, v, , pat]: [Hash, Variable, Space, Src.Pattern]): PatTagged => {\n\treturn [v.value, pat];\n};\n\ntype RowPat = R.Row<Src.Pattern, Variable>;\nexport const Pattern = {\n\tVar: ([value]: [Variable]): Src.Pattern => ({ type: \"var\", value }),\n\tLit: ([[value]]: [Sourced<Literal>]): Src.Pattern => ({ type: \"lit\", value }),\n\tTuple: ([[terms, v]]: [[Src.Pattern[], Variable?]]): Src.Pattern => {\n\t\tconst tail: RowPat = !v ? { type: \"empty\" } : { type: \"variable\", variable: v };\n\t\tconst row = terms.reduceRight<RowPat>((row, value, i) => ({ type: \"extension\", label: i.toString(), value, row }), tail);\n\t\treturn { type: \"tuple\", row };\n\t},\n\tStruct: ([[pairs, v]]: [[PatKeyVal[], Variable?]]): Src.Pattern => {\n\t\tconst tail: RowPat = !v ? { type: \"empty\" } : { type: \"variable\", variable: v };\n\t\tconst row = pairs.reduceRight<RowPat>((acc, [label, value]) => ({ type: \"extension\", label, value, row: acc }), tail);\n\t\treturn { type: \"struct\", row };\n\t},\n\tList: ([[elements, v]]: [[Src.Pattern[], Variable?]]): Src.Pattern => {\n\t\treturn { type: \"list\", elements, rest: v };\n\t},\n\tRow: ([[pairs, v]]: [[PatKeyVal[], Variable?]]): Src.Pattern => {\n\t\tconst tail: RowPat = !v ? { type: \"empty\" } : { type: \"variable\", variable: v };\n\t\tconst row = pairs.reduceRight<RowPat>((acc, [label, value]) => ({ type: \"extension\", label, value, row: acc }), tail);\n\t\treturn { type: \"row\", row };\n\t},\n\n\tVariant: ([pats, last]: [[PatTagged, Space, Bar, Space][], PatTagged]): Src.Pattern => {\n\t\tconst tail: RowPat = { type: \"extension\", label: last[0], value: last[1], row: { type: \"empty\" } };\n\t\tconst row = pats.reduceRight<RowPat>((acc, [[label, value]]) => ({ type: \"extension\", label, value, row: acc }), tail);\n\t\treturn { type: \"variant\", row };\n\t},\n\tWildcard: ([tok]: [Token]): Src.Pattern => ({ type: \"wildcard\" }),\n\n\tEmpty: {\n\t\tList: (): Src.Pattern => ({ type: \"list\", elements: [] }),\n\t\tStruct: (): Src.Pattern => ({ type: \"struct\", row: { type: \"empty\" } }),\n\t},\n};\n\n/***********************************************************\n * Block processors\n ***********************************************************/\n\nexport const Block: PostProcessor<[[Statement[], SemiColon, Term?] | [Term]], Term> = ([input]) => {\n\tconst block = (statements: Statement[], ret?: Term): Term => {\n\t\tif (statements.length === 0 && !ret) {\n\t\t\tthrow new Error(\"Expected at least one statement in block\");\n\t\t}\n\n\t\tconst first = statements[0] || ret;\n\t\tconst location = locSpan(first.location, ret?.location || statements[statements.length - 1].location);\n\t\treturn { type: \"block\", statements, return: ret, location };\n\t};\n\n\tif (Array.isArray(input[0])) {\n\t\tconst [statements, , ret] = input;\n\t\treturn block(statements, ret || undefined); // Ensure ret is undefined and not null\n\t}\n\n\tconst [ret] = input;\n\treturn block([], ret);\n};\n\nexport const Return: PostProcessor<[Space, Keyword, Whitespace, Term, SemiColon], Term> = d => d[3];\n\nexport const Expr: PostProcessor<[Term], Statement> = ([value]) => ({ type: \"expression\", value, location: value.location });\n\nexport const Using: PostProcessor<[Keyword, Space, Term], Statement> = data => {\n\tif (data.length !== 3) {\n\t\tthrow new Error(\"Expected 4 elements in using statement. Renaming not yet implemented\");\n\t}\n\tconst [, , term] = data;\n\treturn { type: \"using\", value: term, location: term.location };\n};\n\nexport const Foreign: PostProcessor<[Keyword, Space, Variable, Space, Token, Space, Term], Statement> = data => {\n\tconst [, , variable, , , , term] = data;\n\treturn { type: \"foreign\", variable: variable.value, annotation: term, location: locSpan(variable.location, term.location) };\n};\n\ntype LetDec = [Keyword, Whitespace, Variable, ...Annotation, Space, Equals, Whitespace, Term];\nexport const LetDec: PostProcessor<LetDec, Statement> = ([, , variable, ...rest]: LetDec) => {\n\tconst letdec = (variable: Variable, value: Term, annotation?: Term, multiplicity?: Q.Multiplicity): Statement => ({\n\t\ttype: \"let\",\n\t\tvariable: variable.value,\n\t\tvalue,\n\t\tannotation,\n\t\tmultiplicity,\n\t\tlocation: locSpan(variable.location, value.location),\n\t});\n\n\tif (rest.length === 4) {\n\t\tconst [, , , value] = rest;\n\t\treturn letdec(variable, value);\n\t}\n\n\tif (rest.length === 8) {\n\t\tconst [, , , ann, , , , value] = rest;\n\t\treturn letdec(variable, value, ann);\n\t}\n\n\tconst q = rest[3][0];\n\tconst ann = rest[5];\n\tconst value = rest[9];\n\treturn letdec(variable, value, ann, q);\n};\n\n/***********************************************************\n * Modal processors\n ***********************************************************/\n\ntype Modal = [[Q.Multiplicity], Whitespace, Term] | [[Q.Multiplicity], Whitespace, Term, Whitespace, LAngle, Term, RAngle] | [Term, Whitespace, [Term]];\n\nexport const Modal: PostProcessor<Modal, Term> = (data: Modal): Term => {\n\tif (data.length === 7) {\n\t\tconst [[q], , term, , , liquid] = data;\n\n\t\treturn { type: \"modal\", term, modalities: { quantity: q, liquid }, location: term.location };\n\t}\n\n\tif (Array.isArray(data[0])) {\n\t\tconst [[q], , term] = data as [[Q.Multiplicity], Whitespace, Term];\n\t\treturn { type: \"modal\", term, modalities: { quantity: q }, location: term.location };\n\t}\n\n\tconst [term, , [liquid]] = data as [Term, Whitespace, [Term]];\n\treturn { type: \"modal\", term, modalities: { liquid }, location: locSpan(term.location, liquid.location) };\n};\n\n/***********************************************************\n * Module processors\n ***********************************************************/\n\nexport const script: PostProcessor<[Statement[], SemiColon, Newline], Src.Script> = ([statements]) => {\n\treturn { type: \"script\", script: statements };\n};\n\nexport const module_: PostProcessor<[Space, Src.Export, Src.Import[], Newline, Src.Script], Src.Module> = ([, exports, imports, , script]) => {\n\treturn { type: \"module\", imports, exports, content: script };\n};\n\nexport const exportSome: PostProcessor<[Keyword, Whitespace, Variable[], SemiColon], Src.Export> = ([, , variables]) => {\n\treturn { type: \"explicit\", names: variables.map(v => v.value) };\n};\n\nexport const exportAll: PostProcessor<[Keyword, Whitespace, Token, SemiColon], Src.Export> = () => {\n\treturn { type: \"*\" };\n};\n\nexport const importAll: PostProcessor<[Space, Keyword, Whitespace, Sourced<string>, SemiColon], Src.Import> = ([, , , str]) => {\n\treturn { type: \"*\", filepath: str[0], hiding: [] };\n};\n\nexport const importSome: PostProcessor<[Space, Keyword, Whitespace, Sourced<string>, Whitespace, Variable[], SemiColon], Src.Import> = ([\n\t,\n\t,\n\t,\n\tstr,\n\t,\n\tvars,\n]) => {\n\treturn { type: \"explicit\", filepath: str[0], names: vars.map(v => v.value) };\n};\n\n/***********************************************************\n * Macro processors\n ***********************************************************/\nexport const empty: PostProcessor<Token[], P.Location> = toks => {\n\tconst start = toks[0];\n\tconst end = toks[toks.length - 1];\n\n\treturn range(start, end);\n};\n\nexport const unwrap: <T>(arg: [Token, T[], Whitespace, Token]) => Sourced<T> = arg => {\n\tconst [l, [t], , r] = arg;\n\treturn [t, range(l, r)];\n};\n\nexport const many: <T>(arg: [Array<[Space, T[], Space, Token]>, Space, T]) => T[] = arg => {\n\tconst [arr, , t2] = arg;\n\n\tconst t1 = arr.flatMap(([, t]) => t);\n\treturn t1.concat(t2);\n};\n\nexport const enclosed = <T>([[t]]: [[T]]): T => t;\nexport const extract = <T>([[t]]: [[T]]): T => t;\n\n/***********************************************************\n * Location utilities\n ***********************************************************/\nexport const sourceLoc: (tok: [Token]) => Sourced<unknown> = ([tok]) => [tok.value, { from: loc(tok) }];\n\nconst loc = (tok: Token): P.LineCol => ({\n\tline: tok.line,\n\tcolumn: tok.col,\n\ttoken: tok,\n});\n\nconst range = (from: Token, to?: Token): P.Location => ({\n\tfrom: loc(from),\n\tto: Null.map(to, loc),\n});\n\nconst span = (t1: Term, t2: Term): P.Location => ({\n\tfrom: t1.location.from,\n\tto: t2.location.to || t2.location.from,\n});\n\nconst locSpan = (from: P.Location, to: P.Location): P.Location => ({\n\tfrom: from.from,\n\tto: to?.to || to?.from,\n});\n\n/***********************************************************\n * Token aliases\n ***********************************************************/\ntype LParens = Token;\ntype RParens = Token;\ntype LAngle = Token;\ntype RAngle = Token;\ntype Space = Token;\ntype Whitespace = Token;\ntype Newline = Token;\ntype Comma = Token;\ntype SemiColon = Token;\ntype Colon = Token;\ntype Backslash = Token;\ntype Hash = Token;\ntype Dot = Token;\ntype Arrow = Token;\ntype FatArrow = Token;\ntype Equals = Token;\ntype Bar = Token;\n\ntype LBrace = Token;\ntype RBrace = Token;\n\ntype Keyword = Token;\n"],"mappings":"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","names":["loc","row","label","term","pairs","ret","variable","value","ann","liquid","script"]}