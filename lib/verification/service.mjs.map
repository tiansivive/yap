{"version":3,"sources":["../../src/verification/service.ts"],"sourcesContent":["import * as EB from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport * as V2 from \"@yap/elaboration/shared/monad.v2\";\n\nimport * as A from \"fp-ts/Array\";\nimport * as E from \"fp-ts/Either\";\nimport * as F from \"fp-ts/function\";\n\nimport * as Q from \"@yap/shared/modalities/multiplicity\";\n\nimport * as Modal from \"@yap/verification/modalities/shared\";\nimport * as Row from \"@yap/shared/rows\";\n\nimport { match, P } from \"ts-pattern\";\nimport { Liquid } from \"./modalities\";\nimport { isEqual } from \"lodash\";\n\nimport { Sort, Context, Expr, IntNum, Bool, SMTArray } from \"z3-solver\";\nimport {\n\tOP_ADD,\n\tOP_AND,\n\tOP_DIV,\n\tOP_EQ,\n\tOP_GT,\n\tOP_GTE,\n\tOP_LT,\n\tOP_LTE,\n\tOP_MUL,\n\tOP_NEQ,\n\tOP_NOT,\n\tOP_OR,\n\tOP_SUB,\n\toperatorMap,\n\tPrimOps,\n} from \"@yap/shared/lib/primitives\";\n\nexport const VerificationService = (Z3: Context<\"main\">) => {\n\tconst Sorts = {\n\t\tInt: Z3.Int.sort(),\n\t\tNum: Z3.Real.sort(),\n\t\tBool: Z3.Bool.sort(),\n\t\tString: Z3.Sort.declare(\"String\"),\n\t\tUnit: Z3.Sort.declare(\"Unit\"),\n\t\tRow: Z3.Sort.declare(\"Row\"),\n\t\tAtom: Z3.Sort.declare(\"Atom\"),\n\t\tType: Z3.Sort.declare(\"Type\"),\n\n\t\tstringify: (sm: SortMap): string =>\n\t\t\tmatch(sm)\n\t\t\t\t.with({ Prim: P.select() }, p => p.name.toString())\n\t\t\t\t.with({ App: P.select() }, App => {\n\t\t\t\t\tconst [f, a] = App;\n\t\t\t\t\tconst fs = Sorts.stringify(f);\n\t\t\t\t\tconst as = Sorts.stringify(a);\n\t\t\t\t\treturn `App(${fs}, ${as})` as any;\n\t\t\t\t})\n\t\t\t\t.with({ Func: P.select() }, Func => {\n\t\t\t\t\tconst [a, body] = Func;\n\t\t\t\t\tconst as = Sorts.stringify(a);\n\t\t\t\t\tconst bs = Sorts.stringify(body);\n\t\t\t\t\treturn `(${as} -> ${bs})` as any;\n\t\t\t\t})\n\t\t\t\t.exhaustive(),\n\t};\n\n\t// TODO: simplify this algorithm and make it more understandable\n\tconst bumpAlpha = (s: string): string => {\n\t\t// assumes s is non-empty and only contains [a-z]\n\t\tlet carry = 1;\n\t\tlet res = \"\";\n\t\tfor (let i = s.length - 1; i >= 0; i--) {\n\t\t\tconst v = s.charCodeAt(i) - 97 + carry; // 'a' -> 0\n\t\t\tif (v >= 26) {\n\t\t\t\tres = \"a\" + res;\n\t\t\t\tcarry = 1;\n\t\t\t} else {\n\t\t\t\tres = String.fromCharCode(97 + v) + res;\n\t\t\t\tcarry = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (carry) {\n\t\t\tres = \"a\" + res;\n\t\t}\n\t\treturn res;\n\t};\n\n\tlet freshSeq = \"a\";\n\tconst freshName = () => {\n\t\tconst name = `$${freshSeq}`;\n\t\tfreshSeq = bumpAlpha(freshSeq);\n\t\treturn name;\n\t};\n\n\tconst check = (tm: EB.Term, ty: NF.Value): V2.Elaboration<Modal.Artefacts> =>\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconsole.log(`Checking: ${EB.Display.Term(tm, ctx)}\\nAgainst: ${NF.display(ty, ctx)}`);\n\t\t\tconst r = match([tm, NF.force(ctx, ty)])\n\t\t\t\t.with([{ type: \"Modal\" }, NF.Patterns.Type], ([tm, ty]) => check.gen(tm.term, ty))\n\t\t\t\t.with([{ type: \"Abs\" }, { type: \"Abs\", binder: { type: \"Pi\" } }], ([tm, ty]) =>\n\t\t\t\t\tV2.local(\n\t\t\t\t\t\tctx => EB.bind(ctx, { type: \"Lambda\", variable: tm.binding.variable }, ty.binder.annotation),\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tconst tyBody = NF.apply(ty.binder, ty.closure, NF.Constructors.Rigid(ctx.env.length));\n\t\t\t\t\t\t\tconst artefacts = yield* check.gen(tm.body, tyBody);\n\n\t\t\t\t\t\t\tconst modalities = extract(ty.binder.annotation, yield* V2.ask());\n\n\t\t\t\t\t\t\tconst [vu, ...usages] = artefacts.usages;\n\t\t\t\t\t\t\tyield* V2.tell(\"constraint\", { type: \"usage\", expected: modalities.quantity, computed: vu });\n\n\t\t\t\t\t\t\tconst sMap = mkSort(ty.binder.annotation, ctx);\n\t\t\t\t\t\t\tconst x = match(sMap)\n\t\t\t\t\t\t\t\t.with({ Prim: P.select() }, sort => Z3.Const(tm.binding.variable, sort))\n\t\t\t\t\t\t\t\t.with({ Func: P._ }, fn => Z3.Array.const(tm.binding.variable, ...(build(fn) as [Sort, ...Sort[], Sort])))\n\t\t\t\t\t\t\t\t.with({ App: P._ }, app => {\n\t\t\t\t\t\t\t\t\tconst sort = Z3.Sort.declare(build(app).join(\" \"));\n\t\t\t\t\t\t\t\t\treturn Z3.Const(tm.binding.variable, sort);\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.exhaustive();\n\n\t\t\t\t\t\t\tconst p = modalities.liquid;\n\t\t\t\t\t\t\tif (p.type !== \"Abs\") {\n\t\t\t\t\t\t\t\tthrow new Error(\"Liquid refinement must be a unary function\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst lvl = ctx.env.length;\n\t\t\t\t\t\t\tconst applied = NF.apply(p.binder, p.closure, NF.Constructors.Rigid(lvl));\n\t\t\t\t\t\t\tconst phi = translate(applied, ctx, { [lvl]: x }) as Bool;\n\n\t\t\t\t\t\t\tconst imp = Z3.ForAll([x], Z3.Implies(phi, artefacts.vc as Bool));\n\n\t\t\t\t\t\t\treturn { usages, vc: imp };\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.otherwise(function* ([tm, ty]) {\n\t\t\t\t\tconst [synthed, artefacts] = yield* synth.gen(tm);\n\t\t\t\t\t// Since verification runs after typechecking, we can assume that the term has at least the type we are checking against\n\t\t\t\t\t// Therefore, we can lift it to have the type we are checking against, with the added synthed liquid refinement\n\t\t\t\t\t// We Many as a dummy quantity, since it has no effect on subtyping\n\t\t\t\t\t// const synthed = NF.Constructors.Modal(ty, { quantity: Q.Many, liquid: artefacts.vc });\n\t\t\t\t\tconst checked = yield* subtype.gen(synthed, ty);\n\t\t\t\t\treturn { usages: artefacts.usages, vc: Z3.And(artefacts.vc as Bool, checked as Bool) };\n\t\t\t\t});\n\n\t\t\t// return r;\n\t\t\treturn yield* r;\n\t\t});\n\n\tcheck.gen = (tm: EB.Term, ty: NF.Value) => V2.pure(check(tm, ty));\n\n\ttype Synthed = [NF.Value, Modal.Artefacts];\n\tconst synth = (term: EB.Term): V2.Elaboration<Synthed> =>\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\tconst r = match(term)\n\t\t\t\t.with({ type: \"Var\", variable: { type: \"Bound\" } }, tm =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst entry = ctx.env[tm.variable.index];\n\n\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\tthrow new Error(\"Unbound variable in synth\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst [binder, , ty] = entry.type;\n\n\t\t\t\t\t\tconst modalities = extract(ty, ctx);\n\t\t\t\t\t\tconst zeros = A.replicate<Q.Multiplicity>(ctx.env.length, Q.Zero);\n\t\t\t\t\t\tconst usages = A.unsafeUpdateAt(tm.variable.index, modalities.quantity, zeros);\n\n\t\t\t\t\t\tconst v = NF.evaluate(ctx, tm);\n\t\t\t\t\t\tconst p = NF.reduce(modalities.liquid, v, \"Explicit\");\n\n\t\t\t\t\t\treturn [ty, { usages, vc: translate(p, ctx) }] satisfies Synthed; // TODO: probably need to strengthen the refinement with the literal here\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with({ type: \"Var\", variable: { type: \"Free\" } }, tm => {\n\t\t\t\t\tconst entry = ctx.imports[tm.variable.name];\n\n\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\tthrow new Error(`Unbound free variable: ${tm.variable.name}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst [t, ty, us] = entry;\n\t\t\t\t\tconst modalities = extract(ty, ctx);\n\n\t\t\t\t\t//const predicate = EB.Constructors.App(\"Explicit\", modalities.liquid, EB.Constructors.Var({ type: \"Free\", name: tm.variable.name }));\n\n\t\t\t\t\tconst p = NF.reduce(modalities.liquid, NF.evaluate(ctx, tm), \"Explicit\");\n\n\t\t\t\t\treturn V2.of([ty, { usages: us, vc: translate(p, ctx) }] satisfies Synthed);\n\t\t\t\t})\n\n\t\t\t\t.with({ type: \"Var\" }, tm => {\n\t\t\t\t\tconsole.warn(\"synth: Other variable types not implemented yet\");\n\t\t\t\t\treturn V2.of<Synthed>([NF.Any, { usages: Q.noUsage(ctx.env.length), vc: Z3.Bool.val(true) }]);\n\t\t\t\t})\n\t\t\t\t.with({ type: \"Lit\" }, tm =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst ann = match(tm.value)\n\t\t\t\t\t\t\t.with({ type: \"Atom\" }, l => EB.Constructors.Lit(l))\n\t\t\t\t\t\t\t.with({ type: \"Num\" }, l => EB.Constructors.Lit({ type: \"Atom\", value: \"Num\" }))\n\t\t\t\t\t\t\t.with({ type: \"String\" }, l => EB.Constructors.Lit({ type: \"Atom\", value: \"String\" }))\n\t\t\t\t\t\t\t.with({ type: \"Bool\" }, l => EB.Constructors.Lit({ type: \"Atom\", value: \"Bool\" }))\n\t\t\t\t\t\t\t.with({ type: \"unit\" }, l => EB.Constructors.Lit({ type: \"Atom\", value: \"Unit\" }))\n\t\t\t\t\t\t\t.exhaustive();\n\t\t\t\t\t\tconst nf = NF.evaluate(ctx, ann);\n\n\t\t\t\t\t\tconst bound = EB.Constructors.Var({ type: \"Bound\", index: 0 });\n\t\t\t\t\t\tconst fresh = freshName();\n\t\t\t\t\t\tconst closure = NF.Constructors.Closure(ctx, EB.DSL.eq(bound, tm));\n\t\t\t\t\t\tconst modalities = {\n\t\t\t\t\t\t\tquantity: Q.Many,\n\t\t\t\t\t\t\tliquid: NF.Constructors.Lambda(fresh, \"Explicit\", closure, nf),\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn [NF.Constructors.Modal(nf, modalities), { usages: Q.noUsage(ctx.env.length), vc: Z3.Bool.val(true) }] satisfies Synthed;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with({ type: \"Abs\" }, tm =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t// const modalities = extract(tm.binding.annotation);\n\n\t\t\t\t\t\tconst ann = NF.evaluate(ctx, tm.binding.annotation);\n\t\t\t\t\t\tconst [, bArtefacts] = yield* V2.local(_ctx => EB.bind(_ctx, { type: \"Pi\", variable: tm.binding.variable }, ann), synth(tm.body));\n\n\t\t\t\t\t\t//const vc = Modal.Verification.implication(NF.evaluate(ctx, modalities.liquid), bArtefacts.vc)\n\n\t\t\t\t\t\tconst icit = tm.binding.type === \"Lambda\" || tm.binding.type === \"Pi\" ? tm.binding.icit : \"Explicit\";\n\t\t\t\t\t\tconst type = NF.Constructors.Pi(tm.binding.variable, icit, ann, NF.Constructors.Closure(ctx, tm.body));\n\n\t\t\t\t\t\t// Note: trying to prevent lambdas from having refinements\n\t\t\t\t\t\treturn [type, { usages: bArtefacts.usages, vc: Z3.Bool.val(true) }] satisfies Synthed;\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with(EB.CtorPatterns.Struct, EB.CtorPatterns.Variant, EB.CtorPatterns.Schema, rowtype => {\n\t\t\t\t\t// TODO: Need to rework sigma env + row terms\n\t\t\t\t\t// We should cache types during elaboration by adding a new field `type` to each label in the row\n\t\t\t\t\t// QUESTION: Is there any advantage in optimizing row terms by adding specific term constructor instead of the App one?\n\t\t\t\t\tthrow new Error(\"synth: Row based verification not implemented yet\");\n\t\t\t\t})\n\t\t\t\t.with({ type: \"App\" }, tm =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst fn = yield* synth.gen(tm.func);\n\t\t\t\t\t\tconst [fnTy, fnArtefacts] = fn;\n\n\t\t\t\t\t\tconst forced = NF.force(ctx, fnTy);\n\t\t\t\t\t\tconst modalities = extract(forced, ctx);\n\t\t\t\t\t\tconst [out, usages, vc] = yield* V2.pure(\n\t\t\t\t\t\t\tmatch(forced)\n\t\t\t\t\t\t\t\t.with({ type: \"Abs\", binder: { type: \"Pi\" } }, ty =>\n\t\t\t\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\t\t\t\tconst checked = yield* check.gen(tm.arg, ty.binder.annotation);\n\t\t\t\t\t\t\t\t\t\tconst us = Q.add(fnArtefacts.usages, Q.multiply(modalities.quantity, checked.usages));\n\n\t\t\t\t\t\t\t\t\t\t// const applied = NF.reduce(checked.vc, NF.evaluate(ctx, tm.arg), \"Explicit\");\n\t\t\t\t\t\t\t\t\t\t// const vc = NF.DSL.Binop.and(fnArtefacts.vc, applied);\n\t\t\t\t\t\t\t\t\t\tconst vc = Z3.And(fnArtefacts.vc as Bool, checked.vc as Bool);\n\t\t\t\t\t\t\t\t\t\tconst nf = NF.evaluate(ctx, tm.arg);\n\t\t\t\t\t\t\t\t\t\tconst out = NF.apply(ty.binder, ty.closure, nf);\n\t\t\t\t\t\t\t\t\t\treturn [out, us, vc] as const;\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t.otherwise(ty => {\n\t\t\t\t\t\t\t\t\tconsole.error(\"Got: \", NF.display(ty, ctx));\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Impossible: Function type expected in application\");\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn [out, { usages, vc }] satisfies Synthed;\n\t\t\t\t\t}),\n\t\t\t\t)\n\n\t\t\t\t// .with({ type: \"Row\" }, tm =>\n\t\t\t\t//     V2.Do(\n\t\t\t\t//         R.fold(\n\t\t\t\t//             tm.row,\n\t\t\t\t//             (val, lbl, artefacts) =>\n\t\t\t\t//                 function* () {\n\t\t\t\t//                     const { usages, vc } = yield* synth.gen(val);\n\t\t\t\t//                     const accumulated = yield* artefacts();\n\n\t\t\t\t//                     return { usages: Q.add(accumulated.usages, usages), vc: NF.DSL.Binop.and(accumulated.vc, vc) } satisfies Modal.Artefacts;\n\t\t\t\t//                 },\n\t\t\t\t//             v => {\n\t\t\t\t//                 if (v.type === \"Bound\") {\n\t\t\t\t//                     const zeros = A.replicate<Q.Multiplicity>(v.index + 1, Q.Zero);\n\t\t\t\t//                     const usages = A.unsafeUpdateAt(v.index, ty.modalities.quantity, zeros);\n\t\t\t\t//                     return () => V2.lift<Modal.Artefacts>({ usages, vc: Liquid.Constants.tru });\n\t\t\t\t//                 }\n\n\t\t\t\t//                 if (v.type === \"Meta\") {\n\t\t\t\t//                     // metavariables are always zero in usage, as they will be substituted by some term later on\n\t\t\t\t//                     // TODO:FIXME: HAve zonker also hold modalities\n\t\t\t\t//                     return () => V2.lift<Modal.Artefacts>({ usages: [Q.Zero], vc: Liquid.Constants.tru });\n\t\t\t\t//                 }\n\n\t\t\t\t//                 throw new Error(\"Row variable not implemented yet\");\n\t\t\t\t//             },\n\t\t\t\t//             () => V2.lift<Modal.Artefacts>({ usages: [Q.Zero], vc: Liquid.Constants.tru }),\n\t\t\t\t//         ),\n\t\t\t\t//     ),\n\t\t\t\t// )\n\t\t\t\t.with({ type: \"Block\" }, block => {\n\t\t\t\t\tconst recurse = (stmts: EB.Statement[], results: Modal.Artefacts[]): V2.Elaboration<Synthed> =>\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tif (stmts.length === 0) {\n\t\t\t\t\t\t\t\treturn yield* synth.gen(block.return);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst [current, ...rest] = stmts;\n\t\t\t\t\t\t\tif (current.type === \"Expression\") {\n\t\t\t\t\t\t\t\tconst synthed = yield* synth.gen(current.value);\n\t\t\t\t\t\t\t\tconst r = yield* V2.pure(recurse(rest, [...results, synthed[1]]));\n\t\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (current.type !== \"Let\") {\n\t\t\t\t\t\t\t\treturn yield* V2.pure(recurse(rest, [...results]));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn yield* V2.local(\n\t\t\t\t\t\t\t\tctx => EB.bind(ctx, { type: \"Let\", variable: current.variable }, current.annotation),\n\t\t\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\t\t\tconst artefacts = yield* check.gen(current.value, current.annotation);\n\t\t\t\t\t\t\t\t\tconst [ty, conj] = yield* V2.pure(recurse(rest, [...results, artefacts]));\n\n\t\t\t\t\t\t\t\t\treturn [ty, { usages: conj.usages, vc: Z3.And(artefacts.vc as Bool, conj.vc as Bool) }] satisfies Synthed;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\n\t\t\t\t\treturn recurse(block.statements, []);\n\t\t\t\t})\n\t\t\t\t.otherwise(() => {\n\t\t\t\t\tconsole.warn(\"synth: Not implemented yet\");\n\t\t\t\t\treturn V2.of<Synthed>([NF.Any, { usages: Q.noUsage(0), vc: Z3.Bool.val(true) }]);\n\t\t\t\t});\n\t\t\tconst ret = yield* V2.pure(r);\n\t\t\treturn ret;\n\t\t});\n\tsynth.gen = (tm: EB.Term) => V2.pure(synth(tm));\n\n\tconst extract = (nf: NF.Value, ctx: EB.Context): NF.Modalities =>\n\t\tmatch(nf)\n\t\t\t.with({ type: \"Modal\" }, m => m.modalities)\n\t\t\t.otherwise(() => ({\n\t\t\t\tquantity: Q.Many,\n\t\t\t\tliquid: Liquid.Predicate.NeutralNF(NF.Constructors.Lit({ type: \"Atom\", value: \"Unit\" }), ctx),\n\t\t\t}));\n\n\tconst subtype = (a: NF.Value, b: NF.Value): V2.Elaboration<Modal.Artefacts[\"vc\"]> =>\n\t\tV2.Do(function* () {\n\t\t\tconst ctx = yield* V2.ask();\n\t\t\tconst s = match([NF.unwrapNeutral(a), NF.unwrapNeutral(b)])\n\t\t\t\t.with([NF.Patterns.Flex, P._], ([meta, t]) => {\n\t\t\t\t\tconst ty = ctx.zonker[meta.variable.val];\n\n\t\t\t\t\tif (!ty) {\n\t\t\t\t\t\tthrow new Error(\"Unbound meta variable in subtype\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn subtype(ty, t);\n\t\t\t\t})\n\t\t\t\t.with([P._, NF.Patterns.Flex], ([t, meta]) => {\n\t\t\t\t\tconst ty = ctx.zonker[meta.variable.val];\n\n\t\t\t\t\tif (!ty) {\n\t\t\t\t\t\tthrow new Error(\"Unbound meta variable in subtype\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn subtype(t, ty);\n\t\t\t\t})\n\t\t\t\t.with(\n\t\t\t\t\t[NF.Patterns.Rigid, P._],\n\t\t\t\t\t([rigid, t]) => t.type !== \"Var\" || t.variable.type !== \"Bound\" || rigid.variable.lvl !== t.variable.lvl,\n\t\t\t\t\t([{ variable }, bt]) =>\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tconst ty = ctx.env[variable.lvl];\n\n\t\t\t\t\t\t\tif (!ty) {\n\t\t\t\t\t\t\t\tthrow new Error(\"Unbound variable in subtype\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn yield* subtype.gen(ty.nf, bt);\n\t\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with(\n\t\t\t\t\t[P._, NF.Patterns.Rigid],\n\t\t\t\t\t([at, { variable }]) => at.type !== \"Var\" || at.variable.type !== \"Bound\" || variable.lvl !== at.variable.lvl,\n\t\t\t\t\t([at, { variable }]) =>\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tconst ty = ctx.env[variable.lvl];\n\n\t\t\t\t\t\t\tif (!ty) {\n\t\t\t\t\t\t\t\tthrow new Error(\"Unbound variable in subtype\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn yield* subtype.gen(at, ty.nf);\n\t\t\t\t\t\t}),\n\t\t\t\t)\n\n\t\t\t\t.with([NF.Patterns.Schema, NF.Patterns.Schema], ([{ arg: a }, { arg: b }]) => {\n\t\t\t\t\treturn contains(b.row, a.row);\n\t\t\t\t})\n\t\t\t\t.with([NF.Patterns.Variant, NF.Patterns.Variant], ([{ arg: a }, { arg: b }]) => {\n\t\t\t\t\treturn contains(a.row, b.row);\n\t\t\t\t})\n\t\t\t\t.with([{ type: \"Modal\" }, { type: \"Modal\" }], ([at, bt]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst ctx = yield* V2.ask();\n\n\t\t\t\t\t\t// 1) Base type subtyping VC (ensures underlying types are compatible)\n\t\t\t\t\t\tconst baseVc = yield* subtype.gen(at.value, bt.value);\n\n\t\t\t\t\t\t// 2) Evaluate both liquid predicates to NF.Abs under the current context\n\t\t\t\t\t\tconst pAt = at.modalities.liquid;\n\t\t\t\t\t\tconst pBt = bt.modalities.liquid;\n\t\t\t\t\t\tif (pAt.type !== \"Abs\" || pBt.type !== \"Abs\") {\n\t\t\t\t\t\t\tthrow new Error(\"Liquid refinements must be unary functions\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 3) Apply both to a fresh rigid at the current level (no context extension)\n\t\t\t\t\t\tconst lvl = ctx.env.length;\n\t\t\t\t\t\tconst appliedAt = NF.apply(pAt.binder, pAt.closure, NF.Constructors.Rigid(lvl));\n\t\t\t\t\t\tconst appliedBt = NF.apply(pBt.binder, pBt.closure, NF.Constructors.Rigid(lvl));\n\n\t\t\t\t\t\t// 4) Create the Z3 quantified variable with the primitive sort of the base type\n\t\t\t\t\t\tconst sortMap = mkSort(at.value, ctx);\n\t\t\t\t\t\tconst xSort = match(sortMap)\n\t\t\t\t\t\t\t.with({ Prim: P.select() }, p => p)\n\t\t\t\t\t\t\t.otherwise(() => {\n\t\t\t\t\t\t\t\tthrow new Error(\"Only primitive types can be used in logical formulas\");\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tconst fresh = freshName();\n\t\t\t\t\t\tconst x = Z3.Const(fresh, xSort);\n\n\t\t\t\t\t\t// 5) Translate with a rigids map so the fresh rigid maps to the quantifier\n\t\t\t\t\t\t// TODO:FIXME: Use free variables instead of rigids. Add a new translation environment for them in the context\n\t\t\t\t\t\tconst rigids = { [lvl]: x } as Record<number, Expr>;\n\t\t\t\t\t\tconst phiAt = translate(appliedAt, ctx, rigids) as Bool;\n\t\t\t\t\t\tconst phiBt = translate(appliedBt, ctx, rigids) as Bool;\n\n\t\t\t\t\t\t// 6) Forall x. phiAt(x) => phiBt(x), conjoined with the base VC\n\t\t\t\t\t\tconst forall: Bool = Z3.ForAll([x], Z3.Implies(phiAt, phiBt));\n\t\t\t\t\t\treturn Z3.And(baseVc as Bool, forall);\n\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([{ type: \"Modal\" }, P._], ([at, bt]) => subtype(at, NF.Constructors.Modal(bt, { quantity: Q.Zero, liquid: Liquid.Predicate.NeutralNF(bt, ctx) })))\n\t\t\t\t.with([P._, { type: \"Modal\" }], ([at, bt]) => subtype(NF.Constructors.Modal(at, { quantity: Q.Many, liquid: Liquid.Predicate.NeutralNF(at, ctx) }), bt))\n\n\t\t\t\t.with(\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: \"Abs\", binder: { type: \"Pi\" } },\n\t\t\t\t\t\t{ type: \"Abs\", binder: { type: \"Pi\" } },\n\t\t\t\t\t],\n\t\t\t\t\t([at, bt]) =>\n\t\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\t\tconst vcArg = yield* subtype.gen(bt.binder.annotation, at.binder.annotation); // contravariant position\n\n\t\t\t\t\t\t\tconst ctx = yield* V2.ask();\n\t\t\t\t\t\t\tconst anf = NF.apply(at.binder, at.closure, NF.Constructors.Rigid(ctx.env.length));\n\t\t\t\t\t\t\tconst bnf = NF.apply(bt.binder, bt.closure, NF.Constructors.Rigid(ctx.env.length));\n\n\t\t\t\t\t\t\tconst vcBody = yield* subtype.gen(anf, bnf); // covariant position\n\n\t\t\t\t\t\t\tconst vc = Z3.Implies(vcArg as Bool, vcBody as Bool);\n\t\t\t\t\t\t\treturn vc;\n\t\t\t\t\t\t}),\n\t\t\t\t)\n\t\t\t\t.with([NF.Patterns.Lit, NF.Patterns.Lit], ([{ value: v1 }, { value: v2 }]) => {\n\t\t\t\t\treturn V2.of(Z3.Bool.val(isEqual(v1, v2)));\n\t\t\t\t})\n\t\t\t\t.otherwise(([a, b]) =>\n\t\t\t\t\tV2.Do(function* () {\n\t\t\t\t\t\tconst ctx = yield* V2.ask();\n\t\t\t\t\t\tconsole.warn(\"Subtype not fully implemented yet\");\n\t\t\t\t\t\tconsole.log(\"A:\", NF.display(a, ctx));\n\t\t\t\t\t\tconsole.log(a);\n\t\t\t\t\t\tconsole.log(\"B:\", NF.display(b, ctx));\n\t\t\t\t\t\tconsole.log(b);\n\t\t\t\t\t\tconsole.log(ctx.zonker);\n\t\t\t\t\t\treturn Z3.Bool.val(false);\n\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t// return s as Modal.Annotations[\"liquid\"];\n\t\t\tconst r = yield* V2.pure(s);\n\t\t\treturn r;\n\t\t});\n\tsubtype.gen = (a: NF.Value, b: NF.Value) => V2.pure(subtype(a, b));\n\n\tconst contains = (a: NF.Row, b: NF.Row) => {\n\t\tconst onVal = (v: NF.Value, lbl: string, conj: V2.Elaboration<Modal.Artefacts[\"vc\"]>): V2.Elaboration<Modal.Artefacts[\"vc\"]> => {\n\t\t\tconst ra = Row.rewrite(a, lbl, v => E.left({ tag: \"Other\", message: `Could not rewrite row. Label ${lbl} not found.` }));\n\t\t\treturn F.pipe(\n\t\t\t\tra,\n\t\t\t\tE.fold(\n\t\t\t\t\terr => V2.Do<Modal.Artefacts[\"vc\"], any>(() => V2.fail({ type: \"MissingLabel\", label: lbl, row: a })),\n\t\t\t\t\trewritten => {\n\t\t\t\t\t\tif (rewritten.type !== \"extension\") {\n\t\t\t\t\t\t\tthrow new Error(\"Verification Subtyping: Expected extension after rewriting row\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn V2.Do(function* () {\n\t\t\t\t\t\t\tconst accumulated = yield* V2.pure(conj);\n\t\t\t\t\t\t\tconst vc = yield* subtype.gen(v, rewritten.value);\n\t\t\t\t\t\t\treturn Z3.And(accumulated as Bool, vc as Bool);\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t);\n\t\t};\n\t\treturn Row.fold(b, onVal, (rv, acc) => acc, V2.of(Z3.Bool.val(true) satisfies Modal.Artefacts[\"vc\"]));\n\t};\n\tconst mkFunction = (val: NF.Value, ctx: EB.Context): SMTArray<\"main\", [Sort<\"main\">, ...Sort<\"main\">[]], Sort<\"main\">> => {\n\t\treturn match(val)\n\t\t\t.with(NF.Patterns.Var, ({ variable }) => {\n\t\t\t\tconst getNameAndType = (variable: NF.Variable) => {\n\t\t\t\t\tif (variable.type === \"Bound\") {\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\ttype: [, , type],\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t} = ctx.env[EB.lvl2idx(ctx, variable.lvl)];\n\t\t\t\t\t\treturn { name: name.variable, type };\n\t\t\t\t\t}\n\t\t\t\t\tif (variable.type === \"Free\") {\n\t\t\t\t\t\tconst [, type] = ctx.imports[variable.name];\n\t\t\t\t\t\treturn { name: variable.name, type };\n\t\t\t\t\t}\n\t\t\t\t\tif (variable.type === \"Label\") {\n\t\t\t\t\t\tconst { ann } = ctx.sigma[variable.name];\n\t\t\t\t\t\treturn { name: variable.name, type: ann };\n\t\t\t\t\t}\n\t\t\t\t\tif (variable.type === \"Foreign\") {\n\t\t\t\t\t\tif (!(variable.name in PrimOps)) {\n\t\t\t\t\t\t\tthrow new Error(\"MKFunc: Foreign variables should not appear in logical formulas\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst [, type] = ctx.imports[operatorMap[variable.name]];\n\t\t\t\t\t\treturn { name: variable.name, type };\n\t\t\t\t\t}\n\t\t\t\t\tif (variable.type === \"Meta\") {\n\t\t\t\t\t\tconst m = ctx.metas[variable.val];\n\t\t\t\t\t\tif (!m) {\n\t\t\t\t\t\t\tthrow new Error(\"MKFunc: Meta variables should not appear in logical formulas\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { name: `?${variable.val}`, type: m.ann };\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\"MKFunc: Unknown variable type\");\n\t\t\t\t};\n\n\t\t\t\tconst { name, type } = getNameAndType(variable);\n\t\t\t\tconst sort = mkSort(type, ctx);\n\t\t\t\tconst all = build(sort) as [Sort, ...Sort[], Sort];\n\t\t\t\tconst f = Z3.Array.const(name, ...all);\n\t\t\t\treturn f;\n\t\t\t})\n\t\t\t.with(NF.Patterns.App, a => mkFunction(a.func, ctx))\n\t\t\t.with({ type: \"External\" }, e => {\n\t\t\t\tif (e.args.length !== e.arity) {\n\t\t\t\t\tthrow new Error(\"External with wrong arity in logical formulas\");\n\t\t\t\t}\n\t\t\t\tconst args = e.args.flatMap(arg => build(mkSort(arg, ctx))) as [Sort, ...Sort[], Sort];\n\n\t\t\t\tconst f = Z3.Array.const(e.name, ...args);\n\t\t\t\treturn f;\n\t\t\t})\n\t\t\t.with({ type: \"Abs\" }, a => {\n\t\t\t\tthrow new Error(\"Function literals not supported in logical formulas\");\n\t\t\t})\n\t\t\t.otherwise(() => {\n\t\t\t\tthrow new Error(\"Not a function\");\n\t\t\t});\n\t};\n\n\tconst translate = (nf: NF.Value, ctx: EB.Context, rigids: Record<number, Expr> = {}): Expr => {\n\t\tconst collectArgs = (value: NF.Value, ctx: EB.Context): Expr[] => {\n\t\t\treturn match(value)\n\t\t\t\t.with(NF.Patterns.App, ({ func, arg }) => {\n\t\t\t\t\tconst fs = collectArgs(func, ctx);\n\t\t\t\t\tconst a = translate(arg, ctx, rigids);\n\t\t\t\t\treturn fs.concat(a);\n\t\t\t\t})\n\t\t\t\t.otherwise(() => [translate(value, ctx, rigids)]);\n\t\t};\n\n\t\tconst r = match(nf)\n\t\t\t.with({ type: \"Neutral\" }, n => translate(n.value, ctx, rigids))\n\t\t\t.with({ type: \"Modal\" }, m => translate(m.value, ctx, rigids))\n\t\t\t.with(NF.Patterns.Lit, l =>\n\t\t\t\tmatch(l.value)\n\t\t\t\t\t.with({ type: \"Num\" }, l => Z3.Real.val(l.value))\n\t\t\t\t\t.with({ type: \"Bool\" }, l => Z3.Bool.val(l.value))\n\t\t\t\t\t.with({ type: \"String\" }, l => {\n\t\t\t\t\t\tthrow new Error(\"String literals not supported yet\");\n\t\t\t\t\t})\n\t\t\t\t\t.with({ type: \"unit\" }, l => Z3.Const(\"unit\", Sorts.Unit))\n\n\t\t\t\t\t.with({ type: \"Atom\" }, atom => Z3.Const(atom.value, Sorts.Atom))\n\t\t\t\t\t.exhaustive(),\n\t\t\t)\n\t\t\t.with(NF.Patterns.Row, r => {\n\t\t\t\tthrow new Error(\"Row literals not supported yet\");\n\t\t\t})\n\t\t\t.with({ type: \"Abs\" }, a => {\n\t\t\t\tthrow new Error(\"Function literals not supported in logical formulas\");\n\t\t\t})\n\t\t\t.with(NF.Patterns.App, fn => {\n\t\t\t\tconst f = mkFunction(fn.func, ctx);\n\t\t\t\tconst [, ...args] = collectArgs(fn, ctx);\n\n\t\t\t\tconst call = f.select(args[0], ...args.slice(1));\n\t\t\t\treturn call;\n\t\t\t})\n\t\t\t.with(NF.Patterns.Var, v => {\n\t\t\t\tif (v.variable.type === \"Bound\") {\n\t\t\t\t\t// If this level is in the rigids map, use the quantified variable directly\n\t\t\t\t\tconst mapped = rigids[v.variable.lvl];\n\n\t\t\t\t\tif (mapped) {\n\t\t\t\t\t\treturn mapped;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tnf,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttype: [, , type],\n\t\t\t\t\t} = ctx.env[EB.lvl2idx(ctx, v.variable.lvl)];\n\t\t\t\t\tconst all = build(mkSort(type, ctx));\n\t\t\t\t\tconst sort = all.length === 1 ? all[0] : Z3.Sort.declare(all.join(\" -> \"));\n\t\t\t\t\treturn Z3.Const(name.variable, sort);\n\t\t\t\t}\n\t\t\t\tif (v.variable.type === \"Free\") {\n\t\t\t\t\tconst [a] = ctx.imports[v.variable.name];\n\t\t\t\t\treturn translate(NF.evaluate(ctx, a), ctx, rigids);\n\t\t\t\t}\n\t\t\t\tif (v.variable.type === \"Label\") {\n\t\t\t\t\tconst { nf } = ctx.sigma[v.variable.name];\n\t\t\t\t\treturn translate(nf, ctx, rigids);\n\t\t\t\t}\n\t\t\t\tif (v.variable.type === \"Foreign\") {\n\t\t\t\t\tthrow new Error(\"Translation Error: Foreign variables should not appear in logical formulas\");\n\t\t\t\t}\n\t\t\t\tif (v.variable.type === \"Meta\") {\n\t\t\t\t\tthrow new Error(\"Translation Error: Meta variables should not appear in logical formulas\");\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Translation Error: Unknown variable type\");\n\t\t\t})\n\t\t\t.with({ type: \"External\" }, e => {\n\t\t\t\tif (e.args.length !== e.arity) {\n\t\t\t\t\tthrow new Error(\"External with wrong arity in logical formulas\");\n\t\t\t\t}\n\t\t\t\tconst args = e.args.map(arg => translate(arg, ctx, rigids));\n\t\t\t\tconst r = (() => {\n\t\t\t\t\tif (e.name === OP_ADD) {\n\t\t\t\t\t\treturn (args[0] as IntNum).add(args[1] as IntNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_SUB) {\n\t\t\t\t\t\treturn (args[0] as IntNum).sub(args[1] as IntNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_MUL) {\n\t\t\t\t\t\treturn (args[0] as IntNum).mul(args[1] as IntNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_DIV) {\n\t\t\t\t\t\treturn (args[0] as IntNum).div(args[1] as IntNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_AND) {\n\t\t\t\t\t\treturn Z3.And(args[0] as Bool, args[1] as Bool);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_OR) {\n\t\t\t\t\t\treturn Z3.Or(args[0] as Bool, args[1] as Bool);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_NOT) {\n\t\t\t\t\t\treturn (args[0] as Bool).not();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_EQ) {\n\t\t\t\t\t\treturn args[0].eq(args[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_NEQ) {\n\t\t\t\t\t\treturn args[0].neq(args[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_GT) {\n\t\t\t\t\t\treturn (args[0] as IntNum).gt(args[1] as IntNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_GTE) {\n\t\t\t\t\t\treturn (args[0] as IntNum).ge(args[1] as IntNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_LT) {\n\t\t\t\t\t\treturn (args[0] as IntNum).lt(args[1] as IntNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e.name === OP_LTE) {\n\t\t\t\t\t\treturn (args[0] as IntNum).le(args[1] as IntNum);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(`Unknown external function in logical formulas: ${e.name}`);\n\t\t\t\t})();\n\t\t\t\treturn r;\n\t\t\t})\n\t\t\t.otherwise(x => {\n\t\t\t\tthrow new Error(\"Unknown expression type\");\n\t\t\t});\n\n\t\treturn r;\n\n\t\t// const a = Z3.Datatype(\"String\")\n\t\t// a.declare(\"mkString\");\n\t\t// a.create()\n\n\t\t// const x = Z3.Int.const('x');\n\t\t// const A = Z3.Sort.declare(\"A\")\n\n\t\t// const implication = Z3.Implies(x.ge(5), x.gt(10));\n\t\t// Z3.solve(Z3.And(x.ge(10), x.le(9)));\n\t};\n\n\ttype SortMap = { Prim: Sort } | { Func: SortMap[] } | { App: SortMap[] };\n\t// TODO: get rid of SortMap and return a Sort directly from mkSort. Update all callsites accordingly\n\tconst mkSort = (nf: NF.Value, ctx: EB.Context): SortMap => {\n\t\tconst s = match(nf)\n\t\t\t.with({ type: \"Neutral\" }, n => mkSort(n.value, ctx))\n\t\t\t.with({ type: \"Modal\" }, m => mkSort(m.value, ctx))\n\t\t\t.with(\n\t\t\t\tNF.Patterns.Lit,\n\t\t\t\tl =>\n\t\t\t\t\tmatch(l.value)\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t.with({ type: \"Atom\" }, ({ value }) => ({ Prim: Sorts[value] || Sorts.Atom }))\n\t\t\t\t\t\t.otherwise(_ => {\n\t\t\t\t\t\t\tthrow new Error(\"Unknown literal type\");\n\t\t\t\t\t\t}),\n\t\t\t\t// .exhaustive()\n\t\t\t)\n\t\t\t.with(NF.Patterns.Row, r => ({ Prim: Sorts.Row }))\n\t\t\t.with(NF.Patterns.App, ({ func, arg }) => ({ App: [mkSort(func, ctx), mkSort(arg, ctx)] }))\n\t\t\t.with({ type: \"Abs\" }, ({ binder, closure }) => {\n\t\t\t\tconst body = NF.apply(binder, closure, NF.Constructors.Rigid(ctx.env.length));\n\t\t\t\tconst argSort = mkSort(binder.annotation, ctx);\n\t\t\t\tconst retSort = mkSort(body, ctx);\n\t\t\t\treturn { Func: [argSort, retSort] };\n\t\t\t})\n\t\t\t.with({ type: \"External\" }, e => {\n\t\t\t\treturn { Prim: Z3.Sort.declare(`External:${e.name}`) };\n\t\t\t})\n\t\t\t.with(NF.Patterns.Var, v => {\n\t\t\t\tconst { type } = v.variable;\n\n\t\t\t\tif (type === \"Bound\") {\n\t\t\t\t\treturn mkSort(ctx.env[v.variable.lvl].nf, ctx);\n\t\t\t\t}\n\n\t\t\t\tif (type === \"Meta\") {\n\t\t\t\t\tconst ty = ctx.zonker[v.variable.val];\n\t\t\t\t\tif (!ty) {\n\t\t\t\t\t\tthrow new Error(\"Unconstrained meta variable in verification\");\n\t\t\t\t\t}\n\t\t\t\t\treturn mkSort(ty, ctx);\n\t\t\t\t}\n\n\t\t\t\tif (type === \"Free\") {\n\t\t\t\t\treturn { Prim: Z3.Sort.declare(v.variable.name) };\n\t\t\t\t}\n\n\t\t\t\tif (type === \"Foreign\") {\n\t\t\t\t\treturn { Prim: Z3.Sort.declare(v.variable.name) };\n\t\t\t\t}\n\n\t\t\t\tif (type === \"Label\") {\n\t\t\t\t\treturn { Prim: Z3.Sort.declare(v.variable.name) };\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(\"Could not create sort from variable\");\n\t\t\t})\n\t\t\t.exhaustive();\n\t\treturn s;\n\t};\n\n\tconst build = (s: SortMap): Sort[] =>\n\t\tmatch(s)\n\t\t\t.with({ Prim: P.select() }, p => [p])\n\t\t\t.with({ App: P.select() }, App => {\n\t\t\t\tconst [f, a] = App;\n\t\t\t\tconst fs = build(f).map(s => s.name);\n\t\t\t\tconst as = build(a).map(s => s.name);\n\n\t\t\t\tconst sort = Z3.Sort.declare(`App(${fs.join(\",\")}, ${as.join(\",\")})`);\n\t\t\t\treturn [sort];\n\t\t\t})\n\t\t\t.with({ Func: P.select() }, Func => {\n\t\t\t\tconst [a, body] = Func;\n\t\t\t\tconst as = build(a);\n\t\t\t\tconst bs = build(body);\n\t\t\t\treturn as.concat(bs);\n\t\t\t})\n\t\t\t.exhaustive();\n\n\treturn { check, synth, subtype };\n};\n"],"mappings":"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","names":["tm","ty","ctx","vc","out","r","a","b","v","variable","type","name","l","nf","s"]}