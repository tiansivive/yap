{"version":3,"sources":["../../../src/verification/modalities/shared.ts"],"sourcesContent":["import * as Q from \"@yap/shared/modalities/multiplicity\";\nimport * as EB from \"@yap/elaboration\";\nimport * as NF from \"@yap/elaboration/normalization\";\nimport { Solver, Expr } from \"z3-solver\";\n\nexport type Annotations = {\n\tquantity: Q.Multiplicity;\n\tliquid: EB.Term;\n};\n\nexport type Artefacts = {\n\t/** Usage information for each variable in the context */\n\tusages: Q.Usages;\n\t/** Verification Condition */\n\tvc: Expr;\n};\n\nexport const Verification = {\n\timplication: (p: NF.Value, q: NF.Value): NF.Value => NF.DSL.Binop.or(NF.DSL.Unop.not(p), q),\n\n\timply: (ctx: EB.Context, ann: NF.Value, p: EB.Term, q: NF.Value): NF.Value => {\n\t\t// const head = NF.reduce(p, NF.Constructors.Var({ type: \"Bound\", lvl: ctx.env.length -1}), \"Explicit\");\n\t\t// const body = Verification.implication(head, q);\n\n\t\tconst x = EB.Constructors.Var({ type: \"Bound\", index: 0 });\n\t\tconst tm = EB.Constructors.App(\"Explicit\", p, x);\n\n\t\tconst extended = EB.bind(ctx, { type: \"Lambda\", variable: \"$x\" }, ann, \"inserted\");\n\t\t// const c = NF.quote(extended, extended.env.length, NF.DSL.Unop.not(q));\n\t\t// const and = EB.DSL.or(tm, c);\n\t\tconst c = NF.quote(extended, extended.env.length, q);\n\t\tconst and = EB.DSL.and(tm, c);\n\n\t\treturn NF.Constructors.Lambda(\"$x\", \"Explicit\", NF.Constructors.Closure(ctx, and), ann);\n\t},\n};\n"],"mappings":";AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AAeb,MAAM,eAAe;AAAA,EAC3B,aAAa,CAAC,GAAa,MAA0B,GAAG,IAAI,MAAM,GAAG,GAAG,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC;AAAA,EAE1F,OAAO,CAAC,KAAiB,KAAe,GAAY,MAA0B;AAI7E,UAAM,IAAI,GAAG,aAAa,IAAI,EAAE,MAAM,SAAS,OAAO,EAAE,CAAC;AACzD,UAAM,KAAK,GAAG,aAAa,IAAI,YAAY,GAAG,CAAC;AAE/C,UAAM,WAAW,GAAG,KAAK,KAAK,EAAE,MAAM,UAAU,UAAU,KAAK,GAAG,KAAK,UAAU;AAGjF,UAAM,IAAI,GAAG,MAAM,UAAU,SAAS,IAAI,QAAQ,CAAC;AACnD,UAAM,MAAM,GAAG,IAAI,IAAI,IAAI,CAAC;AAE5B,WAAO,GAAG,aAAa,OAAO,MAAM,YAAY,GAAG,aAAa,QAAQ,KAAK,GAAG,GAAG,GAAG;AAAA,EACvF;AACD;","names":[]}