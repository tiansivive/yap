{"version":3,"sources":["../../src/Codegen/terms.ts"],"sourcesContent":["import { match } from \"ts-pattern\";\nimport { globalModules } from \"../modules/loading\";\n\nimport * as EB from \"@yap/elaboration\";\nimport { Literal } from \"../shared/literals\";\n\nimport * as Lib from \"@yap/shared/lib/primitives\";\nimport { get } from \"lodash\";\nconst DEFAULT_RECORD_NAME = \"rec\";\n\nexport const codegen = (env: string[], term: EB.Term): string => {\n\treturn (\n\t\tmatch(term)\n\t\t\t.with({ type: \"Lit\" }, ({ value }) => {\n\t\t\t\treturn match(value)\n\t\t\t\t\t.with({ type: \"String\" }, s => `\"${s.value}\"`)\n\t\t\t\t\t.with({ type: \"Num\" }, n => `${n.value}`)\n\t\t\t\t\t.with({ type: \"Bool\" }, b => `${b.value}`)\n\t\t\t\t\t.with({ type: \"unit\" }, () => `\"unit\"`)\n\t\t\t\t\t.with({ type: \"Atom\" }, ({ value }) => `\"${value}\"`)\n\t\t\t\t\t.exhaustive();\n\t\t\t})\n\t\t\t.with({ type: \"Var\", variable: { type: \"Label\" } }, ({ variable }) => `${DEFAULT_RECORD_NAME}.${variable.name}`)\n\t\t\t.with({ type: \"Var\", variable: { type: \"Foreign\" } }, { type: \"Var\", variable: { type: \"Free\" } }, ({ variable }) => {\n\t\t\t\tif (Object.keys(Lib.Terms()).includes(variable.name)) {\n\t\t\t\t\treturn codegen(env, get(Lib.Terms(), variable.name));\n\t\t\t\t}\n\t\t\t\treturn variable.name;\n\t\t\t})\n\t\t\t.with({ type: \"Var\", variable: { type: \"Bound\" } }, ({ variable }) => {\n\t\t\t\treturn env[variable.index];\n\t\t\t})\n\t\t\t.with({ type: \"Var\" }, v => {\n\t\t\t\tthrow new Error(\"Could not compile Variable: \" + JSON.stringify(v));\n\t\t\t})\n\t\t\t.with({ type: \"Abs\", binding: { type: \"Mu\" } }, mu => {\n\t\t\t\treturn codegen([mu.binding.source, ...env], mu.body);\n\t\t\t})\n\t\t\t.with({ type: \"Abs\" }, abs => {\n\t\t\t\tconst extended = [abs.binding.variable, ...env];\n\t\t\t\tconst body = codegen(extended, abs.body);\n\t\t\t\treturn `(${abs.binding.variable}) => {\n                return ${body};\n            }`;\n\t\t\t})\n\t\t\t.with(\n\t\t\t\t{\n\t\t\t\t\ttype: \"App\",\n\t\t\t\t\tfunc: { type: \"Lit\", value: { type: \"Atom\", value: \"Struct\" } },\n\t\t\t\t\targ: { type: \"Row\" },\n\t\t\t\t},\n\t\t\t\t({ func, arg }) => {\n\t\t\t\t\treturn codegen(env, arg);\n\t\t\t\t},\n\t\t\t)\n\t\t\t.with(\n\t\t\t\t{\n\t\t\t\t\ttype: \"App\",\n\t\t\t\t\tfunc: { type: \"Lit\", value: { type: \"Atom\", value: \"Schema\" } },\n\t\t\t\t\targ: { type: \"Row\" },\n\t\t\t\t},\n\t\t\t\t({ func, arg }) => {\n\t\t\t\t\treturn codegen(env, arg);\n\t\t\t\t},\n\t\t\t)\n\t\t\t.with(\n\t\t\t\t{\n\t\t\t\t\ttype: \"App\",\n\t\t\t\t\tfunc: { type: \"Lit\", value: { type: \"Atom\", value: \"Variant\" } },\n\t\t\t\t\targ: { type: \"Row\" },\n\t\t\t\t},\n\t\t\t\t({ func, arg }) => {\n\t\t\t\t\treturn `/* variant */${codegen(env, arg)}`;\n\t\t\t\t},\n\t\t\t)\n\t\t\t.with({ type: \"App\" }, app => {\n\t\t\t\tconst fn = codegen(env, app.func);\n\t\t\t\tconst arg = codegen(env, app.arg);\n\n\t\t\t\treturn `(${fn})(${arg})`;\n\t\t\t})\n\t\t\t.with({ type: \"Block\" }, block => {\n\t\t\t\tconst [, stmts] = block.statements.reduce(\n\t\t\t\t\t([env, code], stmt) => {\n\t\t\t\t\t\tconst code_ = (code += \" \" + Statement.codegen(env, stmt) + \";\");\n\t\t\t\t\t\tconst env_ = stmt.type === \"Let\" ? [stmt.variable, ...env] : env;\n\t\t\t\t\t\treturn [env_, code_];\n\t\t\t\t\t},\n\t\t\t\t\t[env, \"\"],\n\t\t\t\t);\n\t\t\t\tconst ret = codegen(env, block.return);\n\t\t\t\treturn `((_ => { ${stmts} return ${ret}; })())`;\n\t\t\t})\n\t\t\t// .with({ type: \"Annotation\" }, ann => {\n\t\t\t// \treturn codegen(env, ann.term);\n\t\t\t// })\n\t\t\t.with({ type: \"Proj\" }, proj => {\n\t\t\t\tconst label = Number.isNaN(parseInt(proj.label)) ? `\"${proj.label}\"` : proj.label;\n\t\t\t\treturn `${codegen(env, proj.term)}[${label}]`;\n\t\t\t})\n\t\t\t.with({ type: \"Inj\" }, inj => {\n\t\t\t\tconst obj = codegen(env, inj.term);\n\t\t\t\tconst val = codegen(env, inj.value);\n\t\t\t\treturn `{ ...${obj}, ${inj.label}: ${val} }`;\n\t\t\t})\n\t\t\t.with({ type: \"Row\" }, ({ row }) => {\n\t\t\t\tconst extract = (row: EB.Row): Array<string> => {\n\t\t\t\t\tif (row.type === \"empty\") {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (row.type === \"variable\") {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [row.label, ...extract(row.row)];\n\t\t\t\t};\n\n\t\t\t\tconst gen = (r: EB.Row, code: string) => {\n\t\t\t\t\tif (r.type === \"empty\") {\n\t\t\t\t\t\treturn `((() => {${code}\\nreturn ${DEFAULT_RECORD_NAME};\\n})())`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r.type === \"variable\") {\n\t\t\t\t\t\tconsole.warn(\"Cannot compile rows with variable: \" + JSON.stringify(row));\n\t\t\t\t\t\treturn `((() => {${code}\\nreturn ${DEFAULT_RECORD_NAME};\\n})())`;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst dec = `\\nObject.defineProperty(rec, \"${r.label}\", { get: () => ${codegen(env, r.value)}, enumerable: true });`;\n\t\t\t\t\treturn gen(r.row, code + dec);\n\t\t\t\t};\n\n\t\t\t\treturn gen(row, \"\\nconst rec = {};\");\n\t\t\t})\n\t\t\t.with({ type: \"Match\" }, patMatch => {\n\t\t\t\tconst scrutinee = codegen(env, patMatch.scrutinee);\n\t\t\t\tconst alts = patMatch.alternatives.map(alt => Alternative.codegen(env, alt, \"$x\")).join(\" else \");\n\t\t\t\treturn `(() => {\n                const $x = ${scrutinee};\n                ${alts}\n            })()`;\n\t\t\t})\n\t\t\t.otherwise(_ => {\n\t\t\t\tthrow new Error(\"Code gen not yet implemented\");\n\t\t\t})\n\t);\n};\n\nexport const Lit = {\n\tcodegen: (lit: Literal) => {\n\t\treturn match(lit)\n\t\t\t.with({ type: \"String\" }, s => `\"${s.value}\"`)\n\t\t\t.with({ type: \"Num\" }, n => `${n.value}`)\n\t\t\t.with({ type: \"Bool\" }, b => `${b.value}`)\n\t\t\t.with({ type: \"unit\" }, () => `\"unit\"`)\n\t\t\t.with({ type: \"Atom\" }, ({ value }) => `\"${value}\"`)\n\t\t\t.exhaustive();\n\t},\n};\n\ntype Path = string;\ntype Name = string;\nexport const Patterns = {\n\tcodegen: (env: string[], pat: EB.Pattern, scrutinee: string): [string[], [Path, Name][]] => {\n\t\tswitch (pat.type) {\n\t\t\tcase \"Lit\":\n\t\t\t\treturn [[`(${scrutinee}) === ${Lit.codegen(pat.value)}`], []];\n\t\t\tcase \"List\":\n\t\t\t\tif (pat.patterns.length === 0) {\n\t\t\t\t\treturn [[`Array.isArray(${scrutinee}) && ${scrutinee}.length === 0`], []];\n\t\t\t\t}\n\t\t\t\tconst [elems, bindings] = pat.patterns.reduce(\n\t\t\t\t\t([conditions, bs], p, i): [string[], [Path, Name][]] => {\n\t\t\t\t\t\tconst result = Patterns.codegen(env, p, `${scrutinee}[${i}]`);\n\t\t\t\t\t\treturn [conditions.concat(result[0]), bs.concat(result[1])];\n\t\t\t\t\t},\n\t\t\t\t\t[[], []] as [string[], [Path, Name][]],\n\t\t\t\t);\n\n\t\t\t\tconst all: [Path, Name][] = pat.rest ? bindings.concat([[`${scrutinee}.slice(${pat.patterns.length})`, pat.rest]]) : bindings;\n\t\t\t\treturn [[`Array.isArray(${scrutinee}) && ${elems.join(\" && \")}`], all];\n\t\t\tcase \"Variant\":\n\t\t\t\tconst [variant, bs] = Patterns.codegen(env, { type: \"Row\", row: pat.row }, scrutinee);\n\t\t\t\treturn [[`(${variant.join(\" || \")})`], bs];\n\t\t\tcase \"Struct\":\n\t\t\t\tconst [struct, bs2] = Patterns.codegen(env, { type: \"Row\", row: pat.row }, scrutinee);\n\t\t\t\treturn [[`(${struct.join(\" && \")})`], bs2];\n\t\t\tcase \"Row\":\n\t\t\t\tif (pat.row.type === \"empty\") {\n\t\t\t\t\treturn [[], []];\n\t\t\t\t}\n\n\t\t\t\tif (pat.row.type === \"variable\") {\n\t\t\t\t\treturn [[], []];\n\t\t\t\t}\n\n\t\t\t\tconst label = Number.isNaN(parseInt(pat.row.label)) ? `\"${pat.row.label}\"` : pat.row.label;\n\t\t\t\tconst [v, bs3] = Patterns.codegen(env, pat.row.value, `${scrutinee}[${label}]`);\n\t\t\t\tconst [r, bs4] = Patterns.codegen(env, { type: \"Row\", row: pat.row.row }, scrutinee);\n\n\t\t\t\treturn [[...v, ...r], bs3.concat(bs4)];\n\n\t\t\tcase \"Var\":\n\t\t\t\tthrow new Error(\"Var patterns not implemented yet\");\n\t\t\tcase \"Wildcard\":\n\t\t\t\treturn [[`${scrutinee} !== undefined`], []];\n\t\t\tcase \"Binder\":\n\t\t\t\treturn [[scrutinee], [[scrutinee, pat.value]]];\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Pattern codegen not implemented yet\");\n\t\t}\n\t},\n};\n\nexport const Alternative = {\n\tcodegen: (env: string[], alt: EB.Alternative, scrutinee: string): string => {\n\t\tconst [pat, bs] = Patterns.codegen(env, alt.pattern, scrutinee);\n\t\tconst extended = bs.map(([path, name]) => name);\n\t\textended.reverse();\n\t\tconst body = codegen([...extended, ...env], alt.term);\n\t\tconst bindings = bs.map(([path, name]) => `const ${name} = ${path}`);\n\t\tconst defs = bindings.length > 0 ? bindings.join(\"; \") + \";\" : \"\";\n\t\treturn `if (${pat.join(\" && \")}) { ${defs} return ${body}; }`;\n\t},\n};\n\nexport const Statement = {\n\tcodegen: (env: string[], stmt: EB.Statement): string => {\n\t\treturn match(stmt)\n\t\t\t.with({ type: \"Expression\" }, ({ value }) => codegen(env, value))\n\t\t\t.with({ type: \"Let\" }, ({ variable, value }) => {\n\t\t\t\tconst val = codegen([variable, ...env], value);\n\t\t\t\treturn `const ${variable} = ${val}`;\n\t\t\t})\n\t\t\t.with({ type: \"Using\" }, _ => \"\")\n\t\t\t.otherwise(() => {\n\t\t\t\tthrow new Error(\"Statement codegen not implemented yet\");\n\t\t\t});\n\t},\n};\n"],"mappings":"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","names":["value","env","row","bs"]}