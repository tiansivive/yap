// @ts-nocheck
// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d: any[]): any {
	return d[0];
}
declare var space: any;
declare var semicolon: any;
declare var comma: any;
declare var lparens: any;
declare var rparens: any;
declare var colon: any;
declare var langle: any;
declare var rangle: any;
declare var op: any;
declare var concat: any;
declare var hole: any;
declare var arrow: any;
declare var backslash: any;
declare var fatArrow: any;
declare var lbracket: any;
declare var rbracket: any;
declare var bar: any;
declare var lbrace: any;
declare var rbrace: any;
declare var equals: any;
declare var dot: any;
declare var hash: any;
declare var variable: any;
declare var digit: any;
declare var string: any;

// Moo lexer documentation is here:
// https://github.com/no-context/moo

import moo from "moo";
import * as Q from "@qtt/shared/modalities/multiplicity";
import * as Lit from "@qtt/shared/literals";
import * as P from "./processors";

const lexer = moo.compile({
	digit: { match: /[0-9]+/, value: s => parseInt(s) },
	string: { match: /"(?:\\["bfnrt\/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*"/, value: s => s.slice(1, -1) },
	variable: {
		match: /[a-zA-Z][a-zA-Z0-9]*/,
		type: moo.keywords({
			ret: "return",
			dec: "let",
			match: "match",
			Type: "Type",
			Unit: "Unit",
			Row: "Row",
			module: "module",
			import: "import",
			exports: "export",
			from: "from",
			as: "as",
			using: "using",
			foreign: "foreign",
			loop: "loop",
			repeat: "repeat",
			if: "if",
			else: "else",
			then: "then",
		}),
	},
	dot: /\./,
	equals: /\=(?!>)/,
	backslash: /\\/,
	arrow: /->/,
	backarrow: /<-/,
	fatArrow: /\=>/,
	op: /[\+\-\*\/]/,
	concat: /<>/,
	lparens: /\(/,
	rparens: /\)/,
	lbrace: /\{/,
	rbrace: /\}/,
	langle: /</,
	rangle: />/,
	lbracket: /\[/,
	rbracket: /\]/,
	semicolon: /\;/,
	colon: /\:/,
	comma: /\,/,
	bar: /\|/,
	hash: /#/,
	hole: /_/,
	space: { match: /[ \n\t]+/, lineBreaks: true },
});

interface NearleyToken {
	value: any;
	[key: string]: any;
}

interface NearleyLexer {
	reset: (chunk: string, info: any) => void;
	next: () => NearleyToken | undefined;
	save: () => any;
	formatError: (token: never) => string;
	has: (tokenType: string) => boolean;
}

interface NearleyRule {
	name: string;
	symbols: NearleySymbol[];
	postprocess?: (d: any[], loc?: number, reject?: {}) => any;
}

type NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };

interface Grammar {
	Lexer: NearleyLexer | undefined;
	ParserRules: NearleyRule[];
	ParserStart: string;
}

const grammar: Grammar = {
	Lexer: lexer,
	ParserRules: [
		{ name: "Module$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Module$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Module$ebnf$2", symbols: [] },
		{ name: "Module$ebnf$2", symbols: ["Module$ebnf$2", "Imports"], postprocess: d => d[0].concat([d[1]]) },
		{ name: "Module$ebnf$3", symbols: [lexer.has("space") ? { type: "space" } : space] },
		{ name: "Module$ebnf$3", symbols: ["Module$ebnf$3", lexer.has("space") ? { type: "space" } : space], postprocess: d => d[0].concat([d[1]]) },
		{ name: "Module", symbols: ["Module$ebnf$1", "Exports", "Module$ebnf$2", "Module$ebnf$3", "Script"], postprocess: P.module_ },
		{
			name: "Exports",
			symbols: [
				{ literal: "export" },
				lexer.has("space") ? { type: "space" } : space,
				{ literal: "*" },
				lexer.has("semicolon") ? { type: "semicolon" } : semicolon,
			],
			postprocess: P.exportAll,
		},
		{ name: "Exports$macrocall$2$macrocall$2", symbols: ["Identifier"] },
		{ name: "Exports$macrocall$2$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Exports$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Exports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Exports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Exports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Exports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Exports$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Exports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Exports$macrocall$2$macrocall$2",
				"Exports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Exports$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Exports$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Exports$macrocall$2$macrocall$1$ebnf$1", "Exports$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Exports$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Exports$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Exports$macrocall$2$macrocall$1",
			symbols: ["Exports$macrocall$2$macrocall$1$ebnf$1", "Exports$macrocall$2$macrocall$1$ebnf$2", "Exports$macrocall$2$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "Exports$macrocall$2", symbols: ["Exports$macrocall$2$macrocall$1"] },
		{ name: "Exports$macrocall$1$macrocall$2", symbols: ["Exports$macrocall$2"] },
		{ name: "Exports$macrocall$1$macrocall$3", symbols: [lexer.has("lparens") ? { type: "lparens" } : lparens] },
		{ name: "Exports$macrocall$1$macrocall$4", symbols: [lexer.has("rparens") ? { type: "rparens" } : rparens] },
		{ name: "Exports$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Exports$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Exports$macrocall$1$macrocall$1",
			symbols: [
				"Exports$macrocall$1$macrocall$3",
				"Exports$macrocall$1$macrocall$2",
				"Exports$macrocall$1$macrocall$1$ebnf$1",
				"Exports$macrocall$1$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "Exports$macrocall$1", symbols: ["Exports$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{
			name: "Exports",
			symbols: [
				{ literal: "export" },
				lexer.has("space") ? { type: "space" } : space,
				"Exports$macrocall$1",
				lexer.has("semicolon") ? { type: "semicolon" } : semicolon,
			],
			postprocess: P.exportSome,
		},
		{ name: "Imports$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Imports$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Imports",
			symbols: [
				"Imports$ebnf$1",
				{ literal: "import" },
				lexer.has("space") ? { type: "space" } : space,
				"String",
				lexer.has("semicolon") ? { type: "semicolon" } : semicolon,
			],
			postprocess: P.importAll,
		},
		{ name: "Imports$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Imports$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Imports$macrocall$2$macrocall$2", symbols: ["Identifier"] },
		{ name: "Imports$macrocall$2$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Imports$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Imports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Imports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Imports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Imports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Imports$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Imports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Imports$macrocall$2$macrocall$2",
				"Imports$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Imports$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Imports$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Imports$macrocall$2$macrocall$1$ebnf$1", "Imports$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Imports$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Imports$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Imports$macrocall$2$macrocall$1",
			symbols: ["Imports$macrocall$2$macrocall$1$ebnf$1", "Imports$macrocall$2$macrocall$1$ebnf$2", "Imports$macrocall$2$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "Imports$macrocall$2", symbols: ["Imports$macrocall$2$macrocall$1"] },
		{ name: "Imports$macrocall$1$macrocall$2", symbols: ["Imports$macrocall$2"] },
		{ name: "Imports$macrocall$1$macrocall$3", symbols: [lexer.has("lparens") ? { type: "lparens" } : lparens] },
		{ name: "Imports$macrocall$1$macrocall$4", symbols: [lexer.has("rparens") ? { type: "rparens" } : rparens] },
		{ name: "Imports$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Imports$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Imports$macrocall$1$macrocall$1",
			symbols: [
				"Imports$macrocall$1$macrocall$3",
				"Imports$macrocall$1$macrocall$2",
				"Imports$macrocall$1$macrocall$1$ebnf$1",
				"Imports$macrocall$1$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "Imports$macrocall$1", symbols: ["Imports$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{
			name: "Imports",
			symbols: [
				"Imports$ebnf$2",
				{ literal: "import" },
				lexer.has("space") ? { type: "space" } : space,
				"String",
				lexer.has("space") ? { type: "space" } : space,
				"Imports$macrocall$1",
				lexer.has("semicolon") ? { type: "semicolon" } : semicolon,
			],
			postprocess: P.importSome,
		},
		{ name: "Script$macrocall$2", symbols: ["Statement"] },
		{ name: "Script$macrocall$3", symbols: [lexer.has("semicolon") ? { type: "semicolon" } : semicolon] },
		{ name: "Script$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Script$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Script$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Script$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Script$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Script$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Script$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Script$macrocall$2",
				"Script$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Script$macrocall$3",
			],
		},
		{
			name: "Script$macrocall$1$ebnf$1",
			symbols: ["Script$macrocall$1$ebnf$1", "Script$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Script$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Script$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Script$macrocall$1", symbols: ["Script$macrocall$1$ebnf$1", "Script$macrocall$1$ebnf$2", "Script$macrocall$2"], postprocess: P.many },
		{ name: "Script$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Script$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Script", symbols: ["Script$macrocall$1", lexer.has("semicolon") ? { type: "semicolon" } : semicolon, "Script$ebnf$1"], postprocess: P.script },
		{ name: "Ann$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Ann$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Ann$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Ann$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Ann", symbols: ["Ann", "Ann$ebnf$1", lexer.has("colon") ? { type: "colon" } : colon, "Ann$ebnf$2", "TypeExpr"], postprocess: P.Annotation },
		{ name: "Ann$ebnf$3", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Ann$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Ann$ebnf$4", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Ann$ebnf$4", symbols: [], postprocess: () => null },
		{ name: "Ann$macrocall$2", symbols: ["Quantity"] },
		{ name: "Ann$macrocall$1$macrocall$2", symbols: ["Ann$macrocall$2"] },
		{ name: "Ann$macrocall$1$macrocall$3", symbols: [lexer.has("langle") ? { type: "langle" } : langle] },
		{ name: "Ann$macrocall$1$macrocall$4", symbols: [lexer.has("rangle") ? { type: "rangle" } : rangle] },
		{ name: "Ann$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Ann$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Ann$macrocall$1$macrocall$1",
			symbols: ["Ann$macrocall$1$macrocall$3", "Ann$macrocall$1$macrocall$2", "Ann$macrocall$1$macrocall$1$ebnf$1", "Ann$macrocall$1$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Ann$macrocall$1", symbols: ["Ann$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{ name: "Ann$ebnf$5", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Ann$ebnf$5", symbols: [], postprocess: () => null },
		{
			name: "Ann",
			symbols: ["Ann", "Ann$ebnf$3", lexer.has("colon") ? { type: "colon" } : colon, "Ann$ebnf$4", "Ann$macrocall$1", "Ann$ebnf$5", "TypeExpr"],
			postprocess: P.Annotation,
		},
		{ name: "Ann", symbols: ["TypeExpr"], postprocess: id },
		{ name: "TypeExpr", symbols: ["Pi"], postprocess: id },
		{ name: "TypeExpr", symbols: ["Type"], postprocess: id },
		{ name: "Type", symbols: ["Mu"], postprocess: id },
		{ name: "Type", symbols: ["Variant"], postprocess: id },
		{ name: "Type", symbols: ["Schema"], postprocess: id },
		{ name: "Type", symbols: ["Row"], postprocess: id },
		{ name: "Type", symbols: ["Expr"], postprocess: id },
		{ name: "Expr", symbols: ["Lambda"], postprocess: id },
		{ name: "Expr", symbols: ["Match"], postprocess: id },
		{ name: "Expr", symbols: ["Block"], postprocess: id },
		{ name: "Expr", symbols: ["App"], postprocess: id },
		{ name: "App", symbols: ["App", lexer.has("space") ? { type: "space" } : space, "Atom"], postprocess: P.Application },
		{ name: "App$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "App$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "App$subexpression$1", symbols: [lexer.has("op") ? { type: "op" } : op] },
		{ name: "App$subexpression$1", symbols: [lexer.has("concat") ? { type: "concat" } : concat] },
		{ name: "App$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "App$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "App", symbols: ["App", "App$ebnf$1", "App$subexpression$1", "App$ebnf$2", "Atom"], postprocess: P.Operation },
		{ name: "App", symbols: ["Atom"], postprocess: id },
		{ name: "Atom", symbols: ["Identifier"], postprocess: P.Var },
		{ name: "Atom", symbols: [lexer.has("hole") ? { type: "hole" } : hole], postprocess: P.Hole },
		{ name: "Atom", symbols: ["Literal"], postprocess: P.Lit },
		{ name: "Atom", symbols: ["Struct"], postprocess: id },
		{ name: "Atom", symbols: ["Tuple"], postprocess: id },
		{ name: "Atom", symbols: ["Projection"], postprocess: id },
		{ name: "Atom", symbols: ["Injection"], postprocess: id },
		{ name: "Atom", symbols: ["List"], postprocess: id },
		{ name: "Atom", symbols: ["Tagged"], postprocess: id },
		{ name: "Atom$macrocall$2", symbols: ["Ann"] },
		{ name: "Atom$macrocall$1$macrocall$2", symbols: ["Atom$macrocall$2"] },
		{ name: "Atom$macrocall$1$macrocall$3", symbols: [lexer.has("lparens") ? { type: "lparens" } : lparens] },
		{ name: "Atom$macrocall$1$macrocall$4", symbols: [lexer.has("rparens") ? { type: "rparens" } : rparens] },
		{ name: "Atom$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Atom$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Atom$macrocall$1$macrocall$1",
			symbols: ["Atom$macrocall$1$macrocall$3", "Atom$macrocall$1$macrocall$2", "Atom$macrocall$1$macrocall$1$ebnf$1", "Atom$macrocall$1$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Atom$macrocall$1", symbols: ["Atom$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{ name: "Atom", symbols: ["Atom$macrocall$1"], postprocess: P.extract },
		{ name: "Mu$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Mu$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Mu$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Mu$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Mu$ebnf$3", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Mu$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "Mu",
			symbols: [{ literal: "Î¼" }, "Mu$ebnf$1", "Identifier", "Mu$ebnf$2", lexer.has("arrow") ? { type: "arrow" } : arrow, "Mu$ebnf$3", "TypeExpr"],
			postprocess: P.Mu,
		},
		{ name: "Lambda$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Lambda$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Lambda$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Lambda$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Lambda",
			symbols: [
				lexer.has("backslash") ? { type: "backslash" } : backslash,
				"Param",
				"Lambda$ebnf$1",
				lexer.has("arrow") ? { type: "arrow" } : arrow,
				"Lambda$ebnf$2",
				"TypeExpr",
			],
			postprocess: P.Lambda("Explicit"),
		},
		{ name: "Lambda$ebnf$3", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Lambda$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Lambda$ebnf$4", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Lambda$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "Lambda",
			symbols: [
				lexer.has("backslash") ? { type: "backslash" } : backslash,
				"Param",
				"Lambda$ebnf$3",
				lexer.has("fatArrow") ? { type: "fatArrow" } : fatArrow,
				"Lambda$ebnf$4",
				"TypeExpr",
			],
			postprocess: P.Lambda("Implicit"),
		},
		{ name: "Param", symbols: ["Identifier"], postprocess: P.Param },
		{ name: "Param$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Param$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Param$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Param$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Param",
			symbols: ["Identifier", "Param$ebnf$1", lexer.has("colon") ? { type: "colon" } : colon, "Param$ebnf$2", "TypeExpr"],
			postprocess: P.Param,
		},
		{ name: "Param$ebnf$3", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Param$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Param$ebnf$4", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Param$ebnf$4", symbols: [], postprocess: () => null },
		{ name: "Param$macrocall$2", symbols: ["Quantity"] },
		{ name: "Param$macrocall$1$macrocall$2", symbols: ["Param$macrocall$2"] },
		{ name: "Param$macrocall$1$macrocall$3", symbols: [lexer.has("langle") ? { type: "langle" } : langle] },
		{ name: "Param$macrocall$1$macrocall$4", symbols: [lexer.has("rangle") ? { type: "rangle" } : rangle] },
		{ name: "Param$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Param$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Param$macrocall$1$macrocall$1",
			symbols: ["Param$macrocall$1$macrocall$3", "Param$macrocall$1$macrocall$2", "Param$macrocall$1$macrocall$1$ebnf$1", "Param$macrocall$1$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Param$macrocall$1", symbols: ["Param$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{ name: "Param$ebnf$5", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Param$ebnf$5", symbols: [], postprocess: () => null },
		{
			name: "Param",
			symbols: ["Identifier", "Param$ebnf$3", lexer.has("colon") ? { type: "colon" } : colon, "Param$ebnf$4", "Param$macrocall$1", "Param$ebnf$5", "TypeExpr"],
			postprocess: P.Param,
		},
		{ name: "Param$macrocall$4", symbols: ["Param"] },
		{ name: "Param$macrocall$3$macrocall$2", symbols: ["Param$macrocall$4"] },
		{ name: "Param$macrocall$3$macrocall$3", symbols: [lexer.has("lparens") ? { type: "lparens" } : lparens] },
		{ name: "Param$macrocall$3$macrocall$4", symbols: [lexer.has("rparens") ? { type: "rparens" } : rparens] },
		{ name: "Param$macrocall$3$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Param$macrocall$3$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Param$macrocall$3$macrocall$1",
			symbols: ["Param$macrocall$3$macrocall$3", "Param$macrocall$3$macrocall$2", "Param$macrocall$3$macrocall$1$ebnf$1", "Param$macrocall$3$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Param$macrocall$3", symbols: ["Param$macrocall$3$macrocall$1"], postprocess: P.enclosed },
		{ name: "Param", symbols: ["Param$macrocall$3"], postprocess: P.extract },
		{ name: "Pi$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Pi$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Pi$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Pi$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Pi", symbols: ["Type", "Pi$ebnf$1", lexer.has("arrow") ? { type: "arrow" } : arrow, "Pi$ebnf$2", "PiTail"], postprocess: P.Pi("Explicit") },
		{ name: "Pi$ebnf$3", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Pi$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Pi$ebnf$4", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Pi$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "Pi",
			symbols: ["Type", "Pi$ebnf$3", lexer.has("fatArrow") ? { type: "fatArrow" } : fatArrow, "Pi$ebnf$4", "PiTail"],
			postprocess: P.Pi("Implicit"),
		},
		{ name: "PiTail", symbols: ["Pi"], postprocess: id },
		{ name: "PiTail", symbols: ["Type"], postprocess: id },
		{ name: "Row$macrocall$2$macrocall$2", symbols: ["KeyVal"] },
		{ name: "Row$macrocall$2$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Row$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Row$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Row$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Row$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Row$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Row$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Row$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Row$macrocall$2$macrocall$2",
				"Row$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Row$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Row$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Row$macrocall$2$macrocall$1$ebnf$1", "Row$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Row$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Row$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Row$macrocall$2$macrocall$1",
			symbols: ["Row$macrocall$2$macrocall$1$ebnf$1", "Row$macrocall$2$macrocall$1$ebnf$2", "Row$macrocall$2$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "Row$macrocall$2$ebnf$1", symbols: ["RowTail"], postprocess: id },
		{ name: "Row$macrocall$2$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Row$macrocall$2", symbols: ["Row$macrocall$2$macrocall$1", "Row$macrocall$2$ebnf$1"] },
		{ name: "Row$macrocall$1$macrocall$2", symbols: ["Row$macrocall$2"] },
		{ name: "Row$macrocall$1$macrocall$3", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "Row$macrocall$1$macrocall$4", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "Row$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Row$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Row$macrocall$1$macrocall$1",
			symbols: ["Row$macrocall$1$macrocall$3", "Row$macrocall$1$macrocall$2", "Row$macrocall$1$macrocall$1$ebnf$1", "Row$macrocall$1$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Row$macrocall$1", symbols: ["Row$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{ name: "Row", symbols: ["Row$macrocall$1"], postprocess: P.row },
		{ name: "RowTail$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "RowTail$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "RowTail$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "RowTail$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "RowTail", symbols: ["RowTail$ebnf$1", lexer.has("bar") ? { type: "bar" } : bar, "RowTail$ebnf$2", "Identifier"], postprocess: d => d[3] },
		{ name: "Struct$macrocall$2", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Struct$macrocall$3", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Struct$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Struct$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Struct$macrocall$1", symbols: ["Struct$macrocall$2", "Struct$macrocall$1$ebnf$1", "Struct$macrocall$3"], postprocess: P.none },
		{ name: "Struct", symbols: ["Struct$macrocall$1"], postprocess: P.emptyStruct },
		{ name: "Struct$macrocall$5$macrocall$2", symbols: ["KeyVal"] },
		{ name: "Struct$macrocall$5$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Struct$macrocall$5$macrocall$2",
				"Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Struct$macrocall$5$macrocall$3",
			],
		},
		{
			name: "Struct$macrocall$5$macrocall$1$ebnf$1",
			symbols: ["Struct$macrocall$5$macrocall$1$ebnf$1", "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Struct$macrocall$5$macrocall$1",
			symbols: ["Struct$macrocall$5$macrocall$1$ebnf$1", "Struct$macrocall$5$macrocall$1$ebnf$2", "Struct$macrocall$5$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "Struct$macrocall$5", symbols: ["Struct$macrocall$5$macrocall$1"] },
		{ name: "Struct$macrocall$4$macrocall$2", symbols: ["Struct$macrocall$5"] },
		{ name: "Struct$macrocall$4$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Struct$macrocall$4$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Struct$macrocall$4$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Struct$macrocall$4$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Struct$macrocall$4$macrocall$1",
			symbols: ["Struct$macrocall$4$macrocall$3", "Struct$macrocall$4$macrocall$2", "Struct$macrocall$4$macrocall$1$ebnf$1", "Struct$macrocall$4$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Struct$macrocall$4", symbols: ["Struct$macrocall$4$macrocall$1"], postprocess: P.enclosed },
		{ name: "Struct", symbols: ["Struct$macrocall$4"], postprocess: P.struct },
		{ name: "Tuple$macrocall$2$macrocall$2", symbols: ["TypeExpr"] },
		{ name: "Tuple$macrocall$2$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Tuple$macrocall$2$macrocall$2",
				"Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Tuple$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Tuple$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Tuple$macrocall$2$macrocall$1$ebnf$1", "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Tuple$macrocall$2$macrocall$1",
			symbols: ["Tuple$macrocall$2$macrocall$1$ebnf$1", "Tuple$macrocall$2$macrocall$1$ebnf$2", "Tuple$macrocall$2$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "Tuple$macrocall$2", symbols: ["Tuple$macrocall$2$macrocall$1"] },
		{ name: "Tuple$macrocall$1$macrocall$2", symbols: ["Tuple$macrocall$2"] },
		{ name: "Tuple$macrocall$1$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Tuple$macrocall$1$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Tuple$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Tuple$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Tuple$macrocall$1$macrocall$1",
			symbols: ["Tuple$macrocall$1$macrocall$3", "Tuple$macrocall$1$macrocall$2", "Tuple$macrocall$1$macrocall$1$ebnf$1", "Tuple$macrocall$1$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Tuple$macrocall$1", symbols: ["Tuple$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{ name: "Tuple", symbols: ["Tuple$macrocall$1"], postprocess: P.tuple },
		{ name: "List$macrocall$2", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "List$macrocall$3", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "List$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "List$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "List$macrocall$1", symbols: ["List$macrocall$2", "List$macrocall$1$ebnf$1", "List$macrocall$3"], postprocess: P.none },
		{ name: "List", symbols: ["List$macrocall$1"], postprocess: P.emptyList },
		{ name: "List$macrocall$5$macrocall$2", symbols: ["TypeExpr"] },
		{ name: "List$macrocall$5$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "List$macrocall$5$macrocall$1$ebnf$1", symbols: [] },
		{ name: "List$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "List$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "List$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "List$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "List$macrocall$5$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"List$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"List$macrocall$5$macrocall$2",
				"List$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"List$macrocall$5$macrocall$3",
			],
		},
		{
			name: "List$macrocall$5$macrocall$1$ebnf$1",
			symbols: ["List$macrocall$5$macrocall$1$ebnf$1", "List$macrocall$5$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "List$macrocall$5$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "List$macrocall$5$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "List$macrocall$5$macrocall$1",
			symbols: ["List$macrocall$5$macrocall$1$ebnf$1", "List$macrocall$5$macrocall$1$ebnf$2", "List$macrocall$5$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "List$macrocall$5", symbols: ["List$macrocall$5$macrocall$1"] },
		{ name: "List$macrocall$4$macrocall$2", symbols: ["List$macrocall$5"] },
		{ name: "List$macrocall$4$macrocall$3", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "List$macrocall$4$macrocall$4", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "List$macrocall$4$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "List$macrocall$4$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "List$macrocall$4$macrocall$1",
			symbols: ["List$macrocall$4$macrocall$3", "List$macrocall$4$macrocall$2", "List$macrocall$4$macrocall$1$ebnf$1", "List$macrocall$4$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "List$macrocall$4", symbols: ["List$macrocall$4$macrocall$1"], postprocess: P.enclosed },
		{ name: "List", symbols: ["List$macrocall$4"], postprocess: P.list },
		{ name: "Schema$macrocall$2$macrocall$2", symbols: ["SchemaPair"] },
		{ name: "Schema$macrocall$2$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Schema$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Schema$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Schema$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Schema$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Schema$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Schema$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Schema$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Schema$macrocall$2$macrocall$2",
				"Schema$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Schema$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Schema$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Schema$macrocall$2$macrocall$1$ebnf$1", "Schema$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Schema$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Schema$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Schema$macrocall$2$macrocall$1",
			symbols: ["Schema$macrocall$2$macrocall$1$ebnf$1", "Schema$macrocall$2$macrocall$1$ebnf$2", "Schema$macrocall$2$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "Schema$macrocall$2$ebnf$1", symbols: ["RowTail"], postprocess: id },
		{ name: "Schema$macrocall$2$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Schema$macrocall$2", symbols: ["Schema$macrocall$2$macrocall$1", "Schema$macrocall$2$ebnf$1"] },
		{ name: "Schema$macrocall$1$macrocall$2", symbols: ["Schema$macrocall$2"] },
		{ name: "Schema$macrocall$1$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Schema$macrocall$1$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Schema$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Schema$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Schema$macrocall$1$macrocall$1",
			symbols: ["Schema$macrocall$1$macrocall$3", "Schema$macrocall$1$macrocall$2", "Schema$macrocall$1$macrocall$1$ebnf$1", "Schema$macrocall$1$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Schema$macrocall$1", symbols: ["Schema$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{ name: "Schema", symbols: ["Schema$macrocall$1"], postprocess: P.schema },
		{ name: "Variant$macrocall$2", symbols: ["Tagged"] },
		{ name: "Variant$macrocall$3", symbols: [lexer.has("bar") ? { type: "bar" } : bar] },
		{ name: "Variant$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Variant$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Variant$macrocall$2",
				"Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Variant$macrocall$3",
			],
		},
		{
			name: "Variant$macrocall$1$ebnf$1",
			symbols: ["Variant$macrocall$1$ebnf$1", "Variant$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Variant$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Variant$macrocall$1", symbols: ["Variant$macrocall$1$ebnf$1", "Variant$macrocall$1$ebnf$2", "Variant$macrocall$2"], postprocess: P.many },
		{ name: "Variant", symbols: [lexer.has("bar") ? { type: "bar" } : bar, "Variant$macrocall$1"], postprocess: P.variant },
		{ name: "KeyVal$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "KeyVal$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "KeyVal$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "KeyVal$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "KeyVal",
			symbols: ["Identifier", "KeyVal$ebnf$1", lexer.has("colon") ? { type: "colon" } : colon, "KeyVal$ebnf$2", "TypeExpr"],
			postprocess: P.keyval,
		},
		{ name: "SchemaPair$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "SchemaPair$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "SchemaPair$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "SchemaPair$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "SchemaPair",
			symbols: [
				"Identifier",
				"SchemaPair$ebnf$1",
				lexer.has("colon") ? { type: "colon" } : colon,
				lexer.has("colon") ? { type: "colon" } : colon,
				"SchemaPair$ebnf$2",
				"TypeExpr",
			],
			postprocess: P.keyval,
		},
		{ name: "Assignment$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Assignment$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Assignment$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Assignment$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Assignment",
			symbols: ["Identifier", "Assignment$ebnf$1", lexer.has("equals") ? { type: "equals" } : equals, "Assignment$ebnf$2", "TypeExpr"],
			postprocess: P.keyval,
		},
		{ name: "Projection", symbols: ["Atom", lexer.has("dot") ? { type: "dot" } : dot, "Identifier"], postprocess: P.Projection },
		{ name: "Projection", symbols: [lexer.has("dot") ? { type: "dot" } : dot, "Identifier"], postprocess: P.Projection },
		{ name: "Injection$macrocall$2$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$2$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Injection$macrocall$2$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$2$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Injection$macrocall$2$macrocall$2", symbols: ["Assignment"] },
		{ name: "Injection$macrocall$2$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Injection$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Injection$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Injection$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Injection$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Injection$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Injection$macrocall$2$macrocall$2",
				"Injection$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Injection$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Injection$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Injection$macrocall$2$macrocall$1$ebnf$1", "Injection$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Injection$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Injection$macrocall$2$macrocall$1",
			symbols: ["Injection$macrocall$2$macrocall$1$ebnf$1", "Injection$macrocall$2$macrocall$1$ebnf$2", "Injection$macrocall$2$macrocall$2"],
			postprocess: P.many,
		},
		{
			name: "Injection$macrocall$2",
			symbols: [
				"Injection$macrocall$2$ebnf$1",
				"Type",
				"Injection$macrocall$2$ebnf$2",
				lexer.has("bar") ? { type: "bar" } : bar,
				"Injection$macrocall$2$macrocall$1",
			],
		},
		{ name: "Injection$macrocall$1$macrocall$2", symbols: ["Injection$macrocall$2"] },
		{ name: "Injection$macrocall$1$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Injection$macrocall$1$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Injection$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Injection$macrocall$1$macrocall$1",
			symbols: [
				"Injection$macrocall$1$macrocall$3",
				"Injection$macrocall$1$macrocall$2",
				"Injection$macrocall$1$macrocall$1$ebnf$1",
				"Injection$macrocall$1$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "Injection$macrocall$1", symbols: ["Injection$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{ name: "Injection", symbols: ["Injection$macrocall$1"], postprocess: P.Injection },
		{ name: "Injection$macrocall$4$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$4$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Injection$macrocall$4$macrocall$2", symbols: ["Assignment"] },
		{ name: "Injection$macrocall$4$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Injection$macrocall$4$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Injection$macrocall$4$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$4$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Injection$macrocall$4$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$4$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Injection$macrocall$4$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Injection$macrocall$4$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Injection$macrocall$4$macrocall$2",
				"Injection$macrocall$4$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Injection$macrocall$4$macrocall$3",
			],
		},
		{
			name: "Injection$macrocall$4$macrocall$1$ebnf$1",
			symbols: ["Injection$macrocall$4$macrocall$1$ebnf$1", "Injection$macrocall$4$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Injection$macrocall$4$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$4$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Injection$macrocall$4$macrocall$1",
			symbols: ["Injection$macrocall$4$macrocall$1$ebnf$1", "Injection$macrocall$4$macrocall$1$ebnf$2", "Injection$macrocall$4$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "Injection$macrocall$4", symbols: ["Injection$macrocall$4$ebnf$1", lexer.has("bar") ? { type: "bar" } : bar, "Injection$macrocall$4$macrocall$1"] },
		{ name: "Injection$macrocall$3$macrocall$2", symbols: ["Injection$macrocall$4"] },
		{ name: "Injection$macrocall$3$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Injection$macrocall$3$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Injection$macrocall$3$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Injection$macrocall$3$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Injection$macrocall$3$macrocall$1",
			symbols: [
				"Injection$macrocall$3$macrocall$3",
				"Injection$macrocall$3$macrocall$2",
				"Injection$macrocall$3$macrocall$1$ebnf$1",
				"Injection$macrocall$3$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "Injection$macrocall$3", symbols: ["Injection$macrocall$3$macrocall$1"], postprocess: P.enclosed },
		{ name: "Injection", symbols: ["Injection$macrocall$3"], postprocess: P.Injection },
		{ name: "Tagged$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Tagged$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Tagged", symbols: [lexer.has("hash") ? { type: "hash" } : hash, "Identifier", "Tagged$ebnf$1", "TypeExpr"], postprocess: P.tagged },
		{ name: "Block$macrocall$2$macrocall$2", symbols: ["Statement"] },
		{ name: "Block$macrocall$2$macrocall$3", symbols: [lexer.has("semicolon") ? { type: "semicolon" } : semicolon] },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Block$macrocall$2$macrocall$2",
				"Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Block$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Block$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Block$macrocall$2$macrocall$1$ebnf$1", "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Block$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$2$macrocall$1",
			symbols: ["Block$macrocall$2$macrocall$1$ebnf$1", "Block$macrocall$2$macrocall$1$ebnf$2", "Block$macrocall$2$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "Block$macrocall$2$ebnf$1", symbols: ["Return"], postprocess: id },
		{ name: "Block$macrocall$2$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$2",
			symbols: ["Block$macrocall$2$macrocall$1", lexer.has("semicolon") ? { type: "semicolon" } : semicolon, "Block$macrocall$2$ebnf$1"],
		},
		{ name: "Block$macrocall$1$macrocall$2", symbols: ["Block$macrocall$2"] },
		{ name: "Block$macrocall$1$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Block$macrocall$1$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Block$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Block$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$1$macrocall$1",
			symbols: ["Block$macrocall$1$macrocall$3", "Block$macrocall$1$macrocall$2", "Block$macrocall$1$macrocall$1$ebnf$1", "Block$macrocall$1$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Block$macrocall$1", symbols: ["Block$macrocall$1$macrocall$1"], postprocess: P.enclosed },
		{ name: "Block", symbols: ["Block$macrocall$1"], postprocess: P.Block },
		{ name: "Block$macrocall$4", symbols: ["Return"] },
		{ name: "Block$macrocall$3$macrocall$2", symbols: ["Block$macrocall$4"] },
		{ name: "Block$macrocall$3$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Block$macrocall$3$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Block$macrocall$3$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Block$macrocall$3$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$3$macrocall$1",
			symbols: ["Block$macrocall$3$macrocall$3", "Block$macrocall$3$macrocall$2", "Block$macrocall$3$macrocall$1$ebnf$1", "Block$macrocall$3$macrocall$4"],
			postprocess: P.unwrap,
		},
		{ name: "Block$macrocall$3", symbols: ["Block$macrocall$3$macrocall$1"], postprocess: P.enclosed },
		{ name: "Block", symbols: ["Block$macrocall$3"], postprocess: P.Block },
		{ name: "Statement", symbols: ["Ann"], postprocess: P.Expr },
		{ name: "Statement", symbols: ["Letdec"], postprocess: id },
		{ name: "Statement", symbols: ["Using"], postprocess: id },
		{ name: "Statement", symbols: ["Foreign"], postprocess: id },
		{ name: "Return$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Return$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Return",
			symbols: [
				"Return$ebnf$1",
				{ literal: "return" },
				lexer.has("space") ? { type: "space" } : space,
				"Ann",
				lexer.has("semicolon") ? { type: "semicolon" } : semicolon,
			],
			postprocess: P.Return,
		},
		{ name: "Letdec$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Letdec$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Letdec$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Letdec$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Letdec",
			symbols: [
				{ literal: "let" },
				lexer.has("space") ? { type: "space" } : space,
				"Identifier",
				"Letdec$ebnf$1",
				lexer.has("equals") ? { type: "equals" } : equals,
				"Letdec$ebnf$2",
				"Ann",
			],
			postprocess: P.LetDec,
		},
		{ name: "Letdec$ebnf$3", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Letdec$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Letdec$ebnf$4", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Letdec$ebnf$4", symbols: [], postprocess: () => null },
		{ name: "Letdec$ebnf$5", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Letdec$ebnf$5", symbols: [], postprocess: () => null },
		{ name: "Letdec$ebnf$6", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Letdec$ebnf$6", symbols: [], postprocess: () => null },
		{
			name: "Letdec",
			symbols: [
				{ literal: "let" },
				lexer.has("space") ? { type: "space" } : space,
				"Identifier",
				"Letdec$ebnf$3",
				lexer.has("colon") ? { type: "colon" } : colon,
				"Letdec$ebnf$4",
				"TypeExpr",
				"Letdec$ebnf$5",
				lexer.has("equals") ? { type: "equals" } : equals,
				"Letdec$ebnf$6",
				"TypeExpr",
			],
			postprocess: P.LetDec,
		},
		{ name: "Using", symbols: [{ literal: "using" }, lexer.has("space") ? { type: "space" } : space, "Ann"], postprocess: P.Using },
		{
			name: "Using",
			symbols: [
				{ literal: "using" },
				lexer.has("space") ? { type: "space" } : space,
				"Ann",
				lexer.has("space") ? { type: "space" } : space,
				{ literal: "as" },
				lexer.has("space") ? { type: "space" } : space,
				"Identifier",
			],
			postprocess: P.Using,
		},
		{ name: "Foreign$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Foreign$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Foreign$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Foreign$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Foreign",
			symbols: [
				{ literal: "foreign" },
				lexer.has("space") ? { type: "space" } : space,
				"Identifier",
				"Foreign$ebnf$1",
				lexer.has("colon") ? { type: "colon" } : colon,
				"Foreign$ebnf$2",
				"TypeExpr",
			],
			postprocess: P.Foreign,
		},
		{ name: "Identifier", symbols: [lexer.has("variable") ? { type: "variable" } : variable], postprocess: P.Name },
		{
			name: "Identifier",
			symbols: [lexer.has("colon") ? { type: "colon" } : colon, lexer.has("variable") ? { type: "variable" } : variable],
			postprocess: P.Label,
		},
		{ name: "Quantity", symbols: [{ literal: "1" }], postprocess: () => Q.One },
		{ name: "Quantity", symbols: [{ literal: "0" }], postprocess: () => Q.Zero },
		{ name: "Quantity", symbols: [{ literal: "*" }], postprocess: () => Q.Many },
		{ name: "Match$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space] },
		{ name: "Match$ebnf$1", symbols: ["Match$ebnf$1", lexer.has("space") ? { type: "space" } : space], postprocess: d => d[0].concat([d[1]]) },
		{ name: "Match$ebnf$2", symbols: ["Alt"] },
		{ name: "Match$ebnf$2", symbols: ["Match$ebnf$2", "Alt"], postprocess: d => d[0].concat([d[1]]) },
		{ name: "Match", symbols: [{ literal: "match" }, "Match$ebnf$1", "TypeExpr", "Match$ebnf$2"], postprocess: P.Match },
		{ name: "Alt$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Alt$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Alt$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Alt$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Alt$ebnf$3", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Alt$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Alt$ebnf$4", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "Alt$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "Alt",
			symbols: [
				"Alt$ebnf$1",
				lexer.has("bar") ? { type: "bar" } : bar,
				"Alt$ebnf$2",
				"Pattern",
				"Alt$ebnf$3",
				lexer.has("arrow") ? { type: "arrow" } : arrow,
				"Alt$ebnf$4",
				"TypeExpr",
			],
			postprocess: P.Alternative,
		},
		{ name: "Pattern", symbols: ["PatAtom"], postprocess: id },
		{ name: "PatAtom", symbols: ["Identifier"], postprocess: P.Pattern.Var },
		{ name: "PatAtom", symbols: ["Literal"], postprocess: P.Pattern.Lit },
		{ name: "PatAtom$ebnf$1", symbols: [] },
		{
			name: "PatAtom$ebnf$1$subexpression$1",
			symbols: [
				"PatTagged",
				lexer.has("space") ? { type: "space" } : space,
				lexer.has("bar") ? { type: "bar" } : bar,
				lexer.has("space") ? { type: "space" } : space,
			],
		},
		{ name: "PatAtom$ebnf$1", symbols: ["PatAtom$ebnf$1", "PatAtom$ebnf$1$subexpression$1"], postprocess: d => d[0].concat([d[1]]) },
		{ name: "PatAtom", symbols: ["PatAtom$ebnf$1", "PatTagged"], postprocess: P.Pattern.Variant },
		{ name: "PatAtom$macrocall$2", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "PatAtom$macrocall$3", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "PatAtom$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$1", symbols: ["PatAtom$macrocall$2", "PatAtom$macrocall$1$ebnf$1", "PatAtom$macrocall$3"], postprocess: P.none },
		{ name: "PatAtom", symbols: ["PatAtom$macrocall$1"], postprocess: P.Pattern.Empty.Struct },
		{ name: "PatAtom$macrocall$5$macrocall$2", symbols: ["PatAtom"] },
		{ name: "PatAtom$macrocall$5$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "PatAtom$macrocall$5$macrocall$1$ebnf$1", symbols: [] },
		{ name: "PatAtom$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$5$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"PatAtom$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"PatAtom$macrocall$5$macrocall$2",
				"PatAtom$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"PatAtom$macrocall$5$macrocall$3",
			],
		},
		{
			name: "PatAtom$macrocall$5$macrocall$1$ebnf$1",
			symbols: ["PatAtom$macrocall$5$macrocall$1$ebnf$1", "PatAtom$macrocall$5$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "PatAtom$macrocall$5$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$5$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$5$macrocall$1",
			symbols: ["PatAtom$macrocall$5$macrocall$1$ebnf$1", "PatAtom$macrocall$5$macrocall$1$ebnf$2", "PatAtom$macrocall$5$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "PatAtom$macrocall$5$ebnf$1", symbols: ["RowTail"], postprocess: id },
		{ name: "PatAtom$macrocall$5$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$5", symbols: ["PatAtom$macrocall$5$macrocall$1", "PatAtom$macrocall$5$ebnf$1"] },
		{ name: "PatAtom$macrocall$4$macrocall$2", symbols: ["PatAtom$macrocall$5"] },
		{ name: "PatAtom$macrocall$4$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "PatAtom$macrocall$4$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "PatAtom$macrocall$4$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$4$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$4$macrocall$1",
			symbols: [
				"PatAtom$macrocall$4$macrocall$3",
				"PatAtom$macrocall$4$macrocall$2",
				"PatAtom$macrocall$4$macrocall$1$ebnf$1",
				"PatAtom$macrocall$4$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "PatAtom$macrocall$4", symbols: ["PatAtom$macrocall$4$macrocall$1"], postprocess: P.enclosed },
		{ name: "PatAtom", symbols: ["PatAtom$macrocall$4"], postprocess: P.Pattern.Tuple },
		{ name: "PatAtom$macrocall$7$macrocall$2", symbols: ["PatKeyVal"] },
		{ name: "PatAtom$macrocall$7$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "PatAtom$macrocall$7$macrocall$1$ebnf$1", symbols: [] },
		{ name: "PatAtom$macrocall$7$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$7$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$7$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$7$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$7$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"PatAtom$macrocall$7$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"PatAtom$macrocall$7$macrocall$2",
				"PatAtom$macrocall$7$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"PatAtom$macrocall$7$macrocall$3",
			],
		},
		{
			name: "PatAtom$macrocall$7$macrocall$1$ebnf$1",
			symbols: ["PatAtom$macrocall$7$macrocall$1$ebnf$1", "PatAtom$macrocall$7$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "PatAtom$macrocall$7$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$7$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$7$macrocall$1",
			symbols: ["PatAtom$macrocall$7$macrocall$1$ebnf$1", "PatAtom$macrocall$7$macrocall$1$ebnf$2", "PatAtom$macrocall$7$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "PatAtom$macrocall$7$ebnf$1", symbols: ["RowTail"], postprocess: id },
		{ name: "PatAtom$macrocall$7$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$7", symbols: ["PatAtom$macrocall$7$macrocall$1", "PatAtom$macrocall$7$ebnf$1"] },
		{ name: "PatAtom$macrocall$6$macrocall$2", symbols: ["PatAtom$macrocall$7"] },
		{ name: "PatAtom$macrocall$6$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "PatAtom$macrocall$6$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "PatAtom$macrocall$6$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$6$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$6$macrocall$1",
			symbols: [
				"PatAtom$macrocall$6$macrocall$3",
				"PatAtom$macrocall$6$macrocall$2",
				"PatAtom$macrocall$6$macrocall$1$ebnf$1",
				"PatAtom$macrocall$6$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "PatAtom$macrocall$6", symbols: ["PatAtom$macrocall$6$macrocall$1"], postprocess: P.enclosed },
		{ name: "PatAtom", symbols: ["PatAtom$macrocall$6"], postprocess: P.Pattern.Struct },
		{ name: "PatAtom$macrocall$9", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "PatAtom$macrocall$10", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "PatAtom$macrocall$8$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$8$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$8", symbols: ["PatAtom$macrocall$9", "PatAtom$macrocall$8$ebnf$1", "PatAtom$macrocall$10"], postprocess: P.none },
		{ name: "PatAtom", symbols: ["PatAtom$macrocall$8"], postprocess: P.Pattern.Empty.List },
		{ name: "PatAtom$macrocall$12$macrocall$2", symbols: ["PatAtom"] },
		{ name: "PatAtom$macrocall$12$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "PatAtom$macrocall$12$macrocall$1$ebnf$1", symbols: [] },
		{ name: "PatAtom$macrocall$12$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$12$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$12$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$12$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$12$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"PatAtom$macrocall$12$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"PatAtom$macrocall$12$macrocall$2",
				"PatAtom$macrocall$12$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"PatAtom$macrocall$12$macrocall$3",
			],
		},
		{
			name: "PatAtom$macrocall$12$macrocall$1$ebnf$1",
			symbols: ["PatAtom$macrocall$12$macrocall$1$ebnf$1", "PatAtom$macrocall$12$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "PatAtom$macrocall$12$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$12$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$12$macrocall$1",
			symbols: ["PatAtom$macrocall$12$macrocall$1$ebnf$1", "PatAtom$macrocall$12$macrocall$1$ebnf$2", "PatAtom$macrocall$12$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "PatAtom$macrocall$12$ebnf$1", symbols: ["RowTail"], postprocess: id },
		{ name: "PatAtom$macrocall$12$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$12", symbols: ["PatAtom$macrocall$12$macrocall$1", "PatAtom$macrocall$12$ebnf$1"] },
		{ name: "PatAtom$macrocall$11$macrocall$2", symbols: ["PatAtom$macrocall$12"] },
		{ name: "PatAtom$macrocall$11$macrocall$3", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "PatAtom$macrocall$11$macrocall$4", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "PatAtom$macrocall$11$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$11$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$11$macrocall$1",
			symbols: [
				"PatAtom$macrocall$11$macrocall$3",
				"PatAtom$macrocall$11$macrocall$2",
				"PatAtom$macrocall$11$macrocall$1$ebnf$1",
				"PatAtom$macrocall$11$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "PatAtom$macrocall$11", symbols: ["PatAtom$macrocall$11$macrocall$1"], postprocess: P.enclosed },
		{ name: "PatAtom", symbols: ["PatAtom$macrocall$11"], postprocess: P.Pattern.List },
		{ name: "PatAtom$macrocall$14$macrocall$2", symbols: ["PatKeyVal"] },
		{ name: "PatAtom$macrocall$14$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "PatAtom$macrocall$14$macrocall$1$ebnf$1", symbols: [] },
		{ name: "PatAtom$macrocall$14$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$14$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$14$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$14$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$14$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"PatAtom$macrocall$14$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"PatAtom$macrocall$14$macrocall$2",
				"PatAtom$macrocall$14$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"PatAtom$macrocall$14$macrocall$3",
			],
		},
		{
			name: "PatAtom$macrocall$14$macrocall$1$ebnf$1",
			symbols: ["PatAtom$macrocall$14$macrocall$1$ebnf$1", "PatAtom$macrocall$14$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "PatAtom$macrocall$14$macrocall$1$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$14$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$14$macrocall$1",
			symbols: ["PatAtom$macrocall$14$macrocall$1$ebnf$1", "PatAtom$macrocall$14$macrocall$1$ebnf$2", "PatAtom$macrocall$14$macrocall$2"],
			postprocess: P.many,
		},
		{ name: "PatAtom$macrocall$14$ebnf$1", symbols: ["RowTail"], postprocess: id },
		{ name: "PatAtom$macrocall$14$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatAtom$macrocall$14", symbols: ["PatAtom$macrocall$14$macrocall$1", "PatAtom$macrocall$14$ebnf$1"] },
		{ name: "PatAtom$macrocall$13$macrocall$2", symbols: ["PatAtom$macrocall$14"] },
		{ name: "PatAtom$macrocall$13$macrocall$3", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "PatAtom$macrocall$13$macrocall$4", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "PatAtom$macrocall$13$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$13$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$13$macrocall$1",
			symbols: [
				"PatAtom$macrocall$13$macrocall$3",
				"PatAtom$macrocall$13$macrocall$2",
				"PatAtom$macrocall$13$macrocall$1$ebnf$1",
				"PatAtom$macrocall$13$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "PatAtom$macrocall$13", symbols: ["PatAtom$macrocall$13$macrocall$1"], postprocess: P.enclosed },
		{ name: "PatAtom", symbols: ["PatAtom$macrocall$13"], postprocess: P.Pattern.Row },
		{ name: "PatAtom", symbols: ["Wildcard"], postprocess: P.Pattern.Wildcard },
		{ name: "PatAtom$macrocall$16", symbols: ["Pattern"] },
		{ name: "PatAtom$macrocall$15$macrocall$2", symbols: ["PatAtom$macrocall$16"] },
		{ name: "PatAtom$macrocall$15$macrocall$3", symbols: [lexer.has("lparens") ? { type: "lparens" } : lparens] },
		{ name: "PatAtom$macrocall$15$macrocall$4", symbols: [lexer.has("rparens") ? { type: "rparens" } : rparens] },
		{ name: "PatAtom$macrocall$15$macrocall$1$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatAtom$macrocall$15$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "PatAtom$macrocall$15$macrocall$1",
			symbols: [
				"PatAtom$macrocall$15$macrocall$3",
				"PatAtom$macrocall$15$macrocall$2",
				"PatAtom$macrocall$15$macrocall$1$ebnf$1",
				"PatAtom$macrocall$15$macrocall$4",
			],
			postprocess: P.unwrap,
		},
		{ name: "PatAtom$macrocall$15", symbols: ["PatAtom$macrocall$15$macrocall$1"], postprocess: P.enclosed },
		{ name: "PatAtom", symbols: ["PatAtom$macrocall$15"], postprocess: P.extract },
		{
			name: "PatTagged",
			symbols: [lexer.has("hash") ? { type: "hash" } : hash, "Identifier", lexer.has("space") ? { type: "space" } : space, "Pattern"],
			postprocess: P.taggedPat,
		},
		{ name: "PatKeyVal$ebnf$1", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatKeyVal$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "PatKeyVal$ebnf$2", symbols: [lexer.has("space") ? { type: "space" } : space], postprocess: id },
		{ name: "PatKeyVal$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "PatKeyVal",
			symbols: ["Identifier", "PatKeyVal$ebnf$1", lexer.has("colon") ? { type: "colon" } : colon, "PatKeyVal$ebnf$2", "Pattern"],
			postprocess: P.keyvalPat,
		},
		{ name: "Wildcard", symbols: [lexer.has("hole") ? { type: "hole" } : hole], postprocess: P.Wildcard },
		{ name: "Literal", symbols: ["String"], postprocess: P.Str },
		{ name: "Literal", symbols: ["Number"], postprocess: P.Num },
		{ name: "Literal", symbols: [{ literal: "Type" }], postprocess: P.Type },
		{ name: "Literal", symbols: [{ literal: "Unit" }], postprocess: P.Unit("type") },
		{ name: "Literal", symbols: [{ literal: "*" }], postprocess: P.Unit("value") },
		{ name: "Literal", symbols: [{ literal: "Row" }], postprocess: P.LitRow },
		{ name: "Number", symbols: ["Int", lexer.has("dot") ? { type: "dot" } : dot, "Int"], postprocess: id },
		{ name: "Number", symbols: ["Int"], postprocess: id },
		{ name: "Int", symbols: [lexer.has("digit") ? { type: "digit" } : digit], postprocess: P.sourceLoc },
		{ name: "String", symbols: [lexer.has("string") ? { type: "string" } : string], postprocess: P.sourceLoc },
	],
	ParserStart: "Module",
};

export default grammar;
