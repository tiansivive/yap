// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d: any[]): any {
	return d[0];
}
declare var NL: any;
declare var ws: any;
declare var colon: any;
declare var langle: any;
declare var rangle: any;
declare var op: any;
declare var hole: any;
declare var lparens: any;
declare var rparens: any;
declare var backslash: any;
declare var arrow: any;
declare var hash: any;
declare var fatArrow: any;
declare var lbrace: any;
declare var rbrace: any;
declare var comma: any;
declare var bar: any;
declare var lbracket: any;
declare var rbracket: any;
declare var semicolon: any;
declare var equals: any;
declare var variable: any;
declare var dot: any;
declare var number: any;
declare var string: any;

// Moo lexer documention is here:
// https://github.com/no-context/moo

import moo from "moo";
import Shared from "../shared";
import * as Src from "./src";
import * as Con from "./constructors";

const lexer = moo.compile({
	number: /[0-9]+/,
	variable: { match: /[a-zA-Z][a-zA-Z0-9]*/, type: moo.keywords({ ret: "return", dec: "let", match: "match", Type: "Type", Unit: "Unit" }) },
	string: /"(?:\\["bfnrt\/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*"/,
	dot: /\./,
	equals: /\=(?!>)/,
	backslash: /\\/,
	arrow: /->/,
	fatArrow: /\=>/,
	op: /[\+\-\*\/]/,
	ws: /[ \t]+/,
	lparens: /\(/,
	rparens: /\)/,
	lbrace: /\{/,
	rbrace: /\}/,
	langle: /</,
	rangle: />/,
	lbracket: /\[/,
	rbracket: /\]/,
	semicolon: /\;/,
	colon: /\:/,
	comma: /\,/,
	bar: /\|/,
	hash: /#/,
	hole: /_/,
	NL: { match: /\n+/, lineBreaks: true },
});

interface NearleyToken {
	value: any;
	[key: string]: any;
}

interface NearleyLexer {
	reset: (chunk: string, info: any) => void;
	next: () => NearleyToken | undefined;
	save: () => any;
	formatError: (token: never) => string;
	has: (tokenType: string) => boolean;
}

interface NearleyRule {
	name: string;
	symbols: NearleySymbol[];
	postprocess?: (d: any[], loc?: number, reject?: {}) => any;
}

type NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };

interface Grammar {
	Lexer: NearleyLexer | undefined;
	ParserRules: NearleyRule[];
	ParserStart: string;
}

const grammar: Grammar = {
	Lexer: lexer,
	ParserRules: [
		{ name: "Script$ebnf$1", symbols: ["Statement"] },
		{ name: "Script$ebnf$1", symbols: ["Script$ebnf$1", "Statement"], postprocess: d => d[0].concat([d[1]]) },
		{ name: "Script$ebnf$2", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Script$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Script", symbols: ["Script$ebnf$1", "Script$ebnf$2"], postprocess: d => ({ type: "script", script: d[0] }) },
		{ name: "Script", symbols: ["Ann"], postprocess: id },
		{ name: "Ann$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Ann$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Ann$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Ann$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Ann", symbols: ["Ann", "Ann$ebnf$1", lexer.has("colon") ? { type: "colon" } : colon, "Ann$ebnf$2", "TypeExpr"], postprocess: Con.Annotation },
		{ name: "Ann$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Ann$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Ann$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Ann$ebnf$4", symbols: [], postprocess: () => null },
		{ name: "Ann$macrocall$2", symbols: ["Quantity"] },
		{ name: "Ann$macrocall$1$macrocall$2", symbols: ["Ann$macrocall$2"] },
		{ name: "Ann$macrocall$1$macrocall$3", symbols: [lexer.has("langle") ? { type: "langle" } : langle] },
		{ name: "Ann$macrocall$1$macrocall$4", symbols: [lexer.has("rangle") ? { type: "rangle" } : rangle] },
		{ name: "Ann$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Ann$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Ann$macrocall$1$macrocall$1",
			symbols: ["Ann$macrocall$1$macrocall$3", "Ann$macrocall$1$macrocall$2", "Ann$macrocall$1$macrocall$1$ebnf$1", "Ann$macrocall$1$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Ann$macrocall$1", symbols: ["Ann$macrocall$1$macrocall$1"], postprocess: id },
		{ name: "Ann$ebnf$5", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Ann$ebnf$5", symbols: [], postprocess: () => null },
		{
			name: "Ann",
			symbols: ["Ann", "Ann$ebnf$3", lexer.has("colon") ? { type: "colon" } : colon, "Ann$ebnf$4", "Ann$macrocall$1", "Ann$ebnf$5", "TypeExpr"],
			postprocess: Con.Annotation,
		},
		{ name: "Ann", symbols: ["TypeExpr"], postprocess: id },
		{ name: "TypeExpr", symbols: ["Pi"], postprocess: id },
		{ name: "TypeExpr", symbols: ["Variant"], postprocess: id },
		{ name: "TypeExpr", symbols: ["App"], postprocess: id },
		{ name: "App", symbols: ["App", lexer.has("ws") ? { type: "ws" } : ws, "Expr"], postprocess: Con.Application },
		{ name: "App$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "App$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "App$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "App$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "App", symbols: ["App", "App$ebnf$1", lexer.has("op") ? { type: "op" } : op, "App$ebnf$2", "Expr"], postprocess: Con.Operation },
		{ name: "App", symbols: ["Expr"], postprocess: id },
		{ name: "Expr", symbols: ["Lambda"], postprocess: id },
		{ name: "Expr", symbols: ["Match"], postprocess: id },
		{ name: "Expr", symbols: ["Block"], postprocess: id },
		{ name: "Expr", symbols: ["Struct"], postprocess: id },
		{ name: "Expr", symbols: ["Row"], postprocess: id },
		{ name: "Expr", symbols: ["Tuple"], postprocess: id },
		{ name: "Expr", symbols: ["List"], postprocess: id },
		{ name: "Expr", symbols: ["Atom"], postprocess: id },
		{ name: "Atom", symbols: ["Identifier"], postprocess: Con.Var },
		{ name: "Atom", symbols: ["Literal"], postprocess: Con.Lit },
		{ name: "Atom", symbols: [lexer.has("hole") ? { type: "hole" } : hole], postprocess: Con.Hole },
		{ name: "Atom$macrocall$2", symbols: ["Ann"] },
		{ name: "Atom$macrocall$1$macrocall$2", symbols: ["Atom$macrocall$2"] },
		{ name: "Atom$macrocall$1$macrocall$3", symbols: [lexer.has("lparens") ? { type: "lparens" } : lparens] },
		{ name: "Atom$macrocall$1$macrocall$4", symbols: [lexer.has("rparens") ? { type: "rparens" } : rparens] },
		{ name: "Atom$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Atom$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Atom$macrocall$1$macrocall$1",
			symbols: ["Atom$macrocall$1$macrocall$3", "Atom$macrocall$1$macrocall$2", "Atom$macrocall$1$macrocall$1$ebnf$1", "Atom$macrocall$1$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Atom$macrocall$1", symbols: ["Atom$macrocall$1$macrocall$1"], postprocess: id },
		{ name: "Atom", symbols: ["Atom$macrocall$1"], postprocess: Con.extract },
		{
			name: "Lambda",
			symbols: [
				lexer.has("backslash") ? { type: "backslash" } : backslash,
				"Param",
				lexer.has("ws") ? { type: "ws" } : ws,
				lexer.has("arrow") ? { type: "arrow" } : arrow,
				lexer.has("ws") ? { type: "ws" } : ws,
				"Expr",
			],
			postprocess: Con.Lambda,
		},
		{
			name: "Lambda",
			symbols: [
				lexer.has("backslash") ? { type: "backslash" } : backslash,
				lexer.has("hash") ? { type: "hash" } : hash,
				"Param",
				lexer.has("ws") ? { type: "ws" } : ws,
				lexer.has("fatArrow") ? { type: "fatArrow" } : fatArrow,
				lexer.has("ws") ? { type: "ws" } : ws,
				"Expr",
			],
			postprocess: Con.Lambda,
		},
		{ name: "Param", symbols: ["Identifier"], postprocess: Con.Param },
		{ name: "Param$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Param$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Param$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Param$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Param", symbols: ["Identifier", "Param$ebnf$1", lexer.has("colon") ? { type: "colon" } : colon, "Param$ebnf$2", "Expr"], postprocess: Con.Param },
		{ name: "Param$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Param$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Param$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Param$ebnf$4", symbols: [], postprocess: () => null },
		{ name: "Param$macrocall$2", symbols: ["Quantity"] },
		{ name: "Param$macrocall$1$macrocall$2", symbols: ["Param$macrocall$2"] },
		{ name: "Param$macrocall$1$macrocall$3", symbols: [lexer.has("langle") ? { type: "langle" } : langle] },
		{ name: "Param$macrocall$1$macrocall$4", symbols: [lexer.has("rangle") ? { type: "rangle" } : rangle] },
		{ name: "Param$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Param$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Param$macrocall$1$macrocall$1",
			symbols: ["Param$macrocall$1$macrocall$3", "Param$macrocall$1$macrocall$2", "Param$macrocall$1$macrocall$1$ebnf$1", "Param$macrocall$1$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Param$macrocall$1", symbols: ["Param$macrocall$1$macrocall$1"], postprocess: id },
		{ name: "Param$ebnf$5", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Param$ebnf$5", symbols: [], postprocess: () => null },
		{
			name: "Param",
			symbols: ["Identifier", "Param$ebnf$3", lexer.has("colon") ? { type: "colon" } : colon, "Param$ebnf$4", "Param$macrocall$1", "Param$ebnf$5", "Expr"],
			postprocess: Con.Param,
		},
		{ name: "Param$macrocall$4", symbols: ["Param"] },
		{ name: "Param$macrocall$3$macrocall$2", symbols: ["Param$macrocall$4"] },
		{ name: "Param$macrocall$3$macrocall$3", symbols: [lexer.has("lparens") ? { type: "lparens" } : lparens] },
		{ name: "Param$macrocall$3$macrocall$4", symbols: [lexer.has("rparens") ? { type: "rparens" } : rparens] },
		{ name: "Param$macrocall$3$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Param$macrocall$3$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Param$macrocall$3$macrocall$1",
			symbols: ["Param$macrocall$3$macrocall$3", "Param$macrocall$3$macrocall$2", "Param$macrocall$3$macrocall$1$ebnf$1", "Param$macrocall$3$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Param$macrocall$3", symbols: ["Param$macrocall$3$macrocall$1"], postprocess: id },
		{ name: "Param", symbols: ["Param$macrocall$3"], postprocess: Con.extract },
		{ name: "Pi$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Pi$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Pi",
			symbols: ["Expr", "Pi$ebnf$1", lexer.has("arrow") ? { type: "arrow" } : arrow, lexer.has("ws") ? { type: "ws" } : ws, "PiTail"],
			postprocess: Con.Pi("Explicit"),
		},
		{ name: "Pi$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Pi$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Pi",
			symbols: ["Expr", "Pi$ebnf$2", lexer.has("fatArrow") ? { type: "fatArrow" } : fatArrow, lexer.has("ws") ? { type: "ws" } : ws, "PiTail"],
			postprocess: Con.Pi("Implicit"),
		},
		{ name: "PiTail", symbols: ["Pi"], postprocess: id },
		{ name: "PiTail", symbols: ["Atom"], postprocess: id },
		{ name: "Struct$macrocall$2", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Struct$macrocall$3", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Struct$macrocall$1$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Struct$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Struct$macrocall$1$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Struct$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Struct$macrocall$1$ebnf$3", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Struct$macrocall$1$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "Struct$macrocall$1",
			symbols: ["Struct$macrocall$2", "Struct$macrocall$1$ebnf$1", "Struct$macrocall$1$ebnf$2", "Struct$macrocall$1$ebnf$3", "Struct$macrocall$3"],
			postprocess: Con.none,
		},
		{ name: "Struct", symbols: ["Struct$macrocall$1"], postprocess: Con.emptyStruct },
		{ name: "Struct$macrocall$5$macrocall$2", symbols: ["KeyVal"] },
		{ name: "Struct$macrocall$5$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Struct$macrocall$5$macrocall$2",
				"Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$3",
				"Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$4",
				"Struct$macrocall$5$macrocall$3",
			],
		},
		{
			name: "Struct$macrocall$5$macrocall$1$ebnf$1",
			symbols: ["Struct$macrocall$5$macrocall$1$ebnf$1", "Struct$macrocall$5$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$2", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Struct$macrocall$5$macrocall$1$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "Struct$macrocall$5$macrocall$1",
			symbols: [
				"Struct$macrocall$5$macrocall$1$ebnf$1",
				"Struct$macrocall$5$macrocall$1$ebnf$2",
				"Struct$macrocall$5$macrocall$1$ebnf$3",
				"Struct$macrocall$5$macrocall$2",
			],
			postprocess: Con.many,
		},
		{ name: "Struct$macrocall$5", symbols: ["Struct$macrocall$5$macrocall$1"] },
		{ name: "Struct$macrocall$4$macrocall$2", symbols: ["Struct$macrocall$5"] },
		{ name: "Struct$macrocall$4$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Struct$macrocall$4$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Struct$macrocall$4$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Struct$macrocall$4$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Struct$macrocall$4$macrocall$1",
			symbols: ["Struct$macrocall$4$macrocall$3", "Struct$macrocall$4$macrocall$2", "Struct$macrocall$4$macrocall$1$ebnf$1", "Struct$macrocall$4$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Struct$macrocall$4", symbols: ["Struct$macrocall$4$macrocall$1"], postprocess: id },
		{ name: "Struct", symbols: ["Struct$macrocall$4"], postprocess: Con.struct },
		{ name: "Variant$macrocall$2", symbols: ["KeyVal"] },
		{ name: "Variant$macrocall$3", symbols: [lexer.has("bar") ? { type: "bar" } : bar] },
		{ name: "Variant$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "Variant$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Variant$macrocall$2",
				"Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$3",
				"Variant$macrocall$1$ebnf$1$subexpression$1$ebnf$4",
				"Variant$macrocall$3",
			],
		},
		{
			name: "Variant$macrocall$1$ebnf$1",
			symbols: ["Variant$macrocall$1$ebnf$1", "Variant$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Variant$macrocall$1$ebnf$2", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Variant$macrocall$1$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Variant$macrocall$1$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "Variant$macrocall$1",
			symbols: ["Variant$macrocall$1$ebnf$1", "Variant$macrocall$1$ebnf$2", "Variant$macrocall$1$ebnf$3", "Variant$macrocall$2"],
			postprocess: Con.many,
		},
		{ name: "Variant", symbols: [lexer.has("bar") ? { type: "bar" } : bar, "Variant$macrocall$1"], postprocess: Con.Variant },
		{ name: "Row$macrocall$2", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "Row$macrocall$3", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "Row$macrocall$1$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Row$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Row$macrocall$1$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Row$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Row$macrocall$1$ebnf$3", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Row$macrocall$1$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "Row$macrocall$1",
			symbols: ["Row$macrocall$2", "Row$macrocall$1$ebnf$1", "Row$macrocall$1$ebnf$2", "Row$macrocall$1$ebnf$3", "Row$macrocall$3"],
			postprocess: Con.none,
		},
		{ name: "Row", symbols: ["Row$macrocall$1"], postprocess: Con.emptyRow },
		{ name: "Row$macrocall$5$macrocall$2", symbols: ["KeyVal"] },
		{ name: "Row$macrocall$5$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Row$macrocall$5$macrocall$2",
				"Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$3",
				"Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1$ebnf$4",
				"Row$macrocall$5$macrocall$3",
			],
		},
		{
			name: "Row$macrocall$5$macrocall$1$ebnf$1",
			symbols: ["Row$macrocall$5$macrocall$1$ebnf$1", "Row$macrocall$5$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Row$macrocall$5$macrocall$1$ebnf$2", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Row$macrocall$5$macrocall$1$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "Row$macrocall$5$macrocall$1",
			symbols: [
				"Row$macrocall$5$macrocall$1$ebnf$1",
				"Row$macrocall$5$macrocall$1$ebnf$2",
				"Row$macrocall$5$macrocall$1$ebnf$3",
				"Row$macrocall$5$macrocall$2",
			],
			postprocess: Con.many,
		},
		{ name: "Row$macrocall$5", symbols: ["Row$macrocall$5$macrocall$1"] },
		{ name: "Row$macrocall$4$macrocall$2", symbols: ["Row$macrocall$5"] },
		{ name: "Row$macrocall$4$macrocall$3", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "Row$macrocall$4$macrocall$4", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "Row$macrocall$4$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Row$macrocall$4$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Row$macrocall$4$macrocall$1",
			symbols: ["Row$macrocall$4$macrocall$3", "Row$macrocall$4$macrocall$2", "Row$macrocall$4$macrocall$1$ebnf$1", "Row$macrocall$4$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Row$macrocall$4", symbols: ["Row$macrocall$4$macrocall$1"], postprocess: id },
		{ name: "Row", symbols: ["Row$macrocall$4"], postprocess: Con.row },
		{ name: "KeyVal$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "KeyVal$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "KeyVal$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "KeyVal$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "KeyVal",
			symbols: ["Identifier", "KeyVal$ebnf$1", lexer.has("colon") ? { type: "colon" } : colon, "KeyVal$ebnf$2", "Expr"],
			postprocess: Con.keyval,
		},
		{ name: "Tuple$macrocall$2$macrocall$2", symbols: ["Expr"] },
		{ name: "Tuple$macrocall$2$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Tuple$macrocall$2$macrocall$2",
				"Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3",
				"Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4",
				"Tuple$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Tuple$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Tuple$macrocall$2$macrocall$1$ebnf$1", "Tuple$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Tuple$macrocall$2$macrocall$1$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "Tuple$macrocall$2$macrocall$1",
			symbols: [
				"Tuple$macrocall$2$macrocall$1$ebnf$1",
				"Tuple$macrocall$2$macrocall$1$ebnf$2",
				"Tuple$macrocall$2$macrocall$1$ebnf$3",
				"Tuple$macrocall$2$macrocall$2",
			],
			postprocess: Con.many,
		},
		{ name: "Tuple$macrocall$2", symbols: ["Tuple$macrocall$2$macrocall$1"] },
		{ name: "Tuple$macrocall$1$macrocall$2", symbols: ["Tuple$macrocall$2"] },
		{ name: "Tuple$macrocall$1$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Tuple$macrocall$1$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Tuple$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Tuple$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Tuple$macrocall$1$macrocall$1",
			symbols: ["Tuple$macrocall$1$macrocall$3", "Tuple$macrocall$1$macrocall$2", "Tuple$macrocall$1$macrocall$1$ebnf$1", "Tuple$macrocall$1$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Tuple$macrocall$1", symbols: ["Tuple$macrocall$1$macrocall$1"], postprocess: id },
		{ name: "Tuple", symbols: ["Tuple$macrocall$1"], postprocess: Con.tuple },
		{ name: "List$macrocall$2$macrocall$2", symbols: ["Expr"] },
		{ name: "List$macrocall$2$macrocall$3", symbols: [lexer.has("comma") ? { type: "comma" } : comma] },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"List$macrocall$2$macrocall$2",
				"List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3",
				"List$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4",
				"List$macrocall$2$macrocall$3",
			],
		},
		{
			name: "List$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["List$macrocall$2$macrocall$1$ebnf$1", "List$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "List$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "List$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "List$macrocall$2$macrocall$1$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "List$macrocall$2$macrocall$1$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "List$macrocall$2$macrocall$1",
			symbols: [
				"List$macrocall$2$macrocall$1$ebnf$1",
				"List$macrocall$2$macrocall$1$ebnf$2",
				"List$macrocall$2$macrocall$1$ebnf$3",
				"List$macrocall$2$macrocall$2",
			],
			postprocess: Con.many,
		},
		{ name: "List$macrocall$2", symbols: ["List$macrocall$2$macrocall$1"] },
		{ name: "List$macrocall$1$macrocall$2", symbols: ["List$macrocall$2"] },
		{ name: "List$macrocall$1$macrocall$3", symbols: [lexer.has("lbracket") ? { type: "lbracket" } : lbracket] },
		{ name: "List$macrocall$1$macrocall$4", symbols: [lexer.has("rbracket") ? { type: "rbracket" } : rbracket] },
		{ name: "List$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "List$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "List$macrocall$1$macrocall$1",
			symbols: ["List$macrocall$1$macrocall$3", "List$macrocall$1$macrocall$2", "List$macrocall$1$macrocall$1$ebnf$1", "List$macrocall$1$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "List$macrocall$1", symbols: ["List$macrocall$1$macrocall$1"], postprocess: id },
		{ name: "List", symbols: ["List$macrocall$1"], postprocess: Con.list },
		{ name: "Block$macrocall$2$macrocall$2", symbols: ["Statement"] },
		{ name: "Block$macrocall$2$macrocall$3", symbols: [lexer.has("semicolon") ? { type: "semicolon" } : semicolon] },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1", symbols: [] },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1",
			symbols: [
				"Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$1",
				"Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$2",
				"Block$macrocall$2$macrocall$2",
				"Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$3",
				"Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1$ebnf$4",
				"Block$macrocall$2$macrocall$3",
			],
		},
		{
			name: "Block$macrocall$2$macrocall$1$ebnf$1",
			symbols: ["Block$macrocall$2$macrocall$1$ebnf$1", "Block$macrocall$2$macrocall$1$ebnf$1$subexpression$1"],
			postprocess: d => d[0].concat([d[1]]),
		},
		{ name: "Block$macrocall$2$macrocall$1$ebnf$2", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Block$macrocall$2$macrocall$1$ebnf$3", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$2$macrocall$1",
			symbols: [
				"Block$macrocall$2$macrocall$1$ebnf$1",
				"Block$macrocall$2$macrocall$1$ebnf$2",
				"Block$macrocall$2$macrocall$1$ebnf$3",
				"Block$macrocall$2$macrocall$2",
			],
			postprocess: Con.many,
		},
		{ name: "Block$macrocall$2$ebnf$1", symbols: ["Return"], postprocess: id },
		{ name: "Block$macrocall$2$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$2",
			symbols: ["Block$macrocall$2$macrocall$1", lexer.has("semicolon") ? { type: "semicolon" } : semicolon, "Block$macrocall$2$ebnf$1"],
		},
		{ name: "Block$macrocall$1$macrocall$2", symbols: ["Block$macrocall$2"] },
		{ name: "Block$macrocall$1$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Block$macrocall$1$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Block$macrocall$1$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Block$macrocall$1$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$1$macrocall$1",
			symbols: ["Block$macrocall$1$macrocall$3", "Block$macrocall$1$macrocall$2", "Block$macrocall$1$macrocall$1$ebnf$1", "Block$macrocall$1$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Block$macrocall$1", symbols: ["Block$macrocall$1$macrocall$1"], postprocess: id },
		{ name: "Block", symbols: ["Block$macrocall$1"], postprocess: Con.Block },
		{ name: "Block$macrocall$4", symbols: ["Return"] },
		{ name: "Block$macrocall$3$macrocall$2", symbols: ["Block$macrocall$4"] },
		{ name: "Block$macrocall$3$macrocall$3", symbols: [lexer.has("lbrace") ? { type: "lbrace" } : lbrace] },
		{ name: "Block$macrocall$3$macrocall$4", symbols: [lexer.has("rbrace") ? { type: "rbrace" } : rbrace] },
		{ name: "Block$macrocall$3$macrocall$1$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Block$macrocall$3$macrocall$1$ebnf$1", symbols: [], postprocess: () => null },
		{
			name: "Block$macrocall$3$macrocall$1",
			symbols: ["Block$macrocall$3$macrocall$3", "Block$macrocall$3$macrocall$2", "Block$macrocall$3$macrocall$1$ebnf$1", "Block$macrocall$3$macrocall$4"],
			postprocess: Con.unwrap,
		},
		{ name: "Block$macrocall$3", symbols: ["Block$macrocall$3$macrocall$1"], postprocess: id },
		{ name: "Block", symbols: ["Block$macrocall$3"], postprocess: Con.Block },
		{ name: "Statement", symbols: ["Expr"], postprocess: Con.Expr },
		{ name: "Statement", symbols: ["Letdec"], postprocess: id },
		{ name: "Return$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Return$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Return$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Return$ebnf$2", symbols: [], postprocess: () => null },
		{ name: "Return$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws] },
		{ name: "Return$ebnf$3", symbols: ["Return$ebnf$3", lexer.has("ws") ? { type: "ws" } : ws], postprocess: d => d[0].concat([d[1]]) },
		{
			name: "Return",
			symbols: ["Return$ebnf$1", "Return$ebnf$2", { literal: "return" }, "Return$ebnf$3", "Expr", lexer.has("semicolon") ? { type: "semicolon" } : semicolon],
			postprocess: Con.Return,
		},
		{ name: "Letdec$ebnf$1", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Letdec$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Letdec$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Letdec$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Letdec",
			symbols: [
				{ literal: "let" },
				lexer.has("ws") ? { type: "ws" } : ws,
				"Identifier",
				"Letdec$ebnf$1",
				lexer.has("equals") ? { type: "equals" } : equals,
				"Letdec$ebnf$2",
				"Expr",
			],
			postprocess: Con.LetDec,
		},
		{ name: "Letdec$ebnf$3", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Letdec$ebnf$3", symbols: [], postprocess: () => null },
		{ name: "Letdec$ebnf$4", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Letdec$ebnf$4", symbols: [], postprocess: () => null },
		{ name: "Letdec$ebnf$5", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Letdec$ebnf$5", symbols: [], postprocess: () => null },
		{ name: "Letdec$ebnf$6", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Letdec$ebnf$6", symbols: [], postprocess: () => null },
		{
			name: "Letdec",
			symbols: [
				{ literal: "let" },
				lexer.has("ws") ? { type: "ws" } : ws,
				"Identifier",
				"Letdec$ebnf$3",
				lexer.has("colon") ? { type: "colon" } : colon,
				"Letdec$ebnf$4",
				"Expr",
				"Letdec$ebnf$5",
				lexer.has("equals") ? { type: "equals" } : equals,
				"Letdec$ebnf$6",
				"Expr",
			],
			postprocess: Con.LetDec,
		},
		{ name: "Identifier", symbols: [lexer.has("variable") ? { type: "variable" } : variable], postprocess: Con.Name },
		{ name: "Quantity", symbols: [{ literal: "1" }], postprocess: () => Shared.One },
		{ name: "Quantity", symbols: [{ literal: "0" }], postprocess: () => Shared.Zero },
		{ name: "Quantity", symbols: [{ literal: "*" }], postprocess: () => Shared.Many },
		{ name: "Match$ebnf$1", symbols: ["Alt"] },
		{ name: "Match$ebnf$1", symbols: ["Match$ebnf$1", "Alt"], postprocess: d => d[0].concat([d[1]]) },
		{
			name: "Match",
			symbols: [{ literal: "match" }, lexer.has("ws") ? { type: "ws" } : ws, "Expr", "Match$ebnf$1"],
			postprocess: d => ({ type: "match", scrutinee: d[2], alternatives: d[3] }),
		},
		{ name: "Alt$ebnf$1", symbols: [lexer.has("NL") ? { type: "NL" } : NL], postprocess: id },
		{ name: "Alt$ebnf$1", symbols: [], postprocess: () => null },
		{ name: "Alt$ebnf$2", symbols: [lexer.has("ws") ? { type: "ws" } : ws], postprocess: id },
		{ name: "Alt$ebnf$2", symbols: [], postprocess: () => null },
		{
			name: "Alt",
			symbols: [
				"Alt$ebnf$1",
				"Alt$ebnf$2",
				lexer.has("bar") ? { type: "bar" } : bar,
				lexer.has("ws") ? { type: "ws" } : ws,
				"Pattern",
				lexer.has("ws") ? { type: "ws" } : ws,
				lexer.has("arrow") ? { type: "arrow" } : arrow,
				lexer.has("ws") ? { type: "ws" } : ws,
				"Expr",
			],
			postprocess: d => ({ type: "alternative", pattern: d[4], body: d[8] }),
		},
		{ name: "Pattern", symbols: ["Identifier"], postprocess: d => ({ type: "Var", binding: d[0] }) },
		{ name: "Literal", symbols: ["String"], postprocess: ([s]) => Shared.String(s) },
		{ name: "Literal", symbols: ["Number"], postprocess: ([n]) => Shared.Num(n) },
		{ name: "Literal", symbols: [{ literal: "Type" }], postprocess: () => Shared.Type() },
		{ name: "Literal", symbols: [{ literal: "Unit" }], postprocess: () => Shared.Unit() },
		{ name: "Number", symbols: ["Int", lexer.has("dot") ? { type: "dot" } : dot, "Int"], postprocess: d => parseFloat(d.join("")) },
		{ name: "Number", symbols: ["Int"], postprocess: d => parseInt(d) },
		{ name: "Int", symbols: [lexer.has("number") ? { type: "number" } : number], postprocess: id },
		{ name: "String", symbols: [lexer.has("string") ? { type: "string" } : string], postprocess: d => d[0].value.slice(1, -1) },
	],
	ParserStart: "Script",
};

export default grammar;
